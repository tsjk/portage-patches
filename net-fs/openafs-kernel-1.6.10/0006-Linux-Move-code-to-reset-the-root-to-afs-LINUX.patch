From 43136fe416dec49a0bf72cbdbd3457f238e51f17 Mon Sep 17 00:00:00 2001
From: Marc Dionne <marc.dionne@your-file-system.com>
Date: Thu, 18 Dec 2014 06:57:22 -0500
Subject: [PATCH 06/11] Linux: Move code to reset the root to afs/LINUX
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Move the Linux specific bit of code to reset the root to
afs/LINUX platform specific files.  Things that play with
the Linux vfs internals should not be exposed here.

No functional change, but this helps cleanup some ifdef
mess.

Reviewed-on: http://gerrit.openafs.org/11641
Tested-by: BuildBot <buildbot@rampaginggeek.com>
Reviewed-by: Michael La√ü <lass@mail.uni-paderborn.de>
Reviewed-by: Daria Brashear <shadow@your-file-system.com>
(cherry picked from commit 6ca324e565c34d9d04f3c553b7d0febe675ae538)

Change-Id: I82803669dd34d7abeb29040fbb38ec2f000f2601
Reviewed-on: http://gerrit.openafs.org/11658
Tested-by: BuildBot <buildbot@rampaginggeek.com>
Reviewed-by: Chas Williams - CONTRACTOR <chas@cmf.nrl.navy.mil>
Reviewed-by: Daria Brashear <shadow@your-file-system.com>
Reviewed-by: Stephan Wiesand <stephan.wiesand@desy.de>
(cherry picked from commit a6013738362f4d1487ca57282b2428e3ba962720)
---
 src/afs/LINUX/osi_prototypes.h   |  3 ++
 src/afs/LINUX/osi_vcache.c       | 61 ++++++++++++++++++++++++++++++++++++
 src/afs/LINUX24/osi_prototypes.h |  3 ++
 src/afs/LINUX24/osi_vcache.c     | 36 +++++++++++++++++++++
 src/afs/afs_daemons.c            | 67 +++-------------------------------------
 5 files changed, 108 insertions(+), 62 deletions(-)

diff --git a/src/afs/LINUX/osi_prototypes.h b/src/afs/LINUX/osi_prototypes.h
index 9002882..1d2ca0d 100644
--- a/src/afs/LINUX/osi_prototypes.h
+++ b/src/afs/LINUX/osi_prototypes.h
@@ -79,6 +79,9 @@ extern void osi_VM_FlushPages(struct vcache *avc, afs_ucred_t *credp);
 extern void osi_VM_Truncate(struct vcache *avc, int alen,
 			    afs_ucred_t *acred);
 
+/* osi_vcache.c */
+extern void osi_ResetRootVCache(afs_uint32 volid);
+
 /* osi_vfsops.c */
 extern void vattr2inode(struct inode *ip, struct vattr *vp);
 extern int afs_init_inodecache(void);
diff --git a/src/afs/LINUX/osi_vcache.c b/src/afs/LINUX/osi_vcache.c
index 1d0db82..391e7d4 100644
--- a/src/afs/LINUX/osi_vcache.c
+++ b/src/afs/LINUX/osi_vcache.c
@@ -143,3 +143,64 @@ osi_PostPopulateVCache(struct vcache *avc) {
     vSetType(avc, VREG);
 }
 
+/**
+ * osi_ResetRootVCache - Reset the root vcache
+ * Reset the dentry associated with the afs root.
+ * Called from afs_CheckRootVolume when we notice that
+ * the root volume ID has changed.
+ *
+ * @volid: volume ID for the afs root
+ */
+void
+osi_ResetRootVCache(afs_uint32 volid)
+{
+    struct vrequest *treq = NULL;
+    struct vattr vattr;
+    cred_t *credp;
+    struct dentry *dp;
+    struct vcache *vcp;
+    struct inode *root = AFSTOV(afs_globalVp);
+
+    afs_rootFid.Fid.Volume = volid;
+    afs_rootFid.Fid.Vnode = 1;
+    afs_rootFid.Fid.Unique = 1;
+
+    credp = crref();
+    if (afs_CreateReq(&treq, credp))
+	goto out;
+    vcp = afs_GetVCache(&afs_rootFid, treq, NULL, NULL);
+    if (!vcp)
+	goto out;
+    afs_getattr(vcp, &vattr, credp);
+    afs_fill_inode(AFSTOV(vcp), &vattr);
+
+    dp = d_find_alias(root);
+
+#if defined(HAVE_DCACHE_LOCK)
+    spin_lock(&dcache_lock);
+#else
+    spin_lock(&AFSTOV(vcp)->i_lock);
+#endif
+    spin_lock(&dp->d_lock);
+#if defined(D_ALIAS_IS_HLIST)
+    hlist_del_init(&dp->d_alias);
+    hlist_add_head(&dp->d_alias, &(AFSTOV(vcp)->i_dentry));
+#else
+    list_del_init(&dp->d_alias);
+    list_add(&dp->d_alias, &(AFSTOV(vcp)->i_dentry));
+#endif
+    dp->d_inode = AFSTOV(vcp);
+    spin_unlock(&dp->d_lock);
+#if defined(HAVE_DCACHE_LOCK)
+    spin_unlock(&dcache_lock);
+#else
+    spin_unlock(&AFSTOV(vcp)->i_lock);
+#endif
+    dput(dp);
+
+    AFS_RELE(root);
+    afs_globalVp = vcp;
+out:
+    crfree(credp);
+    afs_DestroyReq(treq);
+}
diff --git a/src/afs/LINUX24/osi_prototypes.h b/src/afs/LINUX24/osi_prototypes.h
index ad2522c..39d6402 100644
--- a/src/afs/LINUX24/osi_prototypes.h
+++ b/src/afs/LINUX24/osi_prototypes.h
@@ -69,6 +69,9 @@ extern void osi_syscall_clean(void);
 extern int osi_sysctl_init(void);
 extern void osi_sysctl_clean(void);
 
+/* osi_vcache.c */
+extern void osi_ResetRootVCache(afs_uint32 volid);
+
 /* osi_vm.c */
 extern int osi_VM_FlushVCache(struct vcache *avc, int *slept);
 extern void osi_VM_TryToSmush(struct vcache *avc, afs_ucred_t *acred,
diff --git a/src/afs/LINUX24/osi_vcache.c b/src/afs/LINUX24/osi_vcache.c
index bbaf5ce..853a357 100644
--- a/src/afs/LINUX24/osi_vcache.c
+++ b/src/afs/LINUX24/osi_vcache.c
@@ -119,3 +119,39 @@ osi_PostPopulateVCache(struct vcache *avc) {
     vSetType(avc, VREG);
 }
 
+void
+osi_ResetRootVCache(afs_uint32 volid)
+{
+    struct vrequest *treq = NULL;
+    struct vattr vattr;
+    cred_t *credp;
+    struct dentry *dp;
+    struct vcache *vcp;
+
+    afs_rootFid.Fid.Volume = volid;
+    afs_rootFid.Fid.Vnode = 1;
+    afs_rootFid.Fid.Unique = 1;
+
+    credp = crref();
+    if (afs_CreateReq(&treq, credp))
+	goto out;
+    vcp = afs_GetVCache(&afs_rootFid, treq, NULL, NULL);
+    if (!vcp)
+	goto out;
+    afs_getattr(vcp, &vattr, credp);
+    afs_fill_inode(AFSTOV(vcp), &vattr);
+
+    dp = d_find_alias(AFSTOV(afs_globalVp));
+    spin_lock(&dcache_lock);
+    list_del_init(&dp->d_alias);
+    list_add(&dp->d_alias, &(AFSTOV(vcp)->i_dentry));
+    dp->d_inode = AFSTOV(vcp);
+    spin_unlock(&dcache_lock);
+    dput(dp);
+
+    AFS_FAST_RELE(afs_globalVp);
+    afs_globalVp = vcp;
+out:
+    crfree(credp);
+    afs_DestroyReq(treq);
+}
diff --git a/src/afs/afs_daemons.c b/src/afs/afs_daemons.c
index 8e5f6ad..c26cdee 100644
--- a/src/afs/afs_daemons.c
+++ b/src/afs/afs_daemons.c
@@ -363,71 +363,14 @@ afs_CheckRootVolume(void)
 		 * count to zero and fs checkv is executed when the current
 		 * directory is /afs.
 		 */
-#ifdef AFS_LINUX20_ENV
-		{
-		    struct vrequest *treq = NULL;
-		    struct vattr vattr;
-		    cred_t *credp;
-		    struct dentry *dp;
-		    struct vcache *vcp;
-
-		    afs_rootFid.Fid.Volume = volid;
-		    afs_rootFid.Fid.Vnode = 1;
-		    afs_rootFid.Fid.Unique = 1;
-
-		    credp = crref();
-		    if (afs_CreateReq(&treq, credp))
-			goto out;
-		    vcp = afs_GetVCache(&afs_rootFid, treq, NULL, NULL);
-		    if (!vcp)
-			goto out;
-		    afs_getattr(vcp, &vattr, credp);
-		    afs_fill_inode(AFSTOV(vcp), &vattr);
-
-		    dp = d_find_alias(AFSTOV(afs_globalVp));
-
-#if defined(AFS_LINUX24_ENV)
-#if defined(HAVE_DCACHE_LOCK)
-		    spin_lock(&dcache_lock);
-#else
-		    spin_lock(&AFSTOV(vcp)->i_lock);
-#endif
-#if defined(AFS_LINUX26_ENV)
-		    spin_lock(&dp->d_lock);
-#endif
-#endif
-#if defined(D_ALIAS_IS_HLIST)
-		    hlist_del_init(&dp->d_alias);
-		    hlist_add_head(&dp->d_alias, &(AFSTOV(vcp)->i_dentry));
-#else
-		    list_del_init(&dp->d_alias);
-		    list_add(&dp->d_alias, &(AFSTOV(vcp)->i_dentry));
-#endif
-		    dp->d_inode = AFSTOV(vcp);
-#if defined(AFS_LINUX24_ENV)
-#if defined(AFS_LINUX26_ENV)
-		    spin_unlock(&dp->d_lock);
-#endif
-#if defined(HAVE_DCACHE_LOCK)
-		    spin_unlock(&dcache_lock);
-#else
-		    spin_unlock(&AFSTOV(vcp)->i_lock);
-#endif
-#endif
-		    dput(dp);
-
-		    AFS_FAST_RELE(afs_globalVp);
-		    afs_globalVp = vcp;
-		out:
-		    crfree(credp);
-		    afs_DestroyReq(treq);
-		}
+#ifdef AFS_LINUX22_ENV
+		osi_ResetRootVCache(volid);
 #else
-#ifdef AFS_DARWIN80_ENV
+# ifdef AFS_DARWIN80_ENV
 		afs_PutVCache(afs_globalVp);
-#else
+# else
 		AFS_FAST_RELE(afs_globalVp);
-#endif
+# endif
 		afs_globalVp = 0;
 #endif
 	    }
-- 
2.3.0

