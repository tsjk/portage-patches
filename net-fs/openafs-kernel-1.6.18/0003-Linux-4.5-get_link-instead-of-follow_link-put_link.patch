From 97591edd99583f460d61cece34f9e2173ea637fb Mon Sep 17 00:00:00 2001
From: Chaskiel Grundman <cg2v@andrew.cmu.edu>
Date: Thu, 5 May 2016 12:35:08 -0400
Subject: [PATCH 3/5] Linux 4.5: get_link instead of follow_link+put_link

In linux commit 6b255391, the follow_link inode operation was
replaced by the get_link operation, which is basically the same
but takes the inode and dentry separately, allowing for the
possibility of staying in RCU mode.

For now, only support this if page_get_link is available and we are
using the USABLE_KERNEL_PAGE_SYMLINK_CACHE

The previous test for USABLE_KERNEL_PAGE_SYMLINK_CACHE used a bogus,
undefined configure variable (ac_cv_linux_kernel_page_follow_link).
Remove it, as it was not needed

Change-Id: I2d7851d31dd4b1b944b16fad611addb804930eca
---
 acinclude.m4                 | 10 +++++++++-
 src/afs/LINUX/osi_vnodeops.c |  4 +++-
 2 files changed, 12 insertions(+), 2 deletions(-)

diff --git a/acinclude.m4 b/acinclude.m4
index c8a7ceb..aca1316 100644
--- a/acinclude.m4
+++ b/acinclude.m4
@@ -890,6 +890,7 @@ case $AFS_SYSNAME in *_linux* | *_umlinux*)
 		 AC_CHECK_LINUX_STRUCT([file_operations], [sendfile], [fs.h])
 		 AC_CHECK_LINUX_STRUCT([file_system_type], [mount], [fs.h])
 		 AC_CHECK_LINUX_STRUCT([inode_operations], [truncate], [fs.h])
+		 AC_CHECK_LINUX_STRUCT([inode_operations], [get_link], [fs.h])
 		 AC_CHECK_LINUX_STRUCT([key], [payload.value], [key.h])
 		 AC_CHECK_LINUX_STRUCT([key_type], [instantiate_prep], [key-type.h])
 		 AC_CHECK_LINUX_STRUCT([key_type], [match_preparse], [key-type.h])
@@ -990,6 +991,9 @@ case $AFS_SYSNAME in *_linux* | *_umlinux*)
 		 AC_CHECK_LINUX_FUNC([page_follow_link],
 				     [#include <linux/fs.h>],
 				     [page_follow_link(0,0);])
+		 AC_CHECK_LINUX_FUNC([page_get_link],
+				     [#include <linux/fs.h>],
+				     [page_get_link(0,0,0);])
 		 AC_CHECK_LINUX_FUNC([page_offset],
 				     [#include <linux/pagemap.h>],
 				     [page_offset(NULL);])
@@ -1168,11 +1172,15 @@ case $AFS_SYSNAME in *_linux* | *_umlinux*)
 		 if test -f "$LINUX_KERNEL_PATH/include/linux/mm_inline.h"; then
 		  AC_DEFINE(HAVE_MM_INLINE_H, 1, [define if you have mm_inline.h header file])
 	         fi
-		 if test "x$ac_cv_linux_kernel_page_follow_link" = "xyes" -o "x$ac_cv_linux_func_i_put_link_takes_cookie" = "xyes"; then
+		 if test "x$ac_cv_linux_func_page_get_link" = "xyes" -o "x$ac_cv_linux_func_i_put_link_takes_cookie" = "xyes"; then
 		  AC_DEFINE(USABLE_KERNEL_PAGE_SYMLINK_CACHE, 1, [define if your kernel has a usable symlink cache API])
 		 else
 		  AC_MSG_WARN([your kernel does not have a usable symlink cache API])
 		 fi
+		 if test "x$ac_cv_linux_func_page_get_link" != "xyes" -a "x$ac_cv_linux_struct_inode_operations_has_get_link" = "xyes"; then
+			AC_MSG_ERROR([Your kernel does not use follow_link - not supported without symlink cache API])
+			exit 1
+		 fi
                 :
 		fi
 		if test "x$enable_linux_d_splice_alias_extra_iput" = xyes; then
diff --git a/src/afs/LINUX/osi_vnodeops.c b/src/afs/LINUX/osi_vnodeops.c
index 2f753dd..00b41ef 100644
--- a/src/afs/LINUX/osi_vnodeops.c
+++ b/src/afs/LINUX/osi_vnodeops.c
@@ -3108,7 +3108,9 @@ static struct address_space_operations afs_symlink_aops = {
 static struct inode_operations afs_symlink_iops = {
 #if defined(USABLE_KERNEL_PAGE_SYMLINK_CACHE)
   .readlink = 		page_readlink,
-# if defined(HAVE_LINUX_PAGE_FOLLOW_LINK)
+# if defined(HAVE_LINUX_PAGE_GET_LINK)
+  .get_link =		page_get_link,
+# elif defined(HAVE_LINUX_PAGE_FOLLOW_LINK)
   .follow_link =	page_follow_link,
 # else
   .follow_link =	page_follow_link_light,
-- 
2.8.2

