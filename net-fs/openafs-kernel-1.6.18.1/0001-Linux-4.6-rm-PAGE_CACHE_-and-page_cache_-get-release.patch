From 720556bcbc9d51e2d1b4b0fd1f3c399836b67971 Mon Sep 17 00:00:00 2001
From: Joe Gorse <jhgorse@gmail.com>
Date: Thu, 9 Jun 2016 14:11:23 -0400
Subject: [PATCH] Linux 4.6: rm PAGE_CACHE_* and page_cache_{get,release}
 macros

This is an automatic patch generated by Coccinelle (spatch) from:
https://github.com/torvalds/linux/commit/09cbfeaf1a5a67bfb3201e0c83c810cecb2efa5a

The spatch used:
@@
expression E;
@@
- E << (PAGE_CACHE_SHIFT - PAGE_SHIFT)
+ E

@@
expression E;
@@
- E >> (PAGE_CACHE_SHIFT - PAGE_SHIFT)
+ E

@@
@@
- PAGE_CACHE_SHIFT
+ PAGE_SHIFT

@@
@@
- PAGE_CACHE_SIZE
+ PAGE_SIZE

@@
@@
- PAGE_CACHE_MASK
+ PAGE_MASK

@@
expression E;
@@
- PAGE_CACHE_ALIGN(E)
+ PAGE_ALIGN(E)

@@
expression E;
@@
- page_cache_get(E)
+ get_page(E)

@@
expression E;
@@
- page_cache_release(E)
+ put_page(E)

Change-Id: Iabe29b1349ab44282c66c86eced9e5b2056c9efb
---
 src/afs/LINUX/osi_compat.h   |  2 +-
 src/afs/LINUX/osi_pagecopy.c | 12 ++++++------
 src/afs/LINUX/osi_vnodeops.c | 42 +++++++++++++++++++++---------------------
 3 files changed, 28 insertions(+), 28 deletions(-)

diff --git a/src/afs/LINUX/osi_compat.h b/src/afs/LINUX/osi_compat.h
index 5268e7e..0596273 100644
--- a/src/afs/LINUX/osi_compat.h
+++ b/src/afs/LINUX/osi_compat.h
@@ -274,7 +274,7 @@ afs_linux_cred_is_current(afs_ucred_t *cred)
 static inline loff_t
 page_offset(struct page *pp)
 {
-    return (((loff_t) pp->index) << PAGE_CACHE_SHIFT);
+    return (((loff_t) pp->index) << PAGE_SHIFT);
 }
 #endif
 
diff --git a/src/afs/LINUX/osi_pagecopy.c b/src/afs/LINUX/osi_pagecopy.c
index 4829832..7142a1b 100644
--- a/src/afs/LINUX/osi_pagecopy.c
+++ b/src/afs/LINUX/osi_pagecopy.c
@@ -116,9 +116,9 @@ void afs_pagecopy_queue_page(struct afs_pagecopy_task *task,
     page = kzalloc(sizeof(struct afs_pagecopy_page), GFP_NOFS);
     INIT_LIST_HEAD(&page->tasklink);
 
-    page_cache_get(cachepage);
+    get_page(cachepage);
     page->cachepage = cachepage;
-    page_cache_get(afspage);
+    get_page(afspage);
     page->afspage = afspage;
 
     spin_lock(&task->lock);
@@ -159,7 +159,7 @@ static struct page * afs_pagecopy_checkworkload(void) {
 		if (!schedule_work(&task->work))
 		   atomic_dec(&task->refcnt);
 	   } else if (!sleeppage) {
-		page_cache_get(page->cachepage);
+		get_page(page->cachepage);
 		sleeppage = page->cachepage;
 	   }
 	}
@@ -205,8 +205,8 @@ static void afs_pagecopy_worker(struct work_struct *work)
 	    SetPageUptodate(page->afspage);
 	}
 	unlock_page(page->afspage);
-	page_cache_release(page->cachepage);
-	page_cache_release(page->afspage);
+	put_page(page->cachepage);
+	put_page(page->afspage);
 	kfree(page);
 
 	spin_lock(&task->lock);
@@ -224,7 +224,7 @@ static int afs_pagecopy_thread(void *unused) {
 	    sleeppage = afs_pagecopy_checkworkload();
 	    if (sleeppage) {
 		wait_on_page_locked(sleeppage);
-		page_cache_release(sleeppage);
+		put_page(sleeppage);
 	    } else {
 		break;
 	    }
diff --git a/src/afs/LINUX/osi_vnodeops.c b/src/afs/LINUX/osi_vnodeops.c
index 2696b48..86a9668 100644
--- a/src/afs/LINUX/osi_vnodeops.c
+++ b/src/afs/LINUX/osi_vnodeops.c
@@ -1984,7 +1984,7 @@ afs_linux_read_cache(struct file *cachefp, struct page *page,
     /* If we're trying to read a page that's past the end of the disk
      * cache file, then just return a zeroed page */
     if (AFS_CHUNKOFFSET(offset) >= i_size_read(cacheinode)) {
-	zero_user_segment(page, 0, PAGE_CACHE_SIZE);
+	zero_user_segment(page, 0, PAGE_SIZE);
 	SetPageUptodate(page);
 	if (task)
 	    unlock_page(page);
@@ -1993,7 +1993,7 @@ afs_linux_read_cache(struct file *cachefp, struct page *page,
 
     /* From our offset, we now need to work out which page in the disk
      * file it corresponds to. This will be fun ... */
-    pageindex = (offset - AFS_CHUNKTOBASE(chunk)) >> PAGE_CACHE_SHIFT;
+    pageindex = (offset - AFS_CHUNKTOBASE(chunk)) >> PAGE_SHIFT;
 
     while (cachepage == NULL) {
         cachepage = find_get_page(cachemapping, pageindex);
@@ -2011,12 +2011,12 @@ afs_linux_read_cache(struct file *cachefp, struct page *page,
 	        cachepage = newpage;
 	        newpage = NULL;
 
-	        page_cache_get(cachepage);
+	        get_page(cachepage);
                 if (!pagevec_add(lrupv, cachepage))
                     __pagevec_lru_add_file(lrupv);
 
 	    } else {
-		page_cache_release(newpage);
+		put_page(newpage);
 		newpage = NULL;
 		if (code != -EEXIST)
 		    goto out;
@@ -2057,7 +2057,7 @@ afs_linux_read_cache(struct file *cachefp, struct page *page,
 
 out:
     if (cachepage)
-	page_cache_release(cachepage);
+	put_page(cachepage);
 
     return code;
 }
@@ -2328,7 +2328,7 @@ afs_linux_bypass_readpages(struct file *fp, struct address_space *mapping,
 	/* If we allocate a page and don't remove it from page_list,
 	 * the page cache gets upset. */
 	list_del(&pp->lru);
-	isize = (i_size_read(fp->f_mapping->host) - 1) >> PAGE_CACHE_SHIFT;
+	isize = (i_size_read(fp->f_mapping->host) - 1) >> PAGE_SHIFT;
 	if(pp->index > isize) {
 	    if(PageLocked(pp))
 		unlock_page(pp);
@@ -2345,7 +2345,7 @@ afs_linux_bypass_readpages(struct file *fp, struct address_space *mapping,
         if(base_index != pp->index) {
             if(PageLocked(pp))
 		 unlock_page(pp);
-            page_cache_release(pp);
+            put_page(pp);
 	    iovecp[page_ix].iov_base = (void *) 0;
 	    base_index++;
 	    ancr->length -= PAGE_SIZE;
@@ -2355,7 +2355,7 @@ afs_linux_bypass_readpages(struct file *fp, struct address_space *mapping,
         if(code) {
 	    if(PageLocked(pp))
 		unlock_page(pp);
-	    page_cache_release(pp);
+	    put_page(pp);
 	    iovecp[page_ix].iov_base = (void *) 0;
 	} else {
 	    page_count++;
@@ -2415,7 +2415,7 @@ afs_linux_bypass_readpage(struct file *fp, struct page *pp)
      * it as up to date.
      */
     if (page_offset(pp) >=  i_size_read(fp->f_mapping->host)) {
-	zero_user_segment(pp, 0, PAGE_CACHE_SIZE);
+	zero_user_segment(pp, 0, PAGE_SIZE);
 	SetPageUptodate(pp);
 	unlock_page(pp);
 	return 0;
@@ -2576,13 +2576,13 @@ afs_linux_readpages(struct file *fp, struct address_space *mapping,
 
 	if (tdc && !add_to_page_cache(page, mapping, page->index,
 				      GFP_KERNEL)) {
-	    page_cache_get(page);
+	    get_page(page);
 	    if (!pagevec_add(&lrupv, page))
 		__pagevec_lru_add_file(&lrupv);
 
 	    afs_linux_read_cache(cacheFp, page, tdc->f.chunk, &lrupv, task);
 	}
-	page_cache_release(page);
+	put_page(page);
     }
     if (pagevec_count(&lrupv))
        __pagevec_lru_add_file(&lrupv);
@@ -2763,7 +2763,7 @@ afs_linux_writepage(struct page *pp)
     struct inode *inode;
     struct vcache *vcp;
     cred_t *credp;
-    unsigned int to = PAGE_CACHE_SIZE;
+    unsigned int to = PAGE_SIZE;
     loff_t isize;
     int code = 0;
     int code1 = 0;
@@ -2773,7 +2773,7 @@ afs_linux_writepage(struct page *pp)
 	/* XXX - Do we need to redirty the page here? */
     }
 
-    page_cache_get(pp);
+    get_page(pp);
 
     inode = mapping->host;
     vcp = VTOAFS(inode);
@@ -2842,7 +2842,7 @@ afs_linux_writepage(struct page *pp)
 
 done:
     end_page_writeback(pp);
-    page_cache_release(pp);
+    put_page(pp);
 
     if (code1)
 	return code1;
@@ -2931,10 +2931,10 @@ afs_linux_prepare_write(struct file *file, struct page *page, unsigned from,
 	/* Is the location we are writing to beyond the end of the file? */
 	if (pagebase >= isize ||
 	    ((from == 0) && (pagebase + to) >= isize)) {
-	    zero_user_segments(page, 0, from, to, PAGE_CACHE_SIZE);
+	    zero_user_segments(page, 0, from, to, PAGE_SIZE);
 	    SetPageChecked(page);
 	/* Are we we writing a full page */
-	} else if (from == 0 && to == PAGE_CACHE_SIZE) {
+	} else if (from == 0 && to == PAGE_SIZE) {
 	    SetPageChecked(page);
 	/* Is the page readable, if it's wronly, we don't care, because we're
 	 * not actually going to read from it ... */
@@ -2955,12 +2955,12 @@ afs_linux_write_end(struct file *file, struct address_space *mapping,
                                 struct page *page, void *fsdata)
 {
     int code;
-    unsigned int from = pos & (PAGE_CACHE_SIZE - 1);
+    unsigned int from = pos & (PAGE_SIZE - 1);
 
     code = afs_linux_commit_write(file, page, from, from + len);
 
     unlock_page(page);
-    page_cache_release(page);
+    put_page(page);
     return code;
 }
 
@@ -2970,8 +2970,8 @@ afs_linux_write_begin(struct file *file, struct address_space *mapping,
                                 struct page **pagep, void **fsdata)
 {
     struct page *page;
-    pgoff_t index = pos >> PAGE_CACHE_SHIFT;
-    unsigned int from = pos & (PAGE_CACHE_SIZE - 1);
+    pgoff_t index = pos >> PAGE_SHIFT;
+    unsigned int from = pos & (PAGE_SIZE - 1);
     int code;
 
     page = grab_cache_page_write_begin(mapping, index, flags);
@@ -2980,7 +2980,7 @@ afs_linux_write_begin(struct file *file, struct address_space *mapping,
     code = afs_linux_prepare_write(file, page, from, from + len);
     if (code) {
 	unlock_page(page);
-	page_cache_release(page);
+	put_page(page);
     }
 
     return code;
-- 
2.9.0

