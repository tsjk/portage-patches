From 175bd1fe974c7a0d3677437cabc6835780d52ba3 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Michael=20La=C3=9F?= <lass@mail.uni-paderborn.de>
Date: Thu, 21 Jul 2022 22:58:30 +0200
Subject: [PATCH 2/6] Pending changes for openafs-stable-1_8_x
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

commit 650be42cf1c1c2ca0856f39308cd6d1d6159b586
Author: Cheyenne Wills <cwills@sinenomine.net>
Date:   Mon Jun 27 08:38:25 2022 -0600

    Linux-5.18: replace readpages with readahead

    The linux 5.18 commit 'fs: Remove ->readpages address space
    operation' (704528d8) removes the address_space_operations operation
    "readpages", which is replaced with the "readahead" operation
    that was introduced with the 5.8 commit 'mm: add readahead address
    space operation' (8151b4c8).

    When readahead is called, the pages in 'rac' have already been added to
    the lru caches and are locked. For each page that we get from the 'rac'
    (i.e. from 'readahead_page(rac)'), we must unlock and put_page the page;
    if we successfully populated the page with data, we also set
    PageUpToDate.  If we don't process all the pages in 'rac', the caller
    will handle cleaning up any remaining pages; we don't need to unlock/put
    them or touch them at all.
      (See Linux Documentation/filesystems/vfs.rst)

    Add an autoconf test to detect the presence of 'readahead' in the
    address_space_operations structure.

    For the implementation of readahead (which is contained in Linux's
    osi_vnodeops.c):

    Add new functions 'afs_linux_bypass_readahead' and 'afs_linux_readahead'
    as replacements for 'afs_bypass_readpages' and 'afs_linux_readpages'
    when the linux kernel supports the readahead operation.

    Notes:
      In afs_linux_bypass_readahead, the pages are already locked and are
      already in the page cache, we just need to place the page into the
      iovecp.  The page's refcount will be decremented and will be unlocked
      when processing the read request.

      In afs_linux_readahead, the lrupages is needed in case a page is added
      to the cachefp's mapping in afs_linux_read_cache (which also handles
      unlocking the page).

      In afs_linux_readahead, if there is no tdc, we must still unlock the
      page otherwise the read process will wait on that page.

    Reviewed-on: https://gerrit.openafs.org/14953
    Tested-by: BuildBot <buildbot@rampaginggeek.com>
    Reviewed-by: Andrew Deason <adeason@sinenomine.net>
    Reviewed-by: Benjamin Kaduk <kaduk@mit.edu>
    (cherry picked from commit 7a181415db1b2142d125714f1dea32879e2ca07d)

    Change-Id: I2ed4f22bd2b12c76586ae5326841a23735a20af0

commit aa531b716736d357f6d583ed11f7075fc00e8298
Author: Cheyenne Wills <cwills@sinenomine.net>
Date:   Tue Jun 7 12:19:44 2022 -0600

    Prevent sscanf format widths from overrunning array

    cppcheck noted these instances of sscanf could wipe out the ending null
    terminator.  Length is now macro expanded rather than hard coded and the
    array itself is one unit longer to avoid the overrun.

    Reviewed-on: https://gerrit.openafs.org/13136
    Reviewed-by: Michael Meffie <mmeffie@sinenomine.net>
    Reviewed-by: Andrew Deason <adeason@sinenomine.net>
    Tested-by: BuildBot <buildbot@rampaginggeek.com>
    Reviewed-by: Benjamin Kaduk <kaduk@mit.edu>
    (cherry picked from commit 1162fcdba6c5234f4ac36e17f29e01ae04950004)

    Change-Id: I1759f4c11df003c6d0798910db9210ff91b95536

commit 4e0f4a9c37c3ee01783dd021a1e161637e0bcd41
Author: Cheyenne Wills <cwills@sinenomine.net>
Date:   Tue Jun 21 09:50:41 2022 -0600

    opr: replace AFS_STRINGIZE with opr_stringize

    To avoid adding new includes for afs/afsutil.h in order to use
    'AFS_STRINGIZE', create a replacement, 'opr_stringize', in afs/opr.h.

    Replace the usage of 'AFS_STRINGIZE' with opr_stringize and remove the
    definition of 'AFS_STRINGIZE'

    Reviewed-on: https://gerrit.openafs.org/15029
    Reviewed-by: Michael Meffie <mmeffie@sinenomine.net>
    Tested-by: BuildBot <buildbot@rampaginggeek.com>
    Reviewed-by: Andrew Deason <adeason@sinenomine.net>
    Reviewed-by: Benjamin Kaduk <kaduk@mit.edu>
    (cherry picked from commit 7f54bbe1568ea66d04bf69f5f083aa0422fcb417)

    Change-Id: I09fe7ba2191d1522342ac2a935afc40b1c67b7a4

commit d00d7945a7b6da77e9df2ffc81f5968c17ba7a9c
Author: Cheyenne Wills <cwills@sinenomine.net>
Date:   Tue Jun 7 11:14:55 2022 -0600

    lwp: Ignore dangling-pointer warning in process.c

    In lwp/process.c the address of a stack variable is saved as part of
    creating a new context.  GCC-12 is flagging the statement with a
    diagnostic:

      ./process.c:46:24: error: storing the address of local variable
          ‘stackvar’ in ‘*savearea.topstack’ [-Werror=dangling-pointer=]
       46 |     savearea->topstack = (char *)&stackvar;
          |     ~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~

    In this particular case, the code is meaning to save the address of the
    stack in preparation of setting up a new context, which requires knowing
    the address the current stack.

    The diagnostic is changed from a warning to an error when configured
    with --enable-checking.

    Set the env variable CFLAGS_NODANGLING_POINTER to
    '-Wno-dangling-pointer' if the compiler supports the option and update
    the src/lwp/Makefile.in to use the flag when compiling process.c

    Reviewed-on: https://gerrit.openafs.org/14957
    Reviewed-by: Andrew Deason <adeason@sinenomine.net>
    Reviewed-by: Michael Meffie <mmeffie@sinenomine.net>
    Tested-by: BuildBot <buildbot@rampaginggeek.com>
    Reviewed-by: Benjamin Kaduk <kaduk@mit.edu>
    (cherry picked from commit 748ae0fc25c51316d741afd9b9dfd479ffdf3250)

    Change-Id: I03d2d4a77b4a391f023f40e9793968e03a50c241

commit 67eaefbad25845442baa0f8a58bcc54b23672197
Author: Cheyenne Wills <cwills@sinenomine.net>
Date:   Tue Jun 21 09:57:40 2022 -0600

    afs: Avoid always-false NULL test on AFSTOV(avc)

    GCC-12 is flagging a comparison with the following diagnostic:

     src/afs/afs_vcache.c:3161:25: error: the comparison will always
        evaluate as ‘false’ for the address of ‘v’ will never be NULL
        [-Werror=address]
     3161 |             AFSTOV(avc) == NULL || vType(avc) == VDIR ||
          |                         ^~

    When the vcache structure does not have the vnode embedded the expansion
    of the AFSTOV macro results in:
       ((avc)->v)
    which tests contents of a 'v'.

    When the vcache structure does have the vnode embedded, the expansion of
    the macro results in:
       (&(avc)->v)
    which tests the address of 'v', which will never be NULL in this case.

    Update afs.h to add a new define 'AFS_VCACHE_EMBEDDED_VNODE' when the
    vcache structure contains an embedded vnode structure.  Restructure the
    preprocessor statements for the AFSTOV definition

    Avoid testing AFSTOV(x) against NULL when AFS_VCACHE_EMBEDDED_VNODE is
    defined.

    The diagnostic is changed from a warning to an error when configured
    with --enable-checking.

    Reviewed-on: https://gerrit.openafs.org/14956
    Reviewed-by: Michael Meffie <mmeffie@sinenomine.net>
    Tested-by: BuildBot <buildbot@rampaginggeek.com>
    Reviewed-by: Andrew Deason <adeason@sinenomine.net>
    Reviewed-by: Benjamin Kaduk <kaduk@mit.edu>
    (cherry picked from commit 1d1a20c33258a9285a16e85a55df9c0fbf4a3ac2)

    Change-Id: Ieeb2b958c20aabbb412023c8e60c6d68e961c4b8

commit 5c22def7c517de2b4a12ead23bd6f4da31bf69c7
Author: Cheyenne Wills <cwills@sinenomine.net>
Date:   Thu Jun 9 13:20:02 2022 -0600

    afs: introduce get_dcache_readahead

    Relocate the block of code that obtains the dcache for a readahead
    operation from the afs_linux_readpages function into its own static
    function.

    Reviewed-on: https://gerrit.openafs.org/14962
    Tested-by: BuildBot <buildbot@rampaginggeek.com>
    Reviewed-by: Benjamin Kaduk <kaduk@mit.edu>
    (cherry picked from commit 44e24ae5d7dc41e54d23638d5f64ab2e81e43ad0)

    Change-Id: I5fce05cd241dc5a22526d931969cf11da89e3d48

commit b843a5f6946c5a842386a1d609de7c0e2260f128
Author: Cheyenne Wills <cwills@sinenomine.net>
Date:   Mon Jun 6 12:27:43 2022 -0600

    afs: introduce afs_alloc_ncr/afs_free_ncr

    There is duplicated code for initializing a nocache_read_request
    and also freeing the associated storage in certain cases.  Create a set
    of helper functions that allocates and frees a nocache_read_request and
    its associated structures.

    afs_alloc_ncr allocates a nocache_read_request structure and if not
    UKERNEL, will allocate and initialize the associated uio and iovec
    structures.

    afs_free_ncr releases a noncache_read_request structure and the
    associated uio and iovec structures if not UKERNEL.

    Update locations that allocate/free nocache_read_request structures to
    use the new functions.

    Reviewed-on: https://gerrit.openafs.org/14954
    Reviewed-by: Andrew Deason <adeason@sinenomine.net>
    Tested-by: BuildBot <buildbot@rampaginggeek.com>
    Reviewed-by: Benjamin Kaduk <kaduk@mit.edu>
    (cherry picked from commit 209eb92448001e59525413610356070d8e4f10a0)

    Change-Id: Id9c23195e062c720fdbde83a9b5d36fb287aa8a4

commit cb8ed8ff1aabb933026ecd6fe8b1368a33e74488
Author: Cheyenne Wills <cwills@sinenomine.net>
Date:   Wed Mar 30 11:09:45 2022 -0600

    Linux-5.18 replace set_page_dirty with dirty_folio

    The commits going into Linux 5.18:

      fs: Add aops->dirty_folio (6f31a5a261db)
      fs: Convert __set_page_dirty_buffers to block_dirty_folio (e621900ad2)
      fs: Remove aops ->set_page_dirty (3a3bae50af)

    replaces the address_space_operations structure member set_page_dirty
    which with dirty_folio.  The linux function __set_page_dirty_buffers is
    replaced by block_dirty_folio.

    Nothing within afs uses or implements the set_page_dirty function,
    however the structure member is required to be initialized.

    Add an autoconf test for the dirty_folio member and if present, set the
    address_space_operations member dirty_folio to block_dirty_folio
    instead of setting the set_page_dirty member.

    Reviewed-on: https://gerrit.openafs.org/14939
    Tested-by: BuildBot <buildbot@rampaginggeek.com>
    Reviewed-by: Benjamin Kaduk <kaduk@mit.edu>
    (cherry picked from commit 6aa129e743e882cf30c35afd67eabf82274c5fca)

    Change-Id: I8afccecae7971d98f87a65db816c337fb2380854

commit 8fbbec3f0849ecbca7419ae9bde62140c6f66248
Author: Cheyenne Wills <cwills@sinenomine.net>
Date:   Wed May 11 08:48:52 2022 -0600

    afsd: Avoid fscanf overflows when paring cacheinfo

    clang-14 is producing the following diagnostic:

        afsd.c:581:44: error: 'fscanf' may overflow; destination buffer in
          argument 3 has size 1024, but the corresponding specifier may
          require size 1025 [-Werror,-Wfortify-source]
            fscanf(cachefd, "%1024[^:]:%1024[^:]:%d", tCacheMountDir,

    fscanf is being used to parse the contents of a file and the buffer
    sizes are hardcoded.  Simply increase the size of the 2 buffers by 1.

    The diagnostic warning is changed to an error when configured with
    --enable-checking.

    Reviewed-on: https://gerrit.openafs.org/14958
    Tested-by: BuildBot <buildbot@rampaginggeek.com>
    Reviewed-by: Benjamin Kaduk <kaduk@mit.edu>
    (cherry picked from commit 82c14b9a667174f044b7421e6e081ad323720a67)

    Change-Id: I81b5563599272b8f224962941d179ae2e93f7f47

commit 02d78993ba726af4725e291dca9d049ddf3bb9d3
Author: Cheyenne Wills <cwills@sinenomine.net>
Date:   Tue May 24 20:14:36 2022 -0600

    vol: Use asprintf in _namei_examine_special

    GCC-12 is flagging an snprintf statement with a format truncation
    warning:

      namei_ops.c: In function ‘namei_ListAFSSubDirs’:
      namei_ops.c:2029:22: error: ‘%s’ directive output may be truncated
       writing up to 255 bytes into a region of size between 0 and 511
       [-Werror=format-truncation=]

    Change code to use asprintf instead of snprintf.  Return an error if a
    memory allocation fails.

    Reviewed-on: https://gerrit.openafs.org/14955
    Tested-by: BuildBot <buildbot@rampaginggeek.com>
    Reviewed-by: Benjamin Kaduk <kaduk@mit.edu>
    (cherry picked from commit ae70db6cde5be5abd3bbbb26bd9af6fe68cc4b6b)

    Change-Id: I742e0210ac35eec7a143a780db4a6047a0a7c3fc

commit 0be7f29ade2119286b29c764d1710144cbce247e
Author: Cheyenne Wills <cwills@sinenomine.net>
Date:   Thu Jul 16 15:07:15 2020 -0600

    autoconf: fix detection for fallthrough attribute

    Due to bug <https://savannah.gnu.org/patch/?9949>,
    ax_gcc_func_attribute.m4 fails to properly detect __attribute__((fallthrough))
    in clang. Until this is fixed in autoconf-archive upstream, fix our
    local copy of ax_gcc_func_attribute.m4, so we can detect
    __attribute__((fallthrough)) to make --enable-checking work with clang.

    Reviewed-on: https://gerrit.openafs.org/14273
    Reviewed-by: Andrew Deason <adeason@sinenomine.net>
    Reviewed-by: Benjamin Kaduk <kaduk@mit.edu>
    Tested-by: BuildBot <buildbot@rampaginggeek.com>
    (cherry picked from commit 899b1af4183fb09fd55a36e3d10ffbdb9671a47e)

    Change-Id: Ia7398f958897e326722a77db2e64262212ff3367

commit f42da97889dd1b42afb140239561825f29a1e438
Author: Cheyenne Wills <cwills@sinenomine.net>
Date:   Tue Mar 1 15:35:07 2022 -0700

    cf: Use -Werror when checking for -Wno-* flags

    When detecting valid compiler flags clang behaves differently than gcc
    for certain types of flags.  Specifically, gcc will ignore an unknown
    "-Wno-someflag" while clang will issue a warning.  If using clang and
    --enable-checking is specified, this difference causes a build failure
    because the warning for the unknown flag is turned into an error.

    The autoconf macro AX_APPEND_COMPILE_FLAGS (via the underlying macro
    AX_CHECK_COMPILE_FLAGS) looks specifically for errors and not warnings
    to determine if the flag is valid.  In order to properly catch the above
    type of unknown compiler flags, a '-Werror' must be passed as an
    extra-flag.

    Update the autoconf functions that use AX_APPEND_COMPILE_FLAGS to use
    '-Werror' as an extra flag when testing for "-Wno-..." flags.

    Note, for gcc, the test may (incorrectly) think that the compiler
    supports the given flag, but that is okay, since the flag will be
    ignored by gcc during the build without raising any warnings or errors.

    Reviewed-on: https://gerrit.openafs.org/14900
    Tested-by: BuildBot <buildbot@rampaginggeek.com>
    Reviewed-by: Andrew Deason <adeason@sinenomine.net>
    Reviewed-by: Michael Meffie <mmeffie@sinenomine.net>
    Reviewed-by: Benjamin Kaduk <kaduk@mit.edu>
    (cherry picked from commit 573be0228778873c0d445263fb09989918bea4c1)

    Change-Id: Ie11cf176d4c88560d5fce9a0c5932d3a0d5dba1e

commit e62b03c3d7d7ffaa90e60e4f5bbea62dbd372560
Author: Cheyenne Wills <cwills@sinenomine.net>
Date:   Sun Apr 5 15:51:17 2020 -0600

    cf: Use common macro to test compiler flags

    Use the AX_APPEND_COMPILE_FLAGS macro to test and set compiler
    specific flags.

    Remove the OPENAFS_GCC_SUPPORTS_MARCH check entirely (and the
    associated P5PLUS_KOPTS), since nothing has used it for quite some
    time.

    Reviewed-on: https://gerrit.openafs.org/14132
    Reviewed-by: Benjamin Kaduk <kaduk@mit.edu>
    Tested-by: BuildBot <buildbot@rampaginggeek.com>
    (cherry picked from commit 790824ff749b6ee01c4d7101493cbe8773ef41c6)

    Change-Id: I0880abd2e114568cbcf232197efced91bb2ea5e7

commit bd931fb3639bb59ee1bb916d26da61ed4a2a6b3a
Author: Cheyenne Wills <cwills@sinenomine.net>
Date:   Thu Jul 2 13:39:27 2020 -0600

    LINUX: Don't panic on some file open errors

    Commit 'LINUX: Return NULL for afs_linux_raw_open error' (f6af4a155)
    updated afs_linux_raw_open to return NULL on some errors, but still
    panics if obtaining the dentry fails.

    Commit 'afs: Verify osi_UFSOpen worked' (c6b61a451) updated callers of
    osi_UFSOpen to verify whether or not the open was successful.  This
    meant osi_UFSOpen (and routines it calls) could pass back an error
    indication rather than panic when an error is encountered.

    Update afs_linux_raw_open to return a failure instead of panic if unable
    to obtain a dentry.

    Update osi_UFSOpen to return a NULL instead of panic if unable to obtain
    memory or fails to open the file. All callers of osi_UFSOpen handle a
    fail return, though some will still issue a panic.

    Update afs_linux_readpage_fastpath and afs_linux_readpages to not panic
    if afs_linux_raw_open fails.  Instead of panic, return an error.

    For testing, an error can be forced by removing a file from the
    cache directory.

    Note this work is based on a commit by pruiter@sinenomine.net

    Reviewed-on: https://gerrit.openafs.org/14242
    Reviewed-by: Andrew Deason <adeason@sinenomine.net>
    Reviewed-by: Mark Vitale <mvitale@sinenomine.net>
    Reviewed-by: Benjamin Kaduk <kaduk@mit.edu>
    Tested-by: BuildBot <buildbot@rampaginggeek.com>
    (cherry picked from commit af73b9a3b1fc625694807287c0897391feaad52d)

    Change-Id: I1e430403561d5b85d6a4094d4bf413a6eca4ff5a

commit 0b62fd8a0229daa77ca1a68256c2dd5310acabba
Author: Andrew Deason <adeason@sinenomine.net>
Date:   Thu Jan 17 15:45:36 2019 -0600

    afs: Introduce afs_IsDCacheFresh

    Numerous places in libafs check the DV of a dcache against the DV of
    the vcache for the same file, in order to check if the dcache is up to
    date and can be used. Consolidate all of these checks into a new
    function, afs_IsDCacheFresh, to make it easier for future commits to
    alter this logic.

    This commit should have no visible impact; it is just code
    reorganization.

    Reviewed-on: https://gerrit.openafs.org/13435
    Reviewed-by: Benjamin Kaduk <kaduk@mit.edu>
    Tested-by: Andrew Deason <adeason@sinenomine.net>
    (cherry picked from commit 0d8ce846ab2e6c45166a61f04eb3af271cbd27db)

    Change-Id: I2d7f63339e0cd6e0df7f4b07000834ac946cb4b7

commit 29cf61d9d1019be0830f332a67fb8681ad118c07
Author: Michael Meffie <mmeffie@sinenomine.net>
Date:   Wed Jun 29 10:33:23 2022 -0400

    Change klog.krb5 -lifetime option help description

    Change the klog.krb5 -lifetime help description to show this option is
    ignored.  This option name was copied from the krb4 command but is not
    implemented for the krb5 version. It is retained for command line syntax
    compatibility.

    Reviewed-on: https://gerrit.openafs.org/15045
    Tested-by: BuildBot <buildbot@rampaginggeek.com>
    Reviewed-by: Benjamin Kaduk <kaduk@mit.edu>
    (cherry picked from commit f0c9fe7f8983eccf6453e3345de72a0eed649a5a)

    Change-Id: If2b34f8d9d8e65fb8b6497f0ab01ff1ef6d2196e

commit fb27edc414437a223522ea13fdad16ae0621defd
Author: Cheyenne Wills <cwills@sinenomine.net>
Date:   Fri Jan 28 14:10:46 2022 -0700

    Linux-5.17: Kernel build uses -Wcast-function-type

    The linux 5.17 commit:
      "Makefile: Enable -Wcast-function-type" (552a23a0)
    added the -Wcast-function-type compiler flag for kernel module builds.

    This change catches a type mismatch in the external files obtained from
    heimdal: hcrypto/evp.c and hcrypto/evp-algs.c and produces the following
    type of compile time error messages.

      src/libafs/MODLOAD-.../evp.c: In function ‘hc_EVP_md_null’:
      src/libafs/MODLOAD-.../evp.c:501:2: error: cast between incompatible
          function types from ‘void (*)(void *)’ to ‘int (*)(EVP_MD_CTX *)’
              {aka ‘int (*)(struct hc_EVP_MD_CTX *)’}
              [-Werror=cast-function-type]
      501 |  (hc_evp_md_init)null_Init,
          |  ^

    Use AX_APPEND_COMPILE_FLAGS to create a CFLAGS_NOCAST_FUNCTION_TYPE
    macro to disable this warning and update the CFLAGS for these 2 files
    for the Linux libafs build.

    Update the CODING documentation to add the new exceptions.  In addition
    add a brief description on how to set up autoconf to add a new build
    macro to suppress compiler warnings.

    Note: upstream heimdal has committed a fix for this in:

       hcrypto: Fix return type for null_Init, null_Update and null_Final
       (fc4b3ce49b)

    Reviewed-on: https://gerrit.openafs.org/14881
    Reviewed-by: Benjamin Kaduk <kaduk@mit.edu>
    Tested-by: BuildBot <buildbot@rampaginggeek.com>
    Reviewed-by: Andrew Deason <adeason@sinenomine.net>
    (cherry picked from commit 6bdfa976731ce07f3236893ecf12abb9e169b882)

    Change-Id: Ibd354f663d5876c421a8b4e89b8943c9e3d59ebc

commit d18866e5382f163c0b42e3deab232d5b7731bd5c
Author: Cheyenne Wills <cwills@sinenomine.net>
Date:   Thu Jan 27 20:19:17 2022 -0700

    Linux-5.17: kernel func complete_and_exit renamed

    Handle the Linux kernel function rename made in commit
     "exit: Rename complete_and_exit to kthread_complete_and_exit"
     (cead1855)

    Add a new autoconf test for the linux function kthread_complete_and_exit
    and if not found use a define to map kthread_complete_and_exit to
    complete_and_exit.

    Replace calls to complete_and_exit with kthread_complete_and_exit.

    Reviewed-on: https://gerrit.openafs.org/14882
    Tested-by: BuildBot <buildbot@rampaginggeek.com>
    Reviewed-by: Andrew Deason <adeason@sinenomine.net>
    Reviewed-by: Benjamin Kaduk <kaduk@mit.edu>
    (cherry picked from commit a651d4db7f86a24ea6784f6f27d5c8482667267b)

    Change-Id: Ibe96b92a84a8f876dda4019c221c37dabde93244

commit a81865fc60fc69f5dcfebf778305d4cce5f14d0f
Author: Cheyenne Wills <cwills@sinenomine.net>
Date:   Fri Aug 27 08:20:42 2021 -0600

    clang-13: remove unused variables flagged by clang

    Clang-13 changed the default for the unused-but-set-variable resulting
    in build warnings/errors with the following type of messages

    vsprocs.c:3493:25: error: variable 'tentries' set but not used
        [-Werror,-Wunused-but-set-variable]
           afs_int32 nentries, tentries = 0;

    The locations where these local variables are being flagged show that
    while the variables are being updated, they are actually never used for
    anything (e.g. used as part of an assignment to another variable, passed
    as a parameter, used for as returned value, etc.)

    Remove the variables being flagged by the clang-13 compiler.

    Removal of these variables will not alter the overall functionality of
    the code.

    Reviewed-on: https://gerrit.openafs.org/14775
    Tested-by: BuildBot <buildbot@rampaginggeek.com>
    Reviewed-by: Andrew Deason <adeason@sinenomine.net>
    Reviewed-by: Michael Meffie <mmeffie@sinenomine.net>
    Reviewed-by: Benjamin Kaduk <kaduk@mit.edu>
    (cherry picked from commit 8333e8e6020331013af912acb92a308e4f5a1dd2)

    Change-Id: Id5e7c6a323e352106b8f6bf32b7163846c366dec

commit 92bca71db6a6bcf10ef37b03bfdb0e6de7974c50
Author: Cheyenne Wills <cwills@sinenomine.net>
Date:   Thu Jul 23 15:43:42 2020 -0600

    clang-10: ignore fallthrough warning in generated code

    Clang-10 will not recognize '/* fall through */' as an indicator to
    turn off the fallthrough warning due to the lack of a 'break' in a case
    statement.

    Code generated by flex uses the '/* fall through */' comments to turn
    off compiler warnings for fallthroughs in case statements.

    For code generated by flex, ignore the implicit-fallthrough via pragma
    or disable the warning via a compile time flag.

    Add new env variable "CFLAGS_NOIMPLICIT_FALLTHROUGH" to selectively
    disable the compile check in Makefiles when checking is enabled.

    Reviewed-on: https://gerrit.openafs.org/14275
    Reviewed-by: Andrew Deason <adeason@sinenomine.net>
    Reviewed-by: Benjamin Kaduk <kaduk@mit.edu>
    Tested-by: BuildBot <buildbot@rampaginggeek.com>
    (cherry picked from commit e5f44f6e9af643cab3a66216dff901e0a4c5eda8)

    Change-Id: Ibe1b95e6784ca8b422378cf2896bdc7f1a6d8e61

commit f664931808a6b62f8c27a967d65ff74040ea0311
Author: Andrew Deason <adeason@sinenomine.net>
Date:   Wed Jul 10 12:42:54 2019 -0500

    LINUX: Honor --enable-checking for libafs

    When we build the kernel module on LINUX, we don't pass in any of our
    CFLAGS, since the Linux buildsystem itself figures out what flags are
    needed. However, this means that we don't pass in -Werror when
    --enable-checking is turned on, so warnings may not cause the build to
    fail.

    To fix this, create a new autoconf variable, called CFLAGS_WERROR,
    that only contains -Werror if --enable-checking is turned on. We then
    pass that into the Linux module buildsystem, so -Werror is given to
    the compiler when building our module.

    Reviewed-on: https://gerrit.openafs.org/13682
    Reviewed-by: Cheyenne Wills <cwills@sinenomine.net>
    Tested-by: BuildBot <buildbot@rampaginggeek.com>
    Reviewed-by: Benjamin Kaduk <kaduk@mit.edu>
    (cherry picked from commit 6e0f1c3b45102e7644d25cf34395ca980414317f)

    [cwills@sinenomine.net] On master gerrit 14106 comes after this commit.
    In the 1.8.x branch the 14106 commit is already pulled in (gerrit 14217)
    which causes a conflict due a difference ('-fno-common') in the line
    above the change in osconf.m4.

    Change-Id: I4e49d5c5fdf26399eb04d2f76196f3c3f4e7baf6

commit 3a89581111dc18157180616ff8a6c64a7b0906cf
Author: Michael Meffie <mmeffie@sinenomine.net>
Date:   Fri Sep 3 07:05:36 2021 -0400

    ptserver: Fix CreateEntry() stringop-overflow warnings

    The CreateEntry() prototype has been fixed to match the function
    definition, so callers are expected to provide bounded arrays for the
    user or group name. Fix the InitialGroup() macro which is used to set
    the built-in names using string literal to avoid stringop-overflow
    warnings.

        error: ‘CreateEntry’ accessing 64 bytes in a region of size 22 [-Werror=stringop-overflow=]
                code = CreateEntry(tt, (name), &temp, /*idflag*/1, flag, SYSADMINID, SYSADMINID); \

        note: in expansion of macro ‘InitialGroup’
               InitialGroup(SYSADMINID, "system:administrators");
        note: referencing argument 2 of type ‘char *’
        note: in a call to function ‘CreateEntry’
                CreateEntry(struct ubik_trans *at, char aname[PR_MAXNAMELEN], ...

        (Repeated for "system:backup", "system:anyuser", "system:authuser",
        "system:ptsviewers", and "anonymous".)

    Reviewed-on: https://gerrit.openafs.org/14789
    Reviewed-by: Benjamin Kaduk <kaduk@mit.edu>
    Tested-by: Benjamin Kaduk <kaduk@mit.edu>
    (cherry picked from commit 7924aecf95bf4918a485a041f2426bd1fa407ac8)

    Change-Id: I6e30729f1b24beb1ed1c4b6d9162b347285b7edc

commit dacb178d1ed08ed979c0cee3ba1da0c03ce57f6f
Author: Michael Meffie <mmeffie@sinenomine.net>
Date:   Mon Aug 23 15:42:52 2021 -0400

    libadmin: Fix isAlias may be uninitialized warning

    The cfgutil_HostNameIsAlias() function has an output parameter called
    isAlias, which is used when cfgutil_HostIsAlias() returns non-zero.
    However, it possible for isAlias to not be set before returning. GCC 12
    issues a warning about the possible use of the uninitialized isAlias
    variable:

        cfginternal.c:366:32: error: ‘isAlias’ may be used uninitialized
           [-Werror=maybe-uninitialized]

    Initialize the cfgutil_HostNameIsAlias() isAlias output flag to false.
    Also, fix the misleading code indentation around the
    cfgutil_HostNameIsAlias() call.

    Reviewed-on: https://gerrit.openafs.org/14772
    Reviewed-by: Cheyenne Wills <cwills@sinenomine.net>
    Tested-by: BuildBot <buildbot@rampaginggeek.com>
    Reviewed-by: Benjamin Kaduk <kaduk@mit.edu>
    (cherry picked from commit 4a8d0c4089078fb3df9cc06b595c80c9b4c2ca7f)

    Change-Id: I4cadcb4380962e47213fcfd310c1cac331100f65

commit aacf689f263df5d4a0508198aff26bba018078b8
Author: Michael Meffie <mmeffie@sinenomine.net>
Date:   Mon Aug 23 15:37:13 2021 -0400

    bucoord: Fix doDispatch() array-parameter gcc warning

    The doDispatch() prototype does not match the function definition. The
    targv parameter is declared as an unbounded array in the prototype, but
    is defined as a bounded array. As of GCC 12, a warning is issued for the
    mismatch.

        main.c:346:18: error: argument 2 of type ‘char *[100]’ with
          mismatched bound [-Werror=array-parameter=]
        bucoord_internal.h:123:40: note: previously declared as ‘char *[]’

    Within doDispatch(), the targv argument is just passed to cmd_Dispatch()
    (this is the only use of targv). Since cmd_Displatch() expects an
    unbounded array, update the doDispatch() definition to match the
    prototype.

    Reviewed-on: https://gerrit.openafs.org/14771
    Reviewed-by: Michael Meffie <mmeffie@sinenomine.net>
    Reviewed-by: Cheyenne Wills <cwills@sinenomine.net>
    Tested-by: BuildBot <buildbot@rampaginggeek.com>
    Reviewed-by: Benjamin Kaduk <kaduk@mit.edu>
    (cherry picked from commit 92a6242de2d8ea280debc283a7c089f97c1670bc)

    Change-Id: Idc674dccac5adcbe610e059463e493716cf80f57

commit 9bef94a611865536e74cf4d597bec6a041b47632
Author: Michael Meffie <mmeffie@sinenomine.net>
Date:   Mon Aug 23 15:33:19 2021 -0400

    Fix PrintInode() mismatched array parameter warnings

    The PrintInode() prototypes do not match the function definitions.

    When AFS_64BIT_IOPS_ENV is defined (which is the common case and is
    required for namei), the buffer parameter is declared as a bounded
    character array (afs_ino_str_t) in the prototype, but is defined as an
    unbounded character pointer.  When AFS_64BIT_IOPS_ENV is not defined
    (for legacy 32-bit inode vice partitions), PrintInode() is declared with
    no specified parameters.

    A static buffer is used to hold the formatted string when a NULL is
    passed as the first argument to PrintInode(). However, this method is
    only used by the volinfo and iopen utility programs.

    Fix the mismatch function prototypes and definitions to use the bounded
    char array (afs_ino_str_t) in all cases.  Remove the deprecated function
    declaration with no specified parameters. Update vol-info and iopen to
    pass an afs_ino_str_t buffer and remove the now unused static buffer.
    Update the duplicated PrintInode() function definition in namei_ops.c.
    (This duplicated code could be removed in a future commit.)

    Reviewed-on: https://gerrit.openafs.org/14770
    Tested-by: BuildBot <buildbot@rampaginggeek.com>
    Reviewed-by: Cheyenne Wills <cwills@sinenomine.net>
    Reviewed-by: Benjamin Kaduk <kaduk@mit.edu>
    (cherry picked from commit a1e57d2e42b6d01e5ece93d5d49a4b9f3ecd3edc)

    Change-Id: Ia8685805513c2c17e9253d83aa471718a09a449a

commit 595caef30f853b01de610c0f6703d246b663ece9
Author: Michael Meffie <mmeffie@sinenomine.net>
Date:   Mon Aug 23 19:43:45 2021 -0400

    pts: Fix stringop-overflow warnings

    The ptutil functions are defined to accept bounded character arrays for
    user and group names. As of GCC 11, callers which provide the names as
    string literals now trigger the stringop-overflow warning, since the
    regions provided by the string literals are smaller than the bounded
    areas.

        error: ‘pr_ChangeEntry’ accessing 64 bytes in a region of size 1
               [-Werror=stringop-overflow=]
        note: referencing argument 4 of type ‘char *’

        error: ‘pr_IsAMemberOf’ accessing 64 bytes in a region of size 22
               [-Werror=stringop-overflow=]
        note: referencing argument 2 of type ‘char *’

        error: ‘pr_CreateUser’ accessing 64 bytes in a region of size 16
               [-Werror=stringop-overflow=]
        note: referencing argument 1 of type ‘char *’

        error: ‘pr_Delete’ accessing 64 bytes in a region of size 16
               [-Werror=stringop-overflow=]
        note: referencing argument 1 of type ‘char *’

    Update the callers in pts and testpt which pass literal strings. Instead
    of passing char pointers to literal strings, assign the strings to
    prname buffers and pass the prname buffers to the pr utility functions.

    Reviewed-on: https://gerrit.openafs.org/14769
    Reviewed-by: Cheyenne Wills <cwills@sinenomine.net>
    Tested-by: BuildBot <buildbot@rampaginggeek.com>
    Reviewed-by: Benjamin Kaduk <kaduk@mit.edu>
    (cherry picked from commit a3aac5106beddc5a6f7a09c2d21c2524342aca01)

    Change-Id: I38883cdf9c6db701370b3c6755ca28e50f618c82

commit 94fec959da8e8ac479c191c7025ec6a34d345823
Author: Michael Meffie <mmeffie@sinenomine.net>
Date:   Tue Aug 24 16:40:22 2021 -0400

    ptserver: Fix CreateEntry() mismatched array parameter warning

    The CreateEntry() prototype does not match the function definition. The
    aname parameter is declared as an unbounded array in the prototype but
    is defined as a bounded array. As of GCC 12, a warning is issued for the
    mismatch.

        error: argument 2 of type ‘char[64]’ with mismatched bound
               [-Werror=array-parameter=]
               CreateEntry(struct ubik_trans *at, char aname[PR_MAXNAMELEN], ...

        note: previously declared as ‘char[]’
              extern afs_int32 CreateEntry(struct ubik_trans *at, char aname[], ...

    Fix the prototype to declare the 'aname' parameter as a bounded array as
    expected for this function.

    Reviewed-on: https://gerrit.openafs.org/14768
    Tested-by: BuildBot <buildbot@rampaginggeek.com>
    Reviewed-by: Benjamin Kaduk <kaduk@mit.edu>
    (cherry picked from commit fe64ddd3b49bf15222d32d443ff226dd4c2b899e)

    Change-Id: If29ada7f9460591de8d2b61c17d00090465625b2

commit 0edb3f3036cafbd1d1f63dd2c4c57c17d1fb3baf
Author: Michael Meffie <mmeffie@sinenomine.net>
Date:   Mon Aug 23 14:23:01 2021 -0400

    ubik: Fix ubeacon_updateUbikNetworkAddress() mismatched array parameter warning

    The ubeacon_updateUbikNetworkAddress() prototype does not match the
    function definition. The ubik_host parameter is declared as an unbounded
    array in the prototype but is defined as a bounded array. As of GCC 12,
    a warning is issued for the mismatch:

        error: argument 1 of type ‘afs_uint32[256]’ {aka ‘unsigned int[256]’}
               with mismatched bound [-Werror=array-parameter=]
               ubeacon_updateUbikNetworkAddress(
                 afs_uint32 ubik_host[UBIK_MAX_INTERFACE_ADDR])

        note: previously declared as ‘afs_uint32[]’ {aka ‘unsigned int[]’}
              extern int ubeacon_updateUbikNetworkAddress(afs_uint32 ubik_host[]);

    Restore the ubik_host array length in the function prototype, which was
    dropped in commit 9020e6e2f0357b1082705dcaa6626573433969ec (ubik: Defer
    updateUbikNetworkAddress until after RX startup).

    Reviewed-on: https://gerrit.openafs.org/14767
    Tested-by: BuildBot <buildbot@rampaginggeek.com>
    Reviewed-by: Benjamin Kaduk <kaduk@mit.edu>
    (cherry picked from commit 36796bbb83af2650a872234fdb5cf7124bf6cfa8)

    Change-Id: Ia27b5b9642dbd355e1310419424ed0ac04add4b2

commit 23d8d540a6304b6a2fcf23f5e1b2691580d333d2
Author: Michael Meffie <mmeffie@sinenomine.net>
Date:   Mon Sep 10 23:47:33 2018 -0400

    klog.krb5 -lifetime is not implemented

    The klog.krb5 -lifetime option was copied from earlier versions of log
    and klog, which had the ability to set the krb4 token lifetime. However,
    the -lifetime option is not feasible the krb5 version, and so is not
    implemented in klog.krb5.

    Update the klog.krb5 man page to document the -lifetime option has no
    effect.  Remove the code which unnecessarily checks the unused klog.krb5
    -lifetime command line argument.

    The unused lifetime variable was discovered by Pat Riehecky using the
    clang scan-build static analyzer.

    Reviewed-on: https://gerrit.openafs.org/13309
    Tested-by: BuildBot <buildbot@rampaginggeek.com>
    Reviewed-by: PatRiehecky <jcpunk@gmail.com>
    Reviewed-by: Michael Meffie <mmeffie@sinenomine.net>
    Reviewed-by: Benjamin Kaduk <kaduk@mit.edu>
    (cherry picked from commit da699c8b81e818ba97ff8115397d7f7afe0bf512)

    Change-Id: I81cd0024f4727ba401df7b5813163b11f9b43bd4

commit b8aee7d9508d3abc1e6f46c9ad7e3e6787be927d
Author: Michael Meffie <mmeffie@sinenomine.net>
Date:   Mon Oct 1 11:38:37 2018 -0400

    ubik: do not reuse the offset variable for the sync site address

    The ubik SendFile function performs a sanity check of the host address
    before proceeding with the file transfer.  Currently this check reuses
    the file offset local variable to hold the value of the sync site
    address, a 32-bit IPv4 address. Not only is this confusing, but also
    causes a signed/unsigned type mismatch when comparing host addresses.
    Instead of being so stingy with local variables, declare a new local
    variable of the correct type to hold the value of the sync site address.

    This separation is also a prerequisite for supporting larger address
    types in the future.

    Reviewed-on: https://gerrit.openafs.org/13351
    Tested-by: BuildBot <buildbot@rampaginggeek.com>
    Reviewed-by: Benjamin Kaduk <kaduk@mit.edu>
    (cherry picked from commit f0bab78cbe4f59609fa18647a480cc6989948786)

    Change-Id: I2bda69a2586628b51e84c3facf116bf652e3df0a

commit 37f31fec0adb074cf639e9f5c191980e0d6b923b
Author: Andrew Deason <adeason@sinenomine.net>
Date:   Thu Mar 24 12:04:13 2022 -0500

    afs: Remove redundant AFS_LINUX_ENV test

    After our Linux checks were converted to AFS_LINUX_ENV in commit
    6329a523 (Change AFS*_LINUXnn_ENV to AFS*_LINUX_ENV), the extra
    AFS_LINUX_ENV check in this line doesn't make any sense. Get rid of
    it.

    Reviewed-on: https://gerrit.openafs.org/14935
    Reviewed-by: Marcio Brito Barbosa <mbarbosa@sinenomine.net>
    Reviewed-by: Cheyenne Wills <cwills@sinenomine.net>
    Reviewed-by: Benjamin Kaduk <kaduk@mit.edu>
    Tested-by: BuildBot <buildbot@rampaginggeek.com>
    (cherry picked from commit a7d04f0770beb08ea7db2dcdc3dee80b2a57233a)

    Change-Id: I797e1d677cc758d0475011167c0cbafeedf9788c

commit dbf3f1e70766c141446d7179b6b79e66014c5a62
Author: Cheyenne Wills <cwills@sinenomine.net>
Date:   Thu Jun 2 11:17:45 2022 -0600

    Cleanup AFS_*LINUX_ENV usage

    Commit 6329a523f6305541871bc3d1694065e7b17abe77 changed all
    occurrences of AFS_*LINUXnn_ENV to AFS_*LINUX_ENV, but did not perform
    any refactoring of the use of these variables.

    This commit completes the task by refactoring the preprocessor
    conditionals that involved removing dead code or collapsing statements.

    The updates should have no functional changes.

    Reviewed-on: https://gerrit.openafs.org/14388
    Reviewed-by: Benjamin Kaduk <kaduk@mit.edu>
    Tested-by: BuildBot <buildbot@rampaginggeek.com>
    (cherry picked from commit cbc18e4b311bdd2c461f60b7b96eb2ab8a6d1ee5)

    Change-Id: I02e9f0cab5e60994c67593b0709ae1e500d23545

commit b7d25e9fa3c0d4a9ca972b49a4731f9bcc30ca26
Author: Cheyenne Wills <cwills@sinenomine.net>
Date:   Thu Jun 2 11:19:32 2022 -0600

    Change AFS*_LINUXnn_ENV to AFS*_LINUX_ENV

    The minimum Linux kernel that is now supported is linux-2.6.18.  The
    Linux versioned preprocessor macros AFS_*LINUXnn_ENV are no longer
    needed to distinguish the different levels of Linux and can be merged
    into just a single set of macros.

    Perform a global change of _LINUX\d+_ENV to _LINUX_ENV. e.g.
       AFS_LINUX24_ENV       -> AFS_LINUX_ENV
       AFS_USR_LINUX24_ENV   -> AFS_USR_LINUX_ENV
       AFS_AMD64_LINUX20_ENV -> AFS_AMD64_LINUX_ENV

    Replace the multiple definitions for the versioned 'AFS*_LINUXnn_ENV'
    with just single non-version definitions 'AFS*_LINUX_ENV'.

    Apart from replacing the now-redundant #define directives and tidying up
    a few comments at the close of a preprocessor block to match their
    current form, this commit was done using a mechanical change of the
    variable names and did not reduce preprocessor statements that could now
    be combined or eliminated.  Nor does this commit remove dead code.  A
    follow-up commit (Cleanup AFS_*LINUX_ENV usage) will handle these
    changes.

    The updates should have no functional changes.

    Reviewed-on: https://gerrit.openafs.org/14387
    Tested-by: BuildBot <buildbot@rampaginggeek.com>
    Reviewed-by: Benjamin Kaduk <kaduk@mit.edu>
    (cherry picked from commit 6329a523f6305541871bc3d1694065e7b17abe77)

    [cwills@sinenomine.net] Conflicts due to:
       'afs: Set AFS_VFSFSID to a numerical value' is already in 1.8.x
       'Linux 5.15: Convert osi_Msg macro to a function' is already in 1.8.x
       'fsint: remove dead code' is not in 1.8.x (removes fsint/afsaux.c)
       'Remove rpctestlib' is not in 1.8.x (removes rpc_test_procs.c)

    Change-Id: I19da50622f63db0fcad7acd834559c538e6030be

commit 46feaf035bb0614805a6db54dde87cd68c57553d
Author: Andrew Deason <adeason@sinenomine.net>
Date:   Thu Jun 2 11:11:24 2022 -0600

    Remove AFS_PARISC_LINUX24_ENV references

    Since commit 91713206 (Remove LINUX24 from src/afs),
    AFS_PARISC_LINUX24_ENV is never defined. Remove references to it.

    Reviewed-on: https://gerrit.openafs.org/14472
    Reviewed-by: Andrew Deason <adeason@sinenomine.net>
    Tested-by: BuildBot <buildbot@rampaginggeek.com>
    Reviewed-by: Benjamin Kaduk <kaduk@mit.edu>
    (cherry picked from commit e0e0b3cea6305cdbccc71039a05d6121c32c51cf)

    Change-Id: I4871f5ba6018ab47c78d3f07d4665b5a2676102f

commit 5dc0467022a7666249251a7ee132d8ced60ff6ed
Author: Andrew Deason <adeason@sinenomine.net>
Date:   Tue Jun 2 13:37:00 2020 -0500

    afs: Always define our own osi_timeval32_t

    Since OpenAFS 1.0, osi_GetTime has taken a timeval-like pointer, which
    contains 32-bit fields (the actual type has been called either
    osi_timeval_t or osi_timeval32_t over time). For platforms that have a
    native timeval-like type with 32-bit fields, we just define
    osi_timeval32_t to that type, and elsewhere we define our own struct
    to be osi_timeval32_t. For platforms that use the native timeval, we
    can then define osi_GetTime() to just be, e.g., microtime().

    This approach is difficult to maintain, though, because we must keep
    track of whether 'struct timeval' contains 32-bit fields on each
    platform, which can depend on many factors. It's easy to make mistakes
    (the current tree already contains mistakes), and there's not much
    benefit.

    To avoid all of this, just always define osi_timeval32_t to be our own
    struct with afs_int32 fields, and provide definitions for osi_GetTime
    that convert from the native time struct to our osi_timeval32_t. This
    does mean that for some platforms we do an unnecessary type
    conversion, but this is a small price to pay for more straightforward
    and maintainable code.

    To be a little more sure that our types are correct, change
    osi_GetTime to be defined as an inline function instead of a macro.

    At the same time, do a similar conversion for the KERNEL
    implementation of the rx clock_GetTime function. Get rid of
    platform-specific mess, and do a straightforward type conversion
    between osi_timeval32_t and struct clock in an inline function.

    Reviewed-on: https://gerrit.openafs.org/14238
    Reviewed-by: Michael Meffie <mmeffie@sinenomine.net>
    Reviewed-by: Benjamin Kaduk <kaduk@mit.edu>
    Tested-by: BuildBot <buildbot@rampaginggeek.com>
    (cherry picked from commit eccd4b9778014c36a4b3af6d9e80194066bd2195)

    Change-Id: Ia6ccc7ff3e3a7cfb346449c1335e7a045688aebf

commit dbd7c205439672a0d12c4dfaf5eb0481e47593b8
Author: Andrew Deason <adeason@sinenomine.net>
Date:   Tue Jun 2 13:12:14 2020 -0500

    afs: Move osi_GetTime out of param.h

    Most platforms currently #define osi_GetTime in their param.h. This is
    really redundant, since the definition of osi_GetTime almost never
    changes for a given platform, so we end up with many copies of the
    same osi_GetTime definition for a given platform.

    Move osi_GetTime out of param.h for these platforms, and define it in
    osi_machdep.h instead, which is where most platform-specific
    definitions go.

    For DFBSD, we don't have an osi_machdep.h at all yet, so create a new
    one to contain the osi_GetTime definition. Currently we don't build
    libafs at all on DFBSD, but do this anyway so we don't lose the
    existing osi_GetTime definition.

    For NBSD, we were providing (conflicting!) definitions for osi_GetTime
    in param.h and in osi_machdep.h. Just remove the definitions in
    param.h, since those should have been getting overridden by the
    osi_machdep.h definition.

    Reviewed-on: https://gerrit.openafs.org/14237
    Tested-by: BuildBot <buildbot@rampaginggeek.com>
    Reviewed-by: Michael Meffie <mmeffie@sinenomine.net>
    Reviewed-by: Benjamin Kaduk <kaduk@mit.edu>
    (cherry picked from commit a5c3dfe99fa1831e3b416e89f52a03fd1cf9f73d)

    Change-Id: I3afff0c1b4c14649cc072d555d0c3ebd6de8a0fe

commit 58cab27bee19e0e22c32c527647d7281333b35b4
Author: Mark Vitale <mvitale@sinenomine.net>
Date:   Tue May 5 11:26:00 2020 -0400

    UKERNEL: remove redundant declaration of osi_GetTime

    Commit c861bb0d779b54236b63eda87d9dfaf7792d1659 "Additional UKERNEL
    headers, prototyping and other fixes" added the following lines to
    src/rx/rx_prototypes.h:

      #if defined(UKERNEL) && !defined(osi_GetTime)
      extern int osi_GetTime(struct timeval *tv);
      #endif

    However, this appears to be redundant with the declaration in
    src/afs/afs_prototypes.h:

      #ifdef UKERNEL
      ...
      extern int osi_GetTime(struct timeval *tv);
      ...
      #endif

    which was added much earlier with commit
    8f2df21ffe59e9aa66219bf24656775b584c122d
    "pull-prototypes-to-head-20020821".

    Remove the redundant declaration in rx/rx_prototypes.h.

    No functional change is incurrred by this commit.

    Reviewed-on: https://gerrit.openafs.org/14192
    Reviewed-by: Andrew Deason <adeason@sinenomine.net>
    Tested-by: BuildBot <buildbot@rampaginggeek.com>
    Reviewed-by: Benjamin Kaduk <kaduk@mit.edu>
    (cherry picked from commit 03f44172180563cb9d12d79e5512aae815fee899)

    Change-Id: I2e562f0e25bf4dd0f47f952782792585a8e7fc20

commit bc36661da3f8a26d670b5d0468887cd0e488ac82
Author: Mark Vitale <mvitale@sinenomine.net>
Date:   Mon May 18 14:19:25 2020 -0400

    Convert all osi_timeval_t to osi_timeval32_t

    Since commit 130144850c6d05bc69e06257a5d7219eb98697d8 "xstat: cm xstat
    time values are 32 bit", OpenAFS has had two timeval definitions:
    osi_timeval_t and osi_timeval32_t.  Since they are functionally
    equivalent, convert all references to osi_timeval_t to osi_timeval32_t.
    This makes clear that this struct is always expected to contain 32-bit
    members for tv_sec and tv_usec.

    There are still a few platforms where osi_timeval32_t is mistakenly
    defined with 64-bit members; these will be addressed in future commits.

    No functional change should be incurred by this commit.

    Reviewed-on: https://gerrit.openafs.org/14215
    Reviewed-by: Andrew Deason <adeason@sinenomine.net>
    Tested-by: BuildBot <buildbot@rampaginggeek.com>
    Reviewed-by: Cheyenne Wills <cwills@sinenomine.net>
    Reviewed-by: Benjamin Kaduk <kaduk@mit.edu>
    (cherry picked from commit c6eff25be9fc959f666b33425c9ee2635224826e)

    Change-Id: I55a2ac3d7fb65c3b14aded755cd81056a3775f74

commit 636b5a5561ba3405302d12c09dd7fb001451b5f1
Author: Mark Vitale <mvitale@sinenomine.net>
Date:   Mon May 4 17:35:05 2020 -0400

    UKERNEL: remove dead code osi_SetTime

    osi_SetTime has been dead code since the original IBM code import.
    Remove it from the tree.

    No functional change is incurred by this commit.

    Reviewed-on: https://gerrit.openafs.org/14191
    Reviewed-by: Andrew Deason <adeason@sinenomine.net>
    Tested-by: BuildBot <buildbot@rampaginggeek.com>
    Reviewed-by: Benjamin Kaduk <kaduk@mit.edu>
    (cherry picked from commit d6101128664918e6fcefbaeb68c4c1d439851411)

    Change-Id: I8a406e4199b959f7470b53882ee143efb8723d7c

commit f6ad2f7c175f421f035e8e1b28221a3005349e75
Author: Cheyenne Wills <cwills@sinenomine.net>
Date:   Thu Jun 2 11:18:59 2022 -0600

    clang-10: use AFS_FALLTHROUGH for case fallthrough

    Clang-10 will not recognize '/* fallthrough */' as an indicator to
    turn off the fallthrough diagnostic due to the lack of a 'break' in a
    case statement.  Clang-10 requires the '__attribute__((fallthrough))'
    statement to disable the diagnostic.

    In addition clang-10 is finding additional locations where fall throughs
    occur.

    Determine if the compiler supports '__attribute__((fallthrough))' to
    disable the implicit fallthrough diagnostic.

    Define a new macro 'AFS_FALLTHROUGH' that will disable the fallthrough
    diagnostic. Set it as a wrapper for the Linux kernel's 'fallthrough'
    macro if available, otherwise set it as a wrapper macro for
    '__attribute__((fallthrough))' if the compiler supports it.

    Update CODING to document the use of AFS_FALLTHROUGH when needing to
    fallthrough between case statements.

    Replace the '/* fallthrough */' comments with AFS_FALLTHROUGH, and add
    AFS_FALLTHROUGH as needed.

    Replace some fallthroughs with a break (or goto) if the flow was was
    just to a break (or goto).

    e.g.   case x:                 case x:
               somestmt;               somestmt;
                                       break;
           case y:                 case y:
               break;                  break;

    Correct a mis-indented brace '}' in src/WINNT/afsd/smb3.c

    Note, the clang maintainers have rejected the use of comments as a flag
    to turn off the fall through warnings.

    Reviewed-on: https://gerrit.openafs.org/14274
    Tested-by: BuildBot <buildbot@rampaginggeek.com>
    Reviewed-by: Andrew Deason <adeason@sinenomine.net>
    Reviewed-by: Benjamin Kaduk <kaduk@mit.edu>
    (cherry picked from commit 16f1b2f894c28614df0f096be8232b1176e87c70)

    [cwills@sinenomine.net Note the fallthrough case in asetkey.c that
    exists in the original master commit is not present 1.8.x]

    Change-Id: I4d92d519bd168ac111f46d37bcf7dca7021e5463

commit 840bcf2ecb6d0203af5ec26c072e637acf10f060
Author: Cheyenne Wills <cwills@sinenomine.net>
Date:   Thu Jun 2 10:56:39 2022 -0600

    Add more 'fall through' switch comments

    Commit a455452d (LINUX 5.3: Add comments for fallthrough switch cases)
    added the special /* fall through */ comment to various switch/case
    blocks, in order to avoid implicit-fallthrough warnings from causing
    the build to fail when building the Linux kernel module.

    In this commit, add additional /* fall through */ comments to the rest
    of the tree where falling through is intentional. Add a "break;" in one
    place in dumptool.c where falling through seems like a mistake, and flag
    certain functions as AFS_NORETURN to avoid needing to explicitly break
    or fallthrough.

    Check for the availability of the -Wimplicit-fallthrough compiler flag
    and use it when --enable-checking is set, to prevent additional cases
    from creeping into the tree.

    Note: the -Wimplicit-fallthrough compiler flag was added in gcc 7.

    Reviewed-on: https://gerrit.openafs.org/14125
    Reviewed-by: Andrew Deason <adeason@sinenomine.net>
    Reviewed-by: Benjamin Kaduk <kaduk@mit.edu>
    Tested-by: BuildBot <buildbot@rampaginggeek.com>
    (cherry picked from commit 929d501421579290ce1d4f9aabe45980e5458a9a)

    Change-Id: I57d19d715fe61e9125b0b9efc8ae36934001bb10

commit ece8e2eb10e15b54411cfd8b9d7cb25c74a843aa
Author: Andrew Deason <adeason@sinenomine.net>
Date:   Tue Mar 31 21:19:18 2020 -0500

    vos: Properly print volume transaction flags

    Currently, the code in 'vos status' treats the 'iflags' and 'vflags'
    of a transaction like an enumerated type; that is, we only check if
    'iflags' is equal to ITOffline or ITBusy, etc. But both of these flags
    fields are bitfields; any combination of the relevant flags could
    theoretically be set.

    Practically speaking, we only ever set at most one of the flags in
    'iflags', but if anything ever did set more than one flag, our output
    would look broken (we'd print "attachFlags:" without any flags).

    For 'vflags', multiple flags are often set at once: the most common
    combination is VTDeleteOnSalvage|VTOutOfService. So currently, we
    usually print "attachFlags:" without any actual flags, since the
    'vflags' field isn't exactly equal to VTDeleteOnSalvage (instead it's
    set to VTDeleteOnSalvage|VTOutOfService). And if we ever did see just
    VTDeleteOnSalvage set by itself, the way the switch() cases fall
    through to each other, we'd print out that _all_ flags are set.

    To fix all of this, just test for the individual flag bits instead.

    Reviewed-on: https://gerrit.openafs.org/14126
    Tested-by: Andrew Deason <adeason@sinenomine.net>
    Tested-by: BuildBot <buildbot@rampaginggeek.com>
    Reviewed-by: Cheyenne Wills <cwills@sinenomine.net>
    Reviewed-by: Benjamin Kaduk <kaduk@mit.edu>
    (cherry picked from commit f841c189a53f3a6bcf5c25336e4e0ad5362036e2)

    Change-Id: Id57d2569bbaa94bb9e7e621cdd16c1e171899362

commit 2fc72e86271d47d398c134e8e7fef132aa926042
Author: Michael Meffie <mmeffie@sinenomine.net>
Date:   Thu Jun 2 10:48:49 2022 -0600

    autoconf: attribute type checks

    Check for function attributes by type and update src/afs/stds.h to
    conditionally include the attributes detected, instead of checking for
    specific compilers and compiler versions.

    This allows attributes to be used when building under Solaris Studio.

    Reviewed-on: https://gerrit.openafs.org/12963
    Reviewed-by: Michael Meffie <mmeffie@sinenomine.net>
    Reviewed-by: Benjamin Kaduk <kaduk@mit.edu>
    Tested-by: BuildBot <buildbot@rampaginggeek.com>
    (cherry picked from commit 1f29c9f05f53966df1bbd9ece479155f78f995e0)

    Change-Id: I6163e3ebf73c6616dfd3de78e76b14b5907bd4df

commit 6fb14a696bb23c44bc142c772d53d7b90cf434ef
Author: Michael Meffie <mmeffie@sinenomine.net>
Date:   Thu Jun 2 10:47:46 2022 -0600

    autoconf: check for format __attribute__ to avoid warnings

    Building with Solaris Studio generates a ludicrous number of warnings
    in the form:

       roken.h, line ...: warning: attribute "format" is unknown, ignored

    Modern Solaris Studio supports several GCC-style function attributes,
    including the `noreturn' attribute, however does not support the
    `format' attribute.

    Currently, configure defines HAVE___ATTRIBUTE__ when the `noreturn'
    attribute is available. roken headers conditionally declare printf-like
    functions with the `format' function attribute when HAVE___ATTRIBUTE__
    is defined, leading to the warning messages when building under Solaris
    Studio. Unsupported function attributes generate warnings, not errors.

    Fix these warnings by defining HAVE___ATTRIBUTE__ if and only if the
    `format' attribute is supported by the compiler, instead of checking for
    `noreturn'.  Note that the `format' type is currently the only attribute
    used by roken at this time.

    Reviewed-on: https://gerrit.openafs.org/12956
    Reviewed-by: Andrew Deason <adeason@sinenomine.net>
    Tested-by: BuildBot <buildbot@rampaginggeek.com>
    Reviewed-by: Benjamin Kaduk <kaduk@mit.edu>
    (cherry picked from commit f9b3cf888304d42c2a1a8472fdeeab68a7347859)

    Change-Id: I7ae19fa3d7d90e67d6eb63ef9b51a74a215e9273

commit cb55177611058110057512116861c96e5de5c346
Author: Andrew Deason <adeason@sinenomine.net>
Date:   Sat Apr 4 22:35:07 2020 -0500

    Use autoconf-archive m4 from src/external

    Switch to using the m4 macros from autoconf-archive in our
    src/external mechanism, instead of manually-copied versions in src/cf.
    The src/external copy of ax_gcc_func_attribute.m4 is identical to the
    existing copy in src/cf, so that should incur no changes. There are
    also a few new macros pulled in, but they are currently unused.

    Increase our AC_PREREQ in configure.ac to 2.64, to match the AC_PREREQ
    in some of the new files.

    Reviewed-on: https://gerrit.openafs.org/14135
    Tested-by: BuildBot <buildbot@rampaginggeek.com>
    Reviewed-by: Cheyenne Wills <cwills@sinenomine.net>
    Reviewed-by: Benjamin Kaduk <kaduk@mit.edu>
    (cherry picked from commit ca847ddf35e336a8bc3159ce4b26f0162417bbd5)

    Change-Id: Ifa43b3869e426fada5bd925b0ae002a0f6436232

commit a865c3f3f60b47d5b8338314a9805075d65ea561
Author: Autoconf Archive Maintainers <autoconf-archive-maintainers@gnu.org>
Date:   Tue Apr 7 10:23:16 2020 -0500

    Import of code from autoconf-archive

    This commit updates the code imported from autoconf-archive to
    24358c8c5ca679949ef522964d94e4d1cd1f941a (v2019.01.06)

    New files are:
    	m4/ax_append_compile_flags.m4
    	m4/ax_append_flag.m4
    	m4/ax_check_compile_flag.m4
    	m4/ax_gcc_func_attribute.m4
    	m4/ax_require_defined.m4

    Reviewed-on: https://gerrit.openafs.org/14138
    Reviewed-by: Cheyenne Wills <cwills@sinenomine.net>
    Tested-by: BuildBot <buildbot@rampaginggeek.com>
    Reviewed-by: Benjamin Kaduk <kaduk@mit.edu>
    (cherry picked from commit d8205bbb482554812fbe66afa3c337d991a247b6)

    Change-Id: Ibc18f5ddef8b63ba258fa666ada60577a845aa8f

commit ea7c96283770091d7ff987d35ccbcb72aeeab4c7
Author: Andrew Deason <adeason@sinenomine.net>
Date:   Sat Apr 4 22:28:21 2020 -0500

    Add autoconf-archive to src/external

    Add autoconf-archive to the src/external mechanism, so we can more
    easily import and update the AX_* m4 macros we pull in from
    autoconf-archive. Commits are imported from
    <git://git.savannah.gnu.org/autoconf-archive.git>.

    We already have a copy of ax_gcc_func_attribute.m4 in the tree, so
    include that in the list of files. While we're here, also include a
    few more macros for checking compiler flags, which will be used in
    subsequent commits.

    Reviewed-on: https://gerrit.openafs.org/14133
    Reviewed-by: Cheyenne Wills <cwills@sinenomine.net>
    Tested-by: BuildBot <buildbot@rampaginggeek.com>
    Reviewed-by: Benjamin Kaduk <kaduk@mit.edu>
    (cherry picked from commit a072c65bba86cbcd81157e354d3719ac41a2c97d)

    Change-Id: I785607be9abe85e43287c4880103a365e264473b

commit 002ace5d2c118ad1c5599f931ec1105c60e36843
Author: Michael Meffie <mmeffie@sinenomine.net>
Date:   Fri Mar 16 20:41:35 2018 -0400

    autoconf: import gcc function attribute check macro

    Import Gabriele Svelto's AC_GCC_FUNC_ATTRIBUTE autoconf macro to check for
    GCC-style function attributes.  This macro is part of the GNU Autoconf
    Archive[1]. The imported file is distributed under an all-permissive license.

    [1] https://www.gnu.org/software/autoconf-archive/

    Reviewed-on: https://gerrit.openafs.org/12962
    Tested-by: BuildBot <buildbot@rampaginggeek.com>
    Reviewed-by: Andrew Deason <adeason@sinenomine.net>
    Reviewed-by: Benjamin Kaduk <kaduk@mit.edu>
    (cherry picked from commit b818854f19e33315d1b6453b72a55b54d740e976)

    Change-Id: I6305bf70715048da7da0d605d4ad4bf5551291c0

commit 871120323c3c9bcdc1a82d0f681cd8e6b08128a8
Author: Andrew Deason <adeason@dson.org>
Date:   Sun Dec 22 00:43:07 2019 -0600

    FBSD: Use GENERIC kernel headers by default

    Currently, if --with-bsd-kernel-build is not specified during
    configure, we do not set KERNBUILDDIR during the libafs build at all.
    This means that we do not use an opt_global.h during the build.

    For the GENERIC kernel, in the past this has worked well enough to
    produce a working kernel module, but with FreeBSD 12, the GENERIC
    kernel turns on the VIMAGE option by default. If our kernel module is
    built without VIMAGE defined, our kernel module cannot be loaded into
    GENERIC, since VIMAGE changes the definitions of some symbols that we
    use (for example, trying to load such a libafs fails with the message
    "link_elf_obj: symbol in_ifaddrhead undefined").

    To allow the build to work by default for GENERIC kernels, without
    needing any additional configure flags, change the libafs Makefile to
    use the headers for the GENERIC kernel if no kernel build dir is
    given. To do this, we create a directory in our build tree and
    generate the opt_*.h headers in there (using config(8)), and specify
    that directory as the kernel build dir.

    This approach only works for GENERIC kernels, of course, but that is
    the most common scenario. Users that want to build for a custom kernel
    configuration still need to specify the actual kernel build dir with
    --with-bsd-kernel-build.

    Reviewed-on: https://gerrit.openafs.org/14001
    Tested-by: BuildBot <buildbot@rampaginggeek.com>
    Reviewed-by: Benjamin Kaduk <kaduk@mit.edu>
    (cherry picked from commit a9c1939eeb36372872f3258a9ae7259a564332c3)

    Change-Id: I456871c2b55cd3fc1eef7bf68011a725e253b902

commit 98ceecd283cc2bca804c776634f89f71cffa5d62
Author: Andrew Deason <adeason@dson.org>
Date:   Wed Jan 1 17:09:24 2020 -0600

    FBSD: Avoid recursive osi_VM_StoreAllSegments lock

    Currently, osi_VM_StoreAllSegments calls vget() for the given vnode,
    which requires locking the vnode. However, the vnode should already be
    locked. For example, when called from the close syscall, we reach this
    function via: vn_close1 -> afs_vop_close -> afs_close ->
    afs_StoreOnLastReference -> afs_StoreAllSegments ->
    osi_VM_StoreAllSegments. This causes a panic like so:

        kernel: panic: lockmgr_xlock_hard: recursing on non recursive lockmgr 0x[...] @ /usr/src/sys/kern/vfs_subr.c:2730

    We can also reach this code path from the BOP_STORE background
    operation (BStore -> afs_StoreOnLastReference -> afs_StoreAllSegments
    -> osi_VM_StoreAllSegments), initiated from afs_close(), which has the
    vnode locked. In this case, we won't be recursively locking the vnode,
    since the process calling afs_close() is the one that holds the lock,
    and the background thread is the process trying to lock the vnode
    again. So we'll just deadlock.

    From the comments in this function, it seems like locking the vnode at
    all in here is unnecessary, since the vnode should be locked from the
    higher-level functions anyway. So just skip the vget and all of the
    related looping retry logic. As a result, this function can now become
    somewhat simplified.

    Reviewed-on: https://gerrit.openafs.org/14000
    Tested-by: BuildBot <buildbot@rampaginggeek.com>
    Reviewed-by: Benjamin Kaduk <kaduk@mit.edu>
    (cherry picked from commit bdd4a0c78b1acaf1c947ca53d16159ef95cc9840)

    Change-Id: I9f279cef6aef9beff6636edc0cd7cfa5f3d36cfa

commit 6274236570d34d01ccb09f9644eb97d84f57267b
Author: Mans Nilsson <mansaxel@besserwisser.org>
Date:   Thu Dec 16 21:36:22 2021 +0100

    Add sysname, files and header entries for FreeBSD 12.3

    Created a new sysname "amd64_fbsd_123" in src/config/afs_sysnames.h
    and added "param" files with minimal changes:

    	modified:   src/config/afs_sysnames.h
    	new file:   src/config/param.amd64_fbsd_123.h
    	new file:   src/config/param.i386_fbsd_123.h

    This mod builds on 12.3 with all tests passing.

    Reviewed-on: https://gerrit.openafs.org/14860
    Tested-by: BuildBot <buildbot@rampaginggeek.com>
    Reviewed-by: Benjamin Kaduk <kaduk@mit.edu>
    (cherry picked from commit 7a6192276b3779205fa8bc8c141eda41cf28e37e)

    Change-Id: Id66f9fe5663b33671ba1b9e68b8715a5eacd5da2

commit 9f1165538bd7ff4290964f35190553079ee26b42
Author: Michael Meffie <mmeffie@sinenomine.net>
Date:   Tue Aug 4 10:34:07 2020 -0400

    tests: Accommodate c-tap-harness 4.7

    The SOURCE and BUILD environment variables have been changed to
    C_TAP_SOURCE and C_TAP_BUILD in the new version of c-tap-harness.  The
    runtests command syntax has changed as well.

    Convert all of the old SOURCE and BUILD environment variables to the new
    C_TAP_SOURCE and C_TAP_BUILD names.

    Add the required -l command line option to specify the test list.

    Add the new runtests -v option to run the tests in verbose mode to make
    it easier to see which tests failed.

    Reviewed-on: https://gerrit.openafs.org/14295
    Tested-by: BuildBot <buildbot@rampaginggeek.com>
    Reviewed-by: Andrew Deason <adeason@sinenomine.net>
    Reviewed-by: Benjamin Kaduk <kaduk@mit.edu>
    (cherry picked from commit 624219a1b2192e5c7b6b45e2cbe784a9c5f33a96)

    Change-Id: I3a1ed224a6271918711bdd520094df348d7f8cae

commit 2ee6960e6e7c3652eab4ec044d5eb2588762006c
Author: Russ Allbery <rra@stanford.edu>
Date:   Mon Aug 3 20:59:25 2020 -0400

    Import of code from c-tap-harness

    This commit updates the code imported from c-tap-harness to
    abdb66561ffd4d2f238fdb06f448ccf09d80c059 (release/4.7)

    Upstream changes are:

    Daniel Collins (1):
          Add is_blob() test function.

    Daniel Kahn Gillmor (1):
          LICENSE: use https for all URLs

    Daria Brashear (1):
          Add verbose mode environment variable to runtests

    Julien ÉLIE (2):
          Document -v in usage and comments of runtests
          Avoid realloc of zero length in tests/runtests.c

    Marc Dionne (1):
          Add test_cleanup_register_with_data

    Russ Allbery (115):
          clang --analyze cleanups for runtests
          Modernize POD tests
          Update README to my current layout
          Explicitly note that test programs must be executable
          Fix comment typo in tests/runtests.c
          Switch to a copyright-format 1.0 LICENSE file
          Flush harness output after each line
          Show the test count as ? when the plan is deferred
          More correctly backspace over test counts when aborting
          Refactor test list handling
          Allow passing tests on the runtests command line
          Don't allow command-line arguments if a list was given
          Search for tests under the name given as well
          Release 2.0
          Fix backward incompatibility when searching for tests
          Document decision to ignore TAP version directives
          Release 2.1
          Document different runtests behavior in bail handling
          Change exit status of bail to 255
          Release 2.2
          Add a new test_cleanup_register C API
          Add warn_unused_result attributes
          Add portability for warn_unsed_result attributes to tap/macros.h
          Minor coding style fix (spacing) in runtests.c
          Split the runtests usage string for ISO C90 string limits
          Include stddef.h
          Diagnose failure to register the exit handler
          Use diag internally in the basic C TAP library
          Some additional comments about cleanup functions
          Move repetitive printing code in the C TAP library to a macro
          Set a flag when bailing for more correct cleanup
          Change my email address to eagle@eyrie.org
          Release 2.3
          Add diag_file_add and diag_file_remove functions
          Don't die for unknown files passed to diag_file_remove
          Release 2.4
          Update comment about AIX and WCOREDUMP
          Don't test for NULL before calling free
          Be more careful about file descriptors in child processes
          Run cleanup functions in non-primary processes as well
          Release 3.0
          Update collective package copyright notices at start of LICENSE
          Check integer overflows on memory allocation, fix string creation
          Switch POD spelling test to use Lancaster consensus variable
          Add new bnrealloc API for brealloc with checked multiplication
          Rename nrealloc to reallocarray
          Return the test status from test functions
          Fix the overflow check for breallocarray
          Fix the overflow check for xreallocarray in runtests
          Restructure test result reallocation in runtests
          Change diag and sysdiag to always return true
          Release 3.1
          Fix typos in basic.c and basic.h
          Fix usage message when running runtests with no arguments
          Update introductory runtests comments for current syntax
          Add the -l flag to suggested runtests invocation in README
          Support comments and blank lines in test lists
          Release 3.2
          Update licensing information
          Various improvements to verbose support
          Compile warning-free with Clang, check Autoconf macros
          Release 3.3
          Remove unnecessary assert.h include in tap/basic.c
          Fix some additional -v documentation issues
          Rebalance usage to avoid too-long strings
          Fix segfault in runtests with empty test list
          Release 3.4
          Document running autogen if starting from Git
          Rename autogen to bootstrap
          Support and prefer C_TAP_SOURCE and C_TAP_BUILD
          Fix comment typo in tests/runtests.c
          Add missing va_end to is_double
          Release 4.0
          Fix all non-https www.eyrie.org URLs
          Add is_bool C test function
          Add DocKnot metadata and a Markdown README file
          Update documentation for new DocKnot standards
          Release 4.1
          Use more defaults from DocKnot templates
          Fix new fall-through warning in GCC 7
          Use compiler warnings from rra-c-util, fix issues
          Merge pull request #4 from solemnwarning/master
          Coding style fixes and NEWS for is_blob
          Re-enable -Wunknown-pragmas for GCC
          Avoid zero-length realloc allocations in breallocarray
          Update copyright date on tests/runtests.c
          Release 4.2
          Add SPDX-License-Identifier headers to source files
          Add and run new check-cppcheck target
          Fix instructions for running one test
          Identify values as left and right
          Fix is_string comparisons with NULL pointers
          Add support for running tests under valgrind
          Replace putc with fprintf
          Update shared files from rra-c-util
          Release 4.3
          Update NEWS date for 4.3 release
          Collapse some copyright dates
          NEWS and coding style for test_cleanup_register_with_data
          Remove unused variables caught by Clang scan-build
          Update to rra-c-util 8.0
          Fix error checking in bstrndup
          Release 4.4
          Add support for C++
          Document that C TAP Harness can be built as C++
          Release 4.5
          Regenerate README files
          Reformat using clang-format 10
          Update to rra-c-util 8.1
          Release 4.6
          Fix spelling errors caught by codespell
          Protect the test suite against C_TAP_VERBOSE
          Switch to GitHub Actions for CI
          Add NEWS entry for GCC 10 warning fixes
          Release 4.7

    Reviewed-on: https://gerrit.openafs.org/14294
    Reviewed-by: Andrew Deason <adeason@sinenomine.net>
    Tested-by: Andrew Deason <adeason@sinenomine.net>
    Reviewed-by: Benjamin Kaduk <kaduk@mit.edu>
    (cherry picked from commit 3f377aa117273eba5c77ad652c0b086446b3f874)

    Change-Id: I7b72d9ebd34d3bb5a05268339e136bb1b4309b92

commit d18d5c8ed290b13234b4f69c9cbe08e51654d79d
Author: Andrew Deason <adeason@dson.org>
Date:   Fri Mar 5 22:20:35 2021 -0600

    dir: Explicitly 'make all' in src/dir/test

    Currently, we 'cd test' and then just run 'make', which makes the
    first target specified in the Makefile. On some platforms (FreeBSD),
    this results in 'make' trying to build '%.c', which of course we
    cannot do, since that's a pattern rule, and so 'make' fails.

    To fix this, just 'make all' explicitly, to make the intended targets
    in src/dir/test.

    Reviewed-on: https://gerrit.openafs.org/14550
    Reviewed-by: Benjamin Kaduk <kaduk@mit.edu>
    Tested-by: BuildBot <buildbot@rampaginggeek.com>
    (cherry picked from commit c0b7367253eb6c346d577e099a0b0172d4d24ff3)

    Change-Id: I3c1cc73d88471a31ce2d95325c8dafe797d1c43d

commit bd304fcab943c716097c1f7408f153fde2adc1c2
Author: Mark Vitale <mvitale@sinenomine.net>
Date:   Tue Mar 5 23:11:38 2019 -0500

    dir: make dtest buildable again

    Commit 7fe4125fe3435092b75ed29b884d8d3c2d1a2cad 'dir/vol: Die() really
    does' overlooked src/dir/test/dtest.c, breaking its build.

    Fix the signature of Die() and the makefile so dtest can be built.
    In addition, change the Makefile so it is always built.

    Reviewed-on: https://gerrit.openafs.org/13794
    Reviewed-by: Andrew Deason <adeason@sinenomine.net>
    Reviewed-by: Cheyenne Wills <cwills@sinenomine.net>
    Reviewed-by: Benjamin Kaduk <kaduk@mit.edu>
    Tested-by: BuildBot <buildbot@rampaginggeek.com>
    (cherry picked from commit 192a2ff49af5dbbb4f8175eec7cb63bfe97e444e)

    Change-Id: I92df1068c0c071ac643bd8c43eb7e63efdf4f09b

commit 30798c48534085b5e3811e7412728efce54a3d17
Author: Michael Meffie <mmeffie@sinenomine.net>
Date:   Thu Dec 27 09:32:35 2018 -0500

    build: declare test targets as phony

    Modern versions `make` will not build the 'test' target since a
    directory exists with the same name.

        $ grep -C1 '^test:' Makefile
        test:
            cd test; $(MAKE)

        $ make test
        make: 'test' is up to date.

    Declare these targets as .PHONY to force make to build the test programs
    even when the 'test' directory is present. Also use '&&' to concatenate
    commands instead ';' to avoid running the second command when the first
    fails.

    Reviewed-on: https://gerrit.openafs.org/13419
    Tested-by: BuildBot <buildbot@rampaginggeek.com>
    Reviewed-by: Benjamin Kaduk <kaduk@mit.edu>
    (cherry picked from commit 0bd55a02bb5707b1b8b26347d5cb6ad71765f622)

    Change-Id: I4bc8c09720a19658afbab733ea74332083bb29f4

commit 3c526941ec1848be635d4729bef1e379b1fabcba
Author: Andrew Deason <adeason@sinenomine.net>
Date:   Fri Apr 16 11:11:35 2021 -0500

    rx: Remove delays in multi_End_Ignore

    When using our multi_Rx mechanism, callers can use either multi_End or
    multi_End_Ignore at the end of the multi_Rx block. Among other things,
    these macros run 'rx_EndCall(call, code)' for each call in the
    multi_Rx invocation that hasn't already ended. For multi_End, 'code'
    is RX_USER_ABORT, and for multi_End_Ignore, 'code' is 0; the macros
    are otherwise equivalent.

    When multi_End is used, this means any un-ended calls are aborted with
    RX_USER_ABORT, and the call immediately ends. But when
    multi_End_Ignore is used, the call is not aborted, and so we must wait
    for the peer to acknowledge that it has received our packets before
    ending (done via an rxi_ReadProc call in rx_EndCall).

    This means that if a caller multi_Abort's out of a multi call and uses
    multi_End_Ignore, we'll wait for the peer to acknowledge our packets
    for all of the calls we haven't processed. Waiting for that is a
    complete waste of time, since we don't care about the results of those
    calls (since we multi_Abort'd). This doesn't matter much if those
    calls are responded to promptly, but if the peer is not up or is just
    slow, it can cause us to wait several seconds until we timeout.

    There are currently only three users of multi_End_Ignore:

    - DoProbe in src/ubik/recovery.c

    - MultiBreakCallBackAlternateAddress_r in src/viced/callback.c

    - MultiProbeAlternateAddress_r in src/viced/callback.c

    All of these use multi_Rx to try and probe multiple IPs for the same
    machine in parallel, and so some of the calls may very well be trying
    to contact unreachable IPs; we only need one to work for the call to
    succeed.

    To avoid the unnecessary delays in these codepaths, convert them to
    use multi_End. Change multi_End_Ignore to be the same as multi_End,
    and multi_Finalize_Ignore to the same as multi_Finalize, to make sure
    the bad behavior is not used. The _Ignore macros/functions are now
    unused in the tree, but keep them around for now since
    multi_Finalize_Ignore is exported by libafsrpc.

    Thanks to mbarbosa@sinenomine.net for discovering this weird behavior.

    Reviewed-on: https://gerrit.openafs.org/14595
    Tested-by: BuildBot <buildbot@rampaginggeek.com>
    Reviewed-by: Cheyenne Wills <cwills@sinenomine.net>
    Reviewed-by: Benjamin Kaduk <kaduk@mit.edu>
    (cherry picked from commit 002b031d01e3c0f2ad3e1069b98800c3a7228bd5)

    Change-Id: Ic49c0810bdc9643600a5c060bef4a669798afaf3

commit d276e663553343990c504c5d3029edefaa2f7891
Author: Andrew Deason <adeason@sinenomine.net>
Date:   Thu Apr 4 16:18:57 2019 -0400

    fs: Avoid unnecessary cell DNS lookups

    Currently, many routines in 'fs' cause afsconf_GetCellInfo to be
    called for the given cell, which causes an AFSDB/SRV lookup for the
    given cell if the cell has no dbservers specified in the local
    CellServDB. Sites often define such CellServDB records to indicate
    that the given cell exists, but the dbserver IPs should only be looked
    up via DNS.

    However, 'fs' is only calling afsconf_GetCellInfo in order to
    canonicalize the cell name (we're allowed to give an abbreviated name
    for a cell on the command line if the abbreviation is unambiguous, but
    we want to give the full name to the kernel). We don't care about the
    other cell info at all, so triggering a DNS lookup is completely
    unnecessary.

    If our DNS server is not responding, e.g. because we've lost network
    access entirely, this causes the relevant 'fs' commands to fail,
    possibly after a long delay. Some fs commands such as 'fs setcell' are
    often run during client startup, and can still otherwise run fine
    without network access, and so such failures are unnecessary.

    To fix this, we introduce a new function, called afsconf_GetCellName,
    which only returns the full name for a cell, and does not require a
    DNS lookup for such "empty" cells in the local CellServDB. For all
    code paths in 'fs' that just need the cell name (which is all of them
    besides 'fs mkmount'), use this new function.

    Reviewed-on: https://gerrit.openafs.org/13540
    Reviewed-by: Michael Meffie <mmeffie@sinenomine.net>
    Reviewed-by: Cheyenne Wills <cwills@sinenomine.net>
    Tested-by: BuildBot <buildbot@rampaginggeek.com>
    Reviewed-by: Benjamin Kaduk <kaduk@mit.edu>
    (cherry picked from commit 4a150387e3151ecdfca8b4f7c732a1e876968279)

    Change-Id: Ia81eb1e067fe399949d3ea8ae1957e87f6698753

commit b55fcc70a13998f337d6d39c2709c8d75a05a7c8
Author: Mark Vitale <mvitale@sinenomine.net>
Date:   Fri Jan 29 01:00:56 2016 -0500

    afs: clarify cold and warm shutdown logic

    Currently, any code that wants to perform a cold shutdown must first set
    global afs_cold_shutdown = 1, then call afs_shutdown(void).

    Instead, modify afs_shutdown() to accept a single parm which specifies
    AFS_WARM or AFS_COLD shutdown, and to set the value of global
    afs_cold_shutdown based on this parm.  Remove all other assignments for
    afs_cold_shutdown.  Modify all callers of afs_shutdown() to specify
    AFS_WARM or AFS_COLD as needed to maintain equivalent function.

    This should make it much easier to tell at a glance what type of
    shutdown is being requested by each caller to afs_shutdown().

    No functional change should be incurred by this commit.

    Reviewed-on: https://gerrit.openafs.org/12182
    Tested-by: BuildBot <buildbot@rampaginggeek.com>
    Reviewed-by: Andrew Deason <adeason@sinenomine.net>
    Reviewed-by: Benjamin Kaduk <kaduk@mit.edu>
    (cherry picked from commit a2e03e74c4959f72c90288ec85a40c037c9c6243)

    Change-Id: I9271c1161f419ea02b9fe43ec46219dce19c9d50

commit 4c319a35b10293ee89e616b001fe215415bbc298
Author: Michael Meffie <mmeffie@sinenomine.net>
Date:   Fri Oct 18 13:43:36 2019 -0400

    warn when starting without keys

    The server processes will happily start without keys and then fail all
    authenticated access, including database synchronization and local
    commands with -localauth.  At least issue warnings to let admins know
    the keys are missing and that akeyconvert or asetkey needs to be run.

    The situation is not helped by fact the filenames of the key files have
    changed between versions. In 1.6.x the (non-DES) keys were in the
    rxkad.keytab file and in later versions they are in the KeyFile* files,
    so if you are used to 1.6.x it is not obvious what is wrong.

    Reviewed-on: https://gerrit.openafs.org/13911
    Reviewed-by: Andrew Deason <adeason@sinenomine.net>
    Reviewed-by: Cheyenne Wills <cwills@sinenomine.net>
    Reviewed-by: Benjamin Kaduk <kaduk@mit.edu>
    Tested-by: BuildBot <buildbot@rampaginggeek.com>
    (cherry picked from commit 042f809ccfe12bafed73aa4eb4db2c86737e0b22)

    Change-Id: I280d3c83b4576684f2035f79d94966bc5a174681

commit 0d6ca2205df7e17424cd1037736c388b4577b717
Author: Cheyenne Wills <cwills@sinenomine.net>
Date:   Thu Jun 2 13:45:27 2022 -0600

    autoconf: Remove/update obsolete autoconf macros

    Autoconf 2.70 (released in 2020-12) produces warning messages about
    obsolete constructs by default.

    Running regen.sh with autoconf 2.70 installed produces the following
    warnings:

    ..
     configure.ac:7: warning: The macro `AC_CONFIG_HEADER' is obsolete.
     configure.ac:21: warning: AC_PROG_LEX without either yywrap or noyywrap
       is obsolete
     configure.ac:21: warning: The macro `AC_HEADER_STDC' is obsolete.
     configure.ac:21: warning: The macro `AC_HEADER_TIME' is obsolete.
    ..

    Replace AC_CONFIG_HEADER with AC_CONFIG_HEADERS

    Add the noyywrap parameter to AC_PROG_LEX.  Use the noyywrap option
    since we already provide a yywrap function in the .l sources.

    Remove AC_HEADER_STDC.  There are no references to the the autoconf
    variable set by this macro.  This macro was marked as obsolete prior to
    autoconf 2.64 with the following note:
     "This macro is obsolescent, as current systems have conforming header
     files. New programs need not use this macro."

    AC_HEADER_TIME was marked as obsolete prior to autoconf 2.64 with the
    following note:
     "This macro is obsolescent, as current systems can include both files
      when they exist. New programs need not use this macro."

    The only reference that requires AC_HEADER_TIME is within the external
    roken code pulled from heimdal. Compiles that use the external upstream
    heimdal packages result in a build error if TIME_WITH_SYS_TIME is not
    defined:
      building src/crypto/hcrypto
        src/external/heimdal/hcrypto/camellia.c
          include/roken.h:803:58: error: ‘struct tm’ declared inside

    Update autoheader.m4 so a define for TIME_WITH_SYS_TIME is created. This
    avoids modifying the external heimdal/roken code.

    Reviewed-on: https://gerrit.openafs.org/14838
    Tested-by: BuildBot <buildbot@rampaginggeek.com>
    Reviewed-by: Andrew Deason <adeason@sinenomine.net>
    Reviewed-by: Benjamin Kaduk <kaduk@mit.edu>
    (cherry picked from commit 2a659ba160fbdc87a5fb4f330ffda82c1534929d)

    [cwills@sinenomine.net resolved conflict with MACOS_VERSION numbers]

    Change-Id: I1f5ed4ac66bd5bc35ef79e784e784ae2847321a2

commit 0937ab044dd14fbe3461066759dd0529818f9c1b
Author: Pat Riehecky <riehecky@fnal.gov>
Date:   Wed Sep 19 15:51:00 2018 -0500

    configure.ac: Add missing double include guard

    This is primarily a sanity check (identified by clang-tidy).

    Reviewed-on: https://gerrit.openafs.org/13333
    Reviewed-by: Cheyenne Wills <cwills@sinenomine.net>
    Tested-by: BuildBot <buildbot@rampaginggeek.com>
    Reviewed-by: Benjamin Kaduk <kaduk@mit.edu>
    (cherry picked from commit ec45ae60536190c2f5fbf272a9acfe0a85824e24)

    Change-Id: I6cf42d3645fa2669971a3adcd320397afb4cf2bd
---
 CODING                                        |   62 +-
 LICENSE                                       |   15 +
 acinclude.m4                                  |    2 +-
 configure-libafs.ac                           |    2 +-
 configure.ac                                  |    4 +-
 doc/man-pages/pod1/klog.krb5.pod              |   14 +-
 regen.sh                                      |    8 +-
 src/JAVA/libjafs/ACL.c                        |   12 +-
 src/WINNT/afsadmsvr/TaAfsAdmSvrGeneral.cpp    |    2 +-
 src/WINNT/afsd/afskfw.c                       |    2 +-
 src/WINNT/afsd/cm_daemon.c                    |    3 +-
 src/WINNT/afsd/cm_utils.c                     |    2 +-
 src/WINNT/afsd/rpc_srvsvc.c                   |   10 +-
 src/WINNT/afsd/smb.c                          |    2 +-
 src/WINNT/afsd/smb3.c                         |   10 +-
 src/WINNT/afssvrmgr/svr_getdates.cpp          |    2 +-
 src/WINNT/afssvrmgr/svr_install.cpp           |    2 +-
 src/WINNT/afssvrmgr/svr_prune.cpp             |    2 +-
 src/afs/AIX/osi_config.c                      |    2 +-
 src/afs/AIX/osi_machdep.h                     |    9 +
 src/afs/AIX/osi_vfsops.c                      |    3 +-
 src/afs/DARWIN/osi_machdep.h                  |    9 +
 src/afs/DARWIN/osi_vfsops.c                   |    2 +-
 src/afs/DFBSD/osi_machdep.h                   |   31 +
 src/afs/FBSD/osi_machdep.h                    |    9 +
 src/afs/FBSD/osi_vfsops.c                     |    2 +-
 src/afs/FBSD/osi_vm.c                         |   51 +-
 src/afs/HPUX/osi_machdep.h                    |    9 +
 src/afs/HPUX/osi_vfsops.c                     |    2 +-
 src/afs/IRIX/osi_machdep.h                    |   13 +
 src/afs/IRIX/osi_vfsops.c                     |    2 +-
 src/afs/LINUX/osi_compat.h                    |    4 +
 src/afs/LINUX/osi_export.c                    |   10 +-
 src/afs/LINUX/osi_file.c                      |   15 +-
 src/afs/LINUX/osi_groups.c                    |   20 +-
 src/afs/LINUX/osi_ioctl.c                     |    2 +-
 src/afs/LINUX/osi_machdep.h                   |   58 +-
 src/afs/LINUX/osi_module.c                    |    2 +-
 src/afs/LINUX/osi_pag_module.c                |    2 +-
 src/afs/LINUX/osi_probe.c                     |  110 +-
 src/afs/LINUX/osi_proc.c                      |    2 +-
 src/afs/LINUX/osi_syscall.c                   |   64 +-
 src/afs/LINUX/osi_vfsops.c                    |    2 +-
 src/afs/LINUX/osi_vnodeops.c                  |  359 ++++-
 src/afs/NBSD/osi_machdep.h                    |   10 +-
 src/afs/NBSD/osi_vfsops.c                     |    3 +-
 src/afs/OBSD/osi_machdep.h                    |   10 +-
 src/afs/OBSD/osi_vfsops.c                     |    3 +-
 src/afs/SOLARIS/osi_machdep.h                 |    9 +
 src/afs/SOLARIS/osi_vfsops.c                  |    2 +-
 src/afs/SOLARIS/osi_vnodeops.c                |    6 +-
 src/afs/UKERNEL/afs_usrops.c                  |   21 +-
 src/afs/UKERNEL/osi_machdep.h                 |   10 +
 src/afs/UKERNEL/osi_vfsops.c                  |    2 +-
 src/afs/UKERNEL/sysincludes.h                 |    6 +-
 src/afs/VNOPS/afs_vnop_attrs.c                |   26 +-
 src/afs/VNOPS/afs_vnop_create.c               |    4 +-
 src/afs/VNOPS/afs_vnop_fid.c                  |    4 +-
 src/afs/VNOPS/afs_vnop_flock.c                |    8 +-
 src/afs/VNOPS/afs_vnop_lookup.c               |   20 +-
 src/afs/VNOPS/afs_vnop_open.c                 |    2 +-
 src/afs/VNOPS/afs_vnop_read.c                 |    9 +-
 src/afs/VNOPS/afs_vnop_readdir.c              |    8 +-
 src/afs/VNOPS/afs_vnop_remove.c               |    2 +-
 src/afs/VNOPS/afs_vnop_rename.c               |    2 +-
 src/afs/VNOPS/afs_vnop_strategy.c             |    4 +-
 src/afs/VNOPS/afs_vnop_write.c                |    5 +-
 src/afs/afs.h                                 |   37 +-
 src/afs/afs_analyze.c                         |    4 +-
 src/afs/afs_buffer.c                          |    6 +-
 src/afs/afs_bypasscache.c                     |   92 +-
 src/afs/afs_bypasscache.h                     |    5 +-
 src/afs/afs_call.c                            |   52 +-
 src/afs/afs_callback.c                        |    2 +-
 src/afs/afs_cbqueue.c                         |    2 +-
 src/afs/afs_conn.c                            |    4 +-
 src/afs/afs_daemons.c                         |   10 +-
 src/afs/afs_dcache.c                          |   42 +-
 src/afs/afs_error.c                           |    4 +-
 src/afs/afs_fetchstore.c                      |   10 +-
 src/afs/afs_icl.c                             |    4 +-
 src/afs/afs_init.c                            |   39 +-
 src/afs/afs_lock.c                            |    2 +-
 src/afs/afs_osi.c                             |   16 +-
 src/afs/afs_osi.h                             |   35 +-
 src/afs/afs_osi_alloc.c                       |    4 +-
 src/afs/afs_osi_pag.c                         |   30 +-
 src/afs/afs_osi_vget.c                        |    4 +-
 src/afs/afs_osi_vm.c                          |    2 +-
 src/afs/afs_pag_call.c                        |    2 +-
 src/afs/afs_pioctl.c                          |   38 +-
 src/afs/afs_prototypes.h                      |   25 +-
 src/afs/afs_server.c                          |   16 +-
 src/afs/afs_stats.h                           |    2 +-
 src/afs/afs_syscall.c                         |   24 +-
 src/afs/afs_user.c                            |    6 +-
 src/afs/afs_util.c                            |    4 +-
 src/afs/afs_vcache.c                          |   39 +-
 src/afs/afs_volume.c                          |    4 +-
 src/afs/afs_warn.c                            |   14 +-
 src/afs/afsincludes.h                         |    8 +-
 src/afs/lock.h                                |    4 +-
 src/afs/sysincludes.h                         |   12 +-
 src/afsd/afsd.c                               |   31 +-
 src/afsd/afsd_kernel.c                        |   17 +-
 src/aklog/klog.c                              |   38 +-
 src/auth/Makefile.in                          |    3 +-
 src/auth/cellconfig.c                         |   79 +-
 src/auth/cellconfig.p.h                       |    3 +
 src/auth/keys.c                               |   43 +-
 src/auth/ktc.c                                |    6 +-
 src/auth/liboafs_auth.la.sym                  |    2 +
 src/bozo/Makefile.in                          |    3 +-
 src/bozo/bnode.c                              |    2 +-
 src/bozo/bosserver.c                          |    6 +
 src/bucoord/main.c                            |    2 +-
 src/budb/server.c                             |    6 +
 src/butc/afsxbsa.c                            |    8 +-
 src/butc/butc_xbsa.c                          |    2 +-
 src/butc/dump.c                               |    3 +-
 src/butc/tcmain.c                             |    6 +
 src/butm/file_tm.c                            |    2 +-
 src/cf/autoheader.m4                          |   16 +-
 src/cf/c-attribute.m4                         |   37 +-
 src/cf/headers.m4                             |    1 -
 src/cf/lex.m4                                 |    2 +-
 src/cf/linux-checks.m4                        |    9 +-
 src/cf/linux-kernel-func.m4                   |    6 +
 src/cf/linux-kernel-struct.m4                 |    4 +
 src/cf/linux-test5.m4                         |   88 --
 src/cf/osconf.m4                              |   19 +
 src/cf/solaris-test1.m4                       |   18 +-
 src/cmd/cmd.c                                 |    2 +-
 src/comerr/Makefile.in                        |    3 +-
 src/comerr/error_table.y                      |    5 +
 src/config/afs_args.h                         |    2 +-
 src/config/afs_sysnames.h                     |    2 +
 src/config/param.alpha_linux_26.h             |    5 +-
 src/config/param.amd64_fbsd_123.h             |   56 +
 src/config/param.amd64_linux26.h              |    5 +-
 src/config/param.arm64_linux26.h              |    2 +-
 src/config/param.arm_darwin_100.h             |    1 -
 src/config/param.arm_linux26.h                |    5 +-
 src/config/param.generic_fbsd.h               |    1 -
 src/config/param.hp_ux102.h                   |    1 -
 src/config/param.hp_ux110.h                   |    1 -
 src/config/param.hp_ux1123.h                  |    1 -
 src/config/param.hp_ux11i.h                   |    1 -
 src/config/param.i386_fbsd_123.h              |   52 +
 src/config/param.i386_linux26.h               |    5 +-
 src/config/param.i386_umlinux26.h             |    5 +-
 src/config/param.ia64_hpux1122.h              |    1 -
 src/config/param.ia64_hpux1123.h              |    1 -
 src/config/param.ia64_linux26.h               |    5 +-
 src/config/param.linux26.h                    |   11 +-
 src/config/param.nbsd15.h                     |    1 -
 src/config/param.nbsd16.h                     |    1 -
 src/config/param.nbsd20.h                     |    1 -
 src/config/param.nbsd21.h                     |    1 -
 src/config/param.nbsd30.h                     |    1 -
 src/config/param.nbsd40.h                     |    1 -
 src/config/param.nbsd50.h                     |    1 -
 src/config/param.nbsd60.h                     |    1 -
 src/config/param.nbsd70.h                     |    1 -
 src/config/param.ppc64_linux26.h              |    5 +-
 src/config/param.ppc64le_linux26.h            |    5 +-
 src/config/param.ppc_darwin_70.h              |    1 -
 src/config/param.ppc_darwin_80.h              |    1 -
 src/config/param.ppc_darwin_90.h              |    1 -
 src/config/param.ppc_linux26.h                |    5 +-
 src/config/param.rs_aix42.h                   |    1 -
 src/config/param.rs_aix51.h                   |    1 -
 src/config/param.rs_aix52.h                   |    1 -
 src/config/param.rs_aix53.h                   |    1 -
 src/config/param.rs_aix61.h                   |    1 -
 src/config/param.s390_linux26.h               |    5 +-
 src/config/param.s390x_linux26.h              |   15 +-
 src/config/param.sgi_65.h                     |    5 -
 src/config/param.sparc64_linux26.h            |    5 +-
 src/config/param.sparc_linux26.h              |    4 +-
 src/config/param.sun4x_510.h                  |    1 -
 src/config/param.sun4x_511.h                  |    1 -
 src/config/param.sun4x_58.h                   |    1 -
 src/config/param.sun4x_59.h                   |    1 -
 src/config/param.sunx86_510.h                 |    1 -
 src/config/param.sunx86_511.h                 |    1 -
 src/config/param.sunx86_58.h                  |    1 -
 src/config/param.sunx86_59.h                  |    1 -
 src/config/param.x86_darwin_100.h             |    1 -
 src/config/param.x86_darwin_110.h             |    1 -
 src/config/param.x86_darwin_120.h             |    1 -
 src/config/param.x86_darwin_130.h             |    1 -
 src/config/param.x86_darwin_140.h             |    1 -
 src/config/param.x86_darwin_150.h             |    1 -
 src/config/param.x86_darwin_160.h             |    1 -
 src/config/param.x86_darwin_170.h             |    1 -
 src/config/param.x86_darwin_180.h             |    1 -
 src/config/param.x86_darwin_190.h             |    1 -
 src/config/param.x86_darwin_80.h              |    1 -
 src/config/param.x86_darwin_90.h              |    1 -
 src/config/stds.h                             |   46 +-
 src/crypto/hcrypto/kernel/config.h            |    4 +-
 src/dir/Makefile.in                           |    8 +-
 src/dir/dir.c                                 |   12 +-
 src/dir/test/Makefile.in                      |    3 +-
 src/dir/test/dtest.c                          |    4 +-
 src/external/autoconf-archive-author          |    1 +
 src/external/autoconf-archive-files           |    5 +
 src/external/autoconf-archive-last            |    1 +
 .../m4/ax_append_compile_flags.m4             |   46 +
 .../autoconf-archive/m4/ax_append_flag.m4     |   50 +
 .../m4/ax_check_compile_flag.m4               |   53 +
 .../m4/ax_gcc_func_attribute.m4               |  238 ++++
 .../autoconf-archive/m4/ax_require_defined.m4 |   37 +
 src/external/c-tap-harness-last               |    2 +-
 src/external/c-tap-harness/LICENSE            |  290 ++--
 src/external/c-tap-harness/NEWS               |  272 +++-
 src/external/c-tap-harness/README             |  214 ++-
 src/external/c-tap-harness/tests/runtests.c   | 1220 ++++++++++++-----
 src/external/c-tap-harness/tests/tap/basic.c  |  752 +++++++---
 src/external/c-tap-harness/tests/tap/basic.h  |  124 +-
 src/external/c-tap-harness/tests/tap/float.c  |   57 +-
 src/external/c-tap-harness/tests/tap/float.h  |   11 +-
 .../c-tap-harness/tests/tap/libtap.sh         |   34 +-
 src/external/c-tap-harness/tests/tap/macros.h |   37 +-
 src/fsint/afsaux.c                            |    2 +-
 src/gtx/curseswindows.c                       |    2 +-
 src/kauth/kalog.h                             |    4 +-
 src/kauth/kaserver.c                          |    2 +-
 src/kauth/kauth.rg                            |    2 +-
 src/kauth/kkids.c                             |    5 +-
 src/kauth/user.c                              |    2 +-
 src/libacl/Makefile.in                        |    3 +-
 src/libadmin/cfg/cfginternal.c                |   20 +-
 src/libadmin/vos/vsprocs.c                    |    3 +-
 src/libafs/MakefileProto.FBSD.in              |   24 +-
 src/libafs/MakefileProto.LINUX.in             |    7 +-
 src/libafsauthent/afsauthent.def              |    1 +
 src/libuafs/MakefileProto.LINUX.in            |    2 +-
 src/log/Makefile.in                           |    3 +-
 src/lwp/Makefile.in                           |    1 +
 src/lwp/iomgr.c                               |    6 +-
 src/lwp/lwp.c                                 |   41 +-
 src/lwp/lwp.h                                 |    6 +-
 src/lwp/process.c                             |   32 +-
 src/lwp/waitkey.c                             |    2 +-
 src/opr/jhash.h                               |   33 +-
 src/opr/opr.h                                 |    5 +
 src/pam/afs_auth.c                            |    4 +-
 src/pam/afs_password.c                        |    4 +-
 src/pam/afs_session.c                         |    2 +-
 src/pam/afs_setcred.c                         |    4 +-
 src/pam/test_pam.c                            |    2 +-
 src/platform/IRIX/rcmd.c                      |    4 +-
 src/ptserver/ptprototypes.h                   |    2 +-
 src/ptserver/pts.c                            |    9 +-
 src/ptserver/ptserver.c                       |    6 +-
 src/ptserver/ptutils.c                        |    9 +-
 src/ptserver/testpt.c                         |    2 +-
 src/rx/UKERNEL/rx_knet.c                      |    4 +-
 src/rx/rx.c                                   |    4 +-
 src/rx/rx_atomic.h                            |    2 +-
 src/rx/rx_clock.h                             |   23 +-
 src/rx/rx_internal.h                          |    2 +-
 src/rx/rx_kcommon.c                           |   32 +-
 src/rx/rx_kcommon.h                           |   30 +-
 src/rx/rx_kernel.h                            |    2 +-
 src/rx/rx_lwp.c                               |    2 +-
 src/rx/rx_multi.c                             |   15 +-
 src/rx/rx_multi.h                             |    6 +-
 src/rx/rx_packet.c                            |   12 +-
 src/rx/rx_packet.h                            |    4 +-
 src/rx/rx_prototypes.h                        |    7 +-
 src/rx/rx_pthread.c                           |    2 +-
 src/rx/rx_rdwr.c                              |    2 +-
 src/rx/rx_trace.c                             |    2 +
 src/rx/rx_user.c                              |   10 +-
 src/rx/test/testclient.c                      |    4 +-
 src/rx/test/testserver.c                      |    4 +-
 src/rx/xdr.c                                  |   12 +-
 src/rx/xdr.h                                  |    2 +-
 src/rx/xdr_afsuuid.c                          |    2 +-
 src/rx/xdr_array.c                            |    6 +-
 src/rx/xdr_arrayn.c                           |    4 +-
 src/rx/xdr_int32.c                            |    2 +-
 src/rx/xdr_int64.c                            |    2 +-
 src/rx/xdr_rx.c                               |    4 +-
 src/rxgen/rpc_main.c                          |    4 +-
 src/rxkad/bg-fcrypt.c                         |    4 +-
 src/rxkad/fcrypt.c                            |    4 +-
 src/rxkad/rxkad_client.c                      |    2 +-
 src/rxkad/ticket5.c                           |    2 +-
 src/sys/afssyscalls.c                         |   17 +-
 src/sys/afssyscalls.h                         |   11 +-
 src/sys/glue.c                                |    2 +-
 src/sys/iopen.c                               |    3 +-
 src/sys/pioctl.c                              |    2 +-
 src/sys/rmtsysnet.c                           |    7 +-
 src/sys/setpag.c                              |    2 +-
 src/sys/sys_prototypes.h                      |    2 +-
 src/tests/snprintf.c                          |    2 +-
 src/tools/dumpscan/afsdump_dirlist.c          |    2 +-
 src/tools/dumpscan/afsdump_extract.c          |    2 +-
 src/tools/dumpscan/afsdump_scan.c             |    2 +-
 src/tools/dumpscan/dumptool.c                 |    3 +-
 src/tools/dumpscan/parsevnode.c               |    4 +-
 src/ubik/disk.c                               |    8 +-
 src/ubik/recovery.c                           |    2 +-
 src/ubik/remote.c                             |   10 +-
 src/ubik/ubik.p.h                             |    2 +-
 src/update/server.c                           |    6 +
 src/uss/Makefile.in                           |    2 +-
 src/uss/uss_acl.c                             |    7 +-
 src/uss/uss_common.h                          |    2 +-
 src/util/Makefile.in                          |    3 +-
 src/util/afsutil.h                            |    5 -
 src/util/uuid.c                               |    4 +-
 src/util/vice.h                               |    2 +-
 src/venus/Makefile.in                         |    3 +-
 src/venus/fs.c                                |   33 +-
 src/venus/fstrace.c                           |    8 +-
 src/venus/kdump.c                             |  106 +-
 src/vfsck/pass2.c                             |    4 +-
 src/vfsck/pass5.c                             |    2 +-
 src/viced/callback.c                          |    4 +-
 src/viced/viced.c                             |   11 +-
 src/vlserver/vlserver.c                       |    6 +-
 src/vol/Makefile.in                           |    3 +-
 src/vol/daemon_com.h                          |    2 +-
 src/vol/fssync-server.c                       |    5 +-
 src/vol/ihandle.h                             |    6 +-
 src/vol/listinodes.c                          |    4 +-
 src/vol/namei_ops.c                           |   24 +-
 src/vol/partition.c                           |   14 +-
 src/vol/salvaged.c                            |    3 +-
 src/vol/salvager.c                            |    2 +-
 src/vol/salvsync-server.c                     |    2 +-
 src/vol/vol-info.c                            |   26 +-
 src/vol/vol-salvage.c                         |    2 +-
 src/vol/volume.c                              |    8 +-
 src/volser/volmain.c                          |   10 +-
 src/volser/volprocs.c                         |    1 +
 src/volser/vos.c                              |   29 +-
 tests/Makefile.in                             |    6 +-
 tests/auth/keys-t.c                           |    6 +-
 tests/bozo/bos-man-t                          |    2 +-
 tests/bucoord/backup-man-t                    |    2 +-
 tests/cmd/command-t.c                         |    4 +-
 tests/common/servers.c                        |    2 +-
 tests/kauth/kas-man-t                         |    2 +-
 tests/ptserver/pt_util-t                      |    2 +-
 tests/ptserver/pts-man-t                      |    2 +-
 tests/rpctestlib/rpc_test_procs.c             |    4 +-
 tests/rx/perf-t                               |    2 +-
 tests/venus/fs-man-t                          |    2 +-
 tests/volser/vos-man-t                        |    2 +-
 tests/volser/vos-t.c                          |    2 +-
 357 files changed, 4642 insertions(+), 2277 deletions(-)
 create mode 100644 src/afs/DFBSD/osi_machdep.h
 delete mode 100644 src/cf/linux-test5.m4
 create mode 100644 src/config/param.amd64_fbsd_123.h
 create mode 100644 src/config/param.i386_fbsd_123.h
 create mode 100644 src/external/autoconf-archive-author
 create mode 100644 src/external/autoconf-archive-files
 create mode 100644 src/external/autoconf-archive-last
 create mode 100644 src/external/autoconf-archive/m4/ax_append_compile_flags.m4
 create mode 100644 src/external/autoconf-archive/m4/ax_append_flag.m4
 create mode 100644 src/external/autoconf-archive/m4/ax_check_compile_flag.m4
 create mode 100644 src/external/autoconf-archive/m4/ax_gcc_func_attribute.m4
 create mode 100644 src/external/autoconf-archive/m4/ax_require_defined.m4

diff --git a/CODING b/CODING
index 5d62dbb0b..c20842e02 100644
--- a/CODING
+++ b/CODING
@@ -115,6 +115,47 @@ Instead of:
 	    do_something();
 	}
 
+In switch statements, to fall through from one case statement to another, use
+AFS_FALLTHROUGH to mark the intentional fall through.  Do not use fall through
+comments (e.g. /* fallthrough */), as some compilers do not recognize them and
+will flag the case statement with an implied fallthrough warning.
+
+Use:
+
+    switch (x) {
+    case 1:
+        do_something();
+        AFS_FALLTHROUGH;
+    case 2:
+        do_something_else();
+        AFS_FALLTHROUGH;
+    default:
+        do_some_action();
+    }
+
+Instead of using fallthrough comments:
+
+    switch (x) {
+    case 1:
+        do_something();
+        /* fallthrough */
+    case 2:
+        do_something_else();
+        /* fallthrough */
+    default:
+        do_some_action();
+    }
+
+Or not marking the fall through:
+
+   switch (x) {
+    case 1:
+        do_something();
+    case 2:
+        do_something_else();
+    default:
+        do_some_action();
+    }
 
 Dependencies required to build OpenAFS from source
 --------------------------------------------------
@@ -265,7 +306,13 @@ the fix is to mark that warning as ignored, but only for clang. For example:
   # endif
   #endif
 
-If a pragma isn't available for your particular warning, you will need to
+If the source cannot be changed to add a pragma, you might be abe to use the
+autoconf function AX_APPEND_COMPILE_FLAGS to create a new macro that disables
+the warning and then use macro for the build options for that file. For an
+example, see how the autoconf macro CFLAGS_NOIMPLICIT_FALLTHROUGH is defined and
+used.
+
+Finally if there isn't a way to disable the specific warning, you will need to
 disable all warnings for the file in question. You can do this by supplying
 the autoconf macro @CFLAGS_NOERROR@ in the build options for the file. For
 example:
@@ -276,7 +323,10 @@ If you add a new warning inhibition, please also add it to the list below.
 
 Inhibited warnings
 ------------------
-
+uss/lex.i            : fallthrough   : clang fallthrough, flex generated code
+comerr/et_lex.lex.l  : fallthrough   : clang fallthrough, flex generated code
+                                       pragma set to ignored where included in
+                                       error_table.y
 afs/afs_syscall.c    : old-style
 		     : strict-proto
 		     : all (ukernel) : syscall pointer issues
@@ -288,6 +338,10 @@ bucoord/commands.c   : all	     : Ubik_Call
 				     : signed vs unsigned for dates
 butc/tcudbprocs.c    : all	     : ubik_Call
 external/heimdal/hcrypto/validate.c: all: statement with empty body
+external/heimdal/hcrypto/evp.c:      cast-function-type
+             : Linux kernel build uses -Wcast-function-type
+external/heimdal/hcrypto/evp-algs.c: cast-function-type
+             : Linux kernel build uses -Wcast-function-type
 kauth/admin_tools.c  : strict-proto  : ubik_Call
 kauth/authclient.c   : strict-proto  : ubik_Call nonsense
 libadmin/kas/afs_kasAdmin.c: strict-proto : ubik_Call nonsense
@@ -300,4 +354,6 @@ rxkad/ticket5.c      : format-truncation : inside included file v5der.c in the
                                        function _heim_time2generalizedtime, the
                                        two snprintf calls raise
                                        format-truncation warnings due to the
-                                       arithmetic on tm_year and tm_mon fields
\ No newline at end of file
+                                       arithmetic on tm_year and tm_mon fields
+lwp/process.c        : dangling-pointer : Ignore the legitimate use of saving
+                                       the address of a stack variable
diff --git a/LICENSE b/LICENSE
index 92528897a..f200e2a02 100644
--- a/LICENSE
+++ b/LICENSE
@@ -415,3 +415,18 @@ src/cf/lib-pathname.m4 are covered by the following license:
   THIS SOFTWARE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
   WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
   MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+
+====================================================
+
+The files under src/external/autoconf-archive/m4/ are covered by the following
+license:
+
+  Copyright (c) 2008 Guido U. Draheim <guidod@gmx.de>
+  Copyright (c) 2011 Maarten Bosmans <mkbosmans@gmail.com>
+  Copyright (c) 2013 Gabriele Svelto <gabriele.svelto@gmail.com>
+  Copyright (c) 2014 Mike Frysinger <vapier@gentoo.org>
+
+  Copying and distribution of this file, with or without modification, are
+  permitted in any medium without royalty provided the copyright notice
+  and this notice are preserved.  This file is offered as-is, without any
+  warranty.
diff --git a/acinclude.m4 b/acinclude.m4
index c06945c81..16339682d 100644
--- a/acinclude.m4
+++ b/acinclude.m4
@@ -5,6 +5,7 @@ dnl NB: Because this code is a macro, references to positional shell
 dnl parameters must be done like $[]1 instead of $1
 
 AC_DEFUN([OPENAFS_CONFIGURE_COMMON],[
+OPENAFS_AUTOHEADER_TOP
 OPENAFS_AUTOHEADER_BOTTOM
 AC_CANONICAL_HOST
 SRCDIR_PARENT=`pwd`
@@ -57,7 +58,6 @@ OPENAFS_C_ATTRIBUTE
 OPENAFS_C_PRAGMA
 OPENAFS_MORE_ROKEN_CHECKS
 OPENAFS_NETDB_CHECKS
-AC_HEADER_TIME
 OPENAFS_ROKEN_HEADERS
 OPENAFS_BSWAP_CHECKS
 OPENAFS_HPUX_CHECKS
diff --git a/configure-libafs.ac b/configure-libafs.ac
index ae48c4d1e..3eebcfc03 100644
--- a/configure-libafs.ac
+++ b/configure-libafs.ac
@@ -3,7 +3,7 @@ AC_INIT([OpenAFS],[m4_esyscmd(build-tools/git-version .)],[openafs-bugs@openafs.
 AC_CONFIG_AUX_DIR([build-tools])
 AC_CONFIG_SRCDIR([src/libafs/Makefile.common.in])
 
-AC_CONFIG_HEADER([src/config/afsconfig.h])
+AC_CONFIG_HEADERS([src/config/afsconfig.h])
 MACOS_VERSION=1.8.9d1
 
 AC_SUBST([MACOS_VERSION])
diff --git a/configure.ac b/configure.ac
index 8ca01268b..8dca7724c 100644
--- a/configure.ac
+++ b/configure.ac
@@ -1,10 +1,10 @@
-AC_PREREQ([2.60])
+AC_PREREQ([2.64])
 AC_INIT([OpenAFS],[m4_esyscmd(build-tools/git-version .)],[openafs-bugs@openafs.org],[],[http://www.openafs.org/])
 AC_CONFIG_AUX_DIR([build-tools])
 AC_CONFIG_MACRO_DIR([src/cf])
 AC_CONFIG_SRCDIR([src/config/stds.h])
 
-AC_CONFIG_HEADER([src/config/afsconfig.h])
+AC_CONFIG_HEADERS([src/config/afsconfig.h])
 MACOS_VERSION=1.8.9d1
 
 AC_SUBST([MACOS_VERSION])
diff --git a/regen.sh b/regen.sh
index 3ada36c6b..3ae1987f0 100755
--- a/regen.sh
+++ b/regen.sh
@@ -26,11 +26,15 @@ else
   exit 1
 fi
 
+M4_INCS="-I src/cf"
+M4_INCS="$M4_INCS -I src/external/rra-c-util/m4"
+M4_INCS="$M4_INCS -I src/external/autoconf-archive/m4"
+
 echo "Running aclocal"
 if which aclocal > /dev/null 2>&1; then
-  aclocal -I src/cf -I src/external/rra-c-util/m4
+  aclocal $M4_INCS
 elif which aclocal-1.10 > /dev/null 2>&1; then
-  aclocal-1.10 -I src/cf -I src/external/rra-c-util/m4
+  aclocal-1.10 $M4_INCS
 else
   echo "No aclocal found on your system (looked for aclocal & aclocal-1.10)"
   exit 1
diff --git a/src/JAVA/libjafs/ACL.c b/src/JAVA/libjafs/ACL.c
index b818754db..4b364ff29 100644
--- a/src/JAVA/libjafs/ACL.c
+++ b/src/JAVA/libjafs/ACL.c
@@ -86,11 +86,11 @@ char* getACL(char *path)
     params.out = buffer;
     params.out_size = ACL_LEN; 
 
-#if defined(AFS_PPC64_LINUX20_ENV) || defined(AFS_S390X_LINUX20_ENV)
+#if defined(AFS_PPC64_LINUX_ENV) || defined(AFS_S390X_LINUX_ENV)
     if(pioctl(path, VIOCGETAL, &params, 1)) {
-#else /* AFS_PPC_LINUX20_ENV */
+#else /* AFS_PPC_LINUX_ENV */
     if(syscall(AFS_SYSCALL, AFSCALL_PIOCTL, path, VIOCGETAL, &params, 1)) {
-#endif /* AFS_PPC_LINUX20_ENV */
+#endif /* AFS_PPC_LINUX_ENV */
       fprintf(stderr, "ERROR: ACL::getACL -> VIOCGETAL failed: %d, path: %s\n", errno, path);
       free(buffer);
       return NULL;
@@ -117,11 +117,11 @@ jboolean setACL(char *path, char *aclString)
     params.out = NULL;
     params.out_size = 0;
 
-#if defined(AFS_PPC64_LINUX20_ENV) || defined(AFS_S390X_LINUX20_ENV)
+#if defined(AFS_PPC64_LINUX_ENV) || defined(AFS_S390X_LINUX_ENV)
     if(pioctl(path, VIOCSETAL, &params, 1)) {
-#else /* AFS_PPC_LINUX20_ENV */
+#else /* AFS_PPC_LINUX_ENV */
     if(syscall(AFS_SYSCALL, AFSCALL_PIOCTL, path, VIOCSETAL, &params, 1)) {
-#endif /* AFS_PPC_LINUX20_ENV */
+#endif /* AFS_PPC_LINUX_ENV */
       fprintf(stderr, "ERROR: ACL::setACL -> VIOCSETAL failed: %d, path: %s\n", errno, path);
       return JNI_FALSE;
     }
diff --git a/src/WINNT/afsadmsvr/TaAfsAdmSvrGeneral.cpp b/src/WINNT/afsadmsvr/TaAfsAdmSvrGeneral.cpp
index 8e513310d..bf758e530 100644
--- a/src/WINNT/afsadmsvr/TaAfsAdmSvrGeneral.cpp
+++ b/src/WINNT/afsadmsvr/TaAfsAdmSvrGeneral.cpp
@@ -653,7 +653,7 @@ void AfsAdmSvr_Action_StartRefresh (ASID idScope)
       {
       case itCELL:
          AfsAdmSvr_MarkRefreshThread (idScope);
-         // fall through
+         AFS_FALLTHROUGH;
 
       case itSERVER:
          ASACTION Action;
diff --git a/src/WINNT/afsd/afskfw.c b/src/WINNT/afsd/afskfw.c
index 636b58b59..a45896fcf 100644
--- a/src/WINNT/afsd/afskfw.c
+++ b/src/WINNT/afsd/afskfw.c
@@ -1995,7 +1995,7 @@ MultiInputDialogProc( HWND hDialog, UINT message, WPARAM wParam, LPARAM lParam)
                 if ( !GetDlgItemText(hDialog, ID_MID_TEXT+i, mid_tb[i].buf, mid_tb[i].len) )
                     *mid_tb[i].buf = '\0';
             }
-            /* fallthrough */
+            AFS_FALLTHROUGH;
         case IDCANCEL:
             EndDialog(hDialog, LOWORD(wParam));
             return TRUE;
diff --git a/src/WINNT/afsd/cm_daemon.c b/src/WINNT/afsd/cm_daemon.c
index 2a3f032e2..c3f41c852 100644
--- a/src/WINNT/afsd/cm_daemon.c
+++ b/src/WINNT/afsd/cm_daemon.c
@@ -252,7 +252,8 @@ void * cm_BkgDaemon(void * vparm)
                 cm_daemons[daemonID].retryCount++;
                 osi_QAddT((osi_queue_t **) &cm_daemons[daemonID].head, (osi_queue_t **)&cm_daemons[daemonID].tail, &rp->q);
                 break;
-            } /* otherwise fall through */
+            }
+            AFS_FALLTHROUGH;
         case 0:  /* success */
         default: /* other error */
             if (code == 0) {
diff --git a/src/WINNT/afsd/cm_utils.c b/src/WINNT/afsd/cm_utils.c
index f89b84bc3..c335a4098 100644
--- a/src/WINNT/afsd/cm_utils.c
+++ b/src/WINNT/afsd/cm_utils.c
@@ -768,7 +768,7 @@ int cm_MatchMask(clientchar_t *namep, clientchar_t *maskp, int flags)
             break;
         case '.':
             dot++;
-            /* fallthrough */
+            AFS_FALLTHROUGH;
         default:
             if ( star ) {
                 newmask[j++] = '*';
diff --git a/src/WINNT/afsd/rpc_srvsvc.c b/src/WINNT/afsd/rpc_srvsvc.c
index aa262fea0..899e2ad6c 100644
--- a/src/WINNT/afsd/rpc_srvsvc.c
+++ b/src/WINNT/afsd/rpc_srvsvc.c
@@ -877,12 +877,12 @@ NET_API_STATUS NetrShareGetInfo(
                 NetrIntGenerateSharePath(ServerName, &scp->fid);
             /* must be the empty string */
             InfoStruct->ShareInfo2->shi2_passwd = wcsdup(L"");
-            /* fall-through */
+            AFS_FALLTHROUGH;
         case 1:
             InfoStruct->ShareInfo1->shi1_type = STYPE_DISKTREE;
             InfoStruct->ShareInfo1->shi1_remark =
                 NetrIntGenerateShareRemark(scp, &scp->fid);
-            /* fall-through */
+            AFS_FALLTHROUGH;
         case 0:
             /* Canonicalized version of NetName parameter */
             InfoStruct->ShareInfo0->shi0_netname = wcsdup(NetName);
@@ -995,7 +995,7 @@ NET_API_STATUS NetrServerGetInfo(
     switch (Level) {
     case 103:
         InfoStruct->ServerInfo103->sv103_capabilities = 0;
-        /* fall-through */
+        AFS_FALLTHROUGH;
     case 102:
         InfoStruct->ServerInfo102->sv102_users = 0xFFFFFFFF;
         InfoStruct->ServerInfo102->sv102_disc = SV_NODISC;
@@ -1004,13 +1004,13 @@ NET_API_STATUS NetrServerGetInfo(
         InfoStruct->ServerInfo102->sv102_anndelta = 0;
         InfoStruct->ServerInfo102->sv102_licenses = 0;
         InfoStruct->ServerInfo102->sv102_userpath = wcsdup(L"C:\\");
-        /* fall-through */
+        AFS_FALLTHROUGH;
     case 101:
         InfoStruct->ServerInfo101->sv101_version_major = AFSPRODUCT_VERSION_MAJOR;
         InfoStruct->ServerInfo101->sv101_version_minor = AFSPRODUCT_VERSION_MINOR;
         InfoStruct->ServerInfo101->sv101_type = SV_TYPE_WORKSTATION | SV_TYPE_SERVER | SV_TYPE_SERVER_UNIX;
         InfoStruct->ServerInfo101->sv101_comment = wcsdup(wAFSVersion);
-        /* fall-through */
+        AFS_FALLTHROUGH;
     case 100:
         InfoStruct->ServerInfo100->sv100_platform_id = SV_PLATFORM_ID_AFS;
         /* The Netbios Name */
diff --git a/src/WINNT/afsd/smb.c b/src/WINNT/afsd/smb.c
index 22b9d4301..4bfb1bee2 100644
--- a/src/WINNT/afsd/smb.c
+++ b/src/WINNT/afsd/smb.c
@@ -9471,7 +9471,7 @@ void smb_Server(VOID *parmp)
         case NRC_SNUMOUT:
 	case NRC_SABORT:
 	    LogEvent(EVENTLOG_WARNING_TYPE, MSG_UNEXPECTED_SMB_SESSION_CLOSE, ncb_error_string(rc));
-	    /* fallthrough */
+	    AFS_FALLTHROUGH;
 	case NRC_SCLOSED:
             /* Client closed session */
             vcp = smb_FindVC(ncbp->ncb_lsn, 0, lanas[idx_session]);
diff --git a/src/WINNT/afsd/smb3.c b/src/WINNT/afsd/smb3.c
index d461f8515..006e2fa86 100644
--- a/src/WINNT/afsd/smb3.c
+++ b/src/WINNT/afsd/smb3.c
@@ -5392,12 +5392,12 @@ long smb_T2SearchDirSingle(smb_vc_t *vcp, smb_tran2Packet_t *p, smb_packet_t *op
                    shortName);
             fp->u.FfileBothDirectoryInfo.shortNameLength = cm_ClientStrLen(shortName);
 #endif
-    }
-        /* Fallthrough */
+        }
+        AFS_FALLTHROUGH;
 
     case SMB_FIND_FILE_FULL_DIRECTORY_INFO:
         fp->u.FfileFullDirectoryInfo.eaSize = 0;
-        /* Fallthrough */
+        AFS_FALLTHROUGH;
 
     case SMB_FIND_FILE_DIRECTORY_INFO:
         fp->u.FfileDirectoryInfo.nextEntryOffset = 0;
@@ -6108,11 +6108,11 @@ long smb_ReceiveTran2SearchDir(smb_vc_t *vcp, smb_tran2Packet_t *p, smb_packet_t
                     fp->u.FfileBothDirectoryInfo.shortNameLength = cm_ClientStrLen(shortName);
 #endif
                 }
-                /* Fallthrough */
+                AFS_FALLTHROUGH;
 
             case SMB_FIND_FILE_FULL_DIRECTORY_INFO:
                 fp->u.FfileFullDirectoryInfo.eaSize = 0;
-                /* Fallthrough */
+                AFS_FALLTHROUGH;
 
             case SMB_FIND_FILE_DIRECTORY_INFO:
                 fp->u.FfileDirectoryInfo.nextEntryOffset = orbytes + align;
diff --git a/src/WINNT/afssvrmgr/svr_getdates.cpp b/src/WINNT/afssvrmgr/svr_getdates.cpp
index 07096e8fe..b8ba3409b 100644
--- a/src/WINNT/afssvrmgr/svr_getdates.cpp
+++ b/src/WINNT/afssvrmgr/svr_getdates.cpp
@@ -97,7 +97,7 @@ BOOL WINAPI Server_GetDates_DlgProc (HWND hDlg, UINT msg, WPARAM wp, LPARAM lp)
                {
                case IDOK:
                   Server_GetDates_OnOK (hDlg);
-                  // fall through
+                  AFS_FALLTHROUGH;
 
                case IDCANCEL:
                   DestroyWindow (hDlg);
diff --git a/src/WINNT/afssvrmgr/svr_install.cpp b/src/WINNT/afssvrmgr/svr_install.cpp
index 2dfca8bff..f77b54dcb 100644
--- a/src/WINNT/afssvrmgr/svr_install.cpp
+++ b/src/WINNT/afssvrmgr/svr_install.cpp
@@ -94,7 +94,7 @@ BOOL WINAPI Server_Install_DlgProc (HWND hDlg, UINT msg, WPARAM wp, LPARAM lp)
                {
                case IDOK:
                   Server_Install_OnOK (hDlg);
-                  // fall through
+                  AFS_FALLTHROUGH;
 
                case IDCANCEL:
                   DestroyWindow (hDlg);
diff --git a/src/WINNT/afssvrmgr/svr_prune.cpp b/src/WINNT/afssvrmgr/svr_prune.cpp
index ac39fc337..d645b1656 100644
--- a/src/WINNT/afssvrmgr/svr_prune.cpp
+++ b/src/WINNT/afssvrmgr/svr_prune.cpp
@@ -94,7 +94,7 @@ BOOL WINAPI Server_Prune_DlgProc (HWND hDlg, UINT msg, WPARAM wp, LPARAM lp)
                {
                case IDOK:
                   Server_Prune_OnOK (hDlg);
-                  // fall through
+                  AFS_FALLTHROUGH;
 
                case IDCANCEL:
                   DestroyWindow (hDlg);
diff --git a/src/afs/AIX/osi_config.c b/src/afs/AIX/osi_config.c
index 6cd306d1d..82fe53333 100644
--- a/src/afs/AIX/osi_config.c
+++ b/src/afs/AIX/osi_config.c
@@ -56,7 +56,7 @@
 #include <sys/timer.h>		/* For the timer related defines                */
 #include <sys/intr.h>		/* for the serialization defines                */
 #include <sys/malloc.h>		/* for the parameters to xmalloc()              */
-#include "afs/afs_osi.h"	/* pick up osi_timeval_t for afs_stats.h */
+#include "afs/afs_osi.h"	/* pick up osi_timeval32_t for afs_stats.h */
 #include "afs/afs_stats.h"
 #include "../export.h"
 
diff --git a/src/afs/AIX/osi_machdep.h b/src/afs/AIX/osi_machdep.h
index 1c285b85b..0c79c03c5 100644
--- a/src/afs/AIX/osi_machdep.h
+++ b/src/afs/AIX/osi_machdep.h
@@ -84,4 +84,13 @@ extern simple_lock_data afs_global_lock;
  * src/afs/AIX/osi_gcpags.c for how to look at the process list */
 #define osi_procname(procname, size) strncpy(procname, "", size)
 
+static_inline void
+osi_GetTime(osi_timeval32_t *atv)
+{
+    struct timestruc_t now;
+    curtime(&now);
+    atv->tv_sec = now.tv_sec;
+    atv->tv_usec = now.tv_nsec / 1000;
+}
+
 #endif /* _OSI_MACHDEP_H_ */
diff --git a/src/afs/AIX/osi_vfsops.c b/src/afs/AIX/osi_vfsops.c
index 526594442..71c1553ac 100644
--- a/src/afs/AIX/osi_vfsops.c
+++ b/src/afs/AIX/osi_vfsops.c
@@ -100,8 +100,7 @@ afs_unmount(struct vfs *afsp, int flag)
     AFS_STATCNT(afs_unmount);
 
     afs_globalVFS = 0;
-    afs_cold_shutdown = 1;
-    afs_shutdown();
+    afs_shutdown(AFS_COLD);
 
     AFS_VFSUNLOCK();
     return 0;
diff --git a/src/afs/DARWIN/osi_machdep.h b/src/afs/DARWIN/osi_machdep.h
index f7c53f273..e736c2c74 100644
--- a/src/afs/DARWIN/osi_machdep.h
+++ b/src/afs/DARWIN/osi_machdep.h
@@ -241,4 +241,13 @@ extern int (**afs_vnodeop_p) ();
 #define osi_procname(procname, size) strncpy(procname, curproc->p_comm, size)
 #endif
 
+static_inline void
+osi_GetTime(osi_timeval32_t *atv)
+{
+    struct timeval now;
+    microtime(&now);
+    atv->tv_sec = now.tv_sec;
+    atv->tv_usec = now.tv_usec;
+}
+
 #endif /* _OSI_MACHDEP_H_ */
diff --git a/src/afs/DARWIN/osi_vfsops.c b/src/afs/DARWIN/osi_vfsops.c
index b180882ee..d5b867179 100644
--- a/src/afs/DARWIN/osi_vfsops.c
+++ b/src/afs/DARWIN/osi_vfsops.c
@@ -196,7 +196,7 @@ afs_unmount(struct mount *mp, int flags, CTX_TYPE ctx)
 	        vflush(mp, NULLVP, FORCECLOSE/*0*/);
 		AFS_GLOCK();
 		afs_globalVFS = 0;
-		afs_shutdown();
+		afs_shutdown(AFS_WARM);
 	    } else {
 		AFS_GUNLOCK();
 		return EBUSY;
diff --git a/src/afs/DFBSD/osi_machdep.h b/src/afs/DFBSD/osi_machdep.h
new file mode 100644
index 000000000..4c6a80d4d
--- /dev/null
+++ b/src/afs/DFBSD/osi_machdep.h
@@ -0,0 +1,31 @@
+/*
+ * Copyright 2000, International Business Machines Corporation and others.
+ * All Rights Reserved.
+ *
+ * This software has been released under the terms of the IBM Public
+ * License.  For details, see the LICENSE file in the top-level source
+ * directory or online at http://www.openafs.org/dl/license10.html
+ */
+
+/*
+ *
+ * DFBSD OSI header file. Extends afs_osi.h.
+ *
+ * afs_osi.h includes this file, which is the only way this file should
+ * be included in a source file. This file can redefine macros declared in
+ * afs_osi.h.
+ */
+
+#ifndef _OSI_MACHDEP_H_
+#define _OSI_MACHDEP_H_
+
+static_inline void
+osi_GetTime(osi_timeval32_t *atv)
+{
+    struct timeval now;
+    microtime(&now);
+    atv->tv_sec = now.tv_sec;
+    atv->tv_usec = now.tv_usec;
+}
+
+#endif /* _OSI_MACHDEP_H_ */
diff --git a/src/afs/FBSD/osi_machdep.h b/src/afs/FBSD/osi_machdep.h
index 67544e196..d9d39f096 100644
--- a/src/afs/FBSD/osi_machdep.h
+++ b/src/afs/FBSD/osi_machdep.h
@@ -133,4 +133,13 @@ extern struct thread *afs_global_owner;
 
 #define osi_procname(procname, size) strncpy(procname, curproc->p_comm, size)
 
+static_inline void
+osi_GetTime(osi_timeval32_t *atv)
+{
+    struct timeval now;
+    microtime(&now);
+    atv->tv_sec = now.tv_sec;
+    atv->tv_usec = now.tv_usec;
+}
+
 #endif /* _OSI_MACHDEP_H_ */
diff --git a/src/afs/FBSD/osi_vfsops.c b/src/afs/FBSD/osi_vfsops.c
index d8b06b9b7..6044bbed1 100644
--- a/src/afs/FBSD/osi_vfsops.c
+++ b/src/afs/FBSD/osi_vfsops.c
@@ -184,7 +184,7 @@ afs_unmount(struct mount *mp, int flags)
     AFS_GLOCK();
     AFS_STATCNT(afs_unmount);
     afs_globalVFS = 0;
-    afs_shutdown();
+    afs_shutdown(AFS_WARM);
     AFS_GUNLOCK();
 
 out:
diff --git a/src/afs/FBSD/osi_vm.c b/src/afs/FBSD/osi_vm.c
index 780ae1280..d02c533f8 100644
--- a/src/afs/FBSD/osi_vm.c
+++ b/src/afs/FBSD/osi_vm.c
@@ -110,41 +110,30 @@ osi_VM_StoreAllSegments(struct vcache *avc)
 {
     struct vnode *vp;
     struct vm_object *obj;
-    int anyio, tries;
 
-    ReleaseWriteLock(&avc->lock);
-    AFS_GUNLOCK();
-    tries = 5;
     vp = AFSTOV(avc);
-
     /*
-     * I don't understand this.  Why not just call vm_object_page_clean()
-     * and be done with it?  I particularly don't understand why we're calling
-     * vget() here.  Is there some reason to believe that the vnode might
-     * be being recycled at this point?  I don't think there's any need for
-     * this loop, either -- if we keep the vnode locked all the time,
-     * that and the object lock will prevent any new pages from appearing.
-     * The loop is what causes the race condition.  -GAW
+     * VOP_ISLOCKED may return LK_EXCLOTHER here, since we may be running in a
+     * BOP_STORE background operation, and so we're running in a different
+     * thread than the actual syscall that has the vnode locked. So we cannot
+     * just call ASSERT_VOP_LOCKED (since that will fail if VOP_ISLOCKED
+     * returns LK_EXCLOTHER), and instead we just have our own assert here.
      */
-    do {
-	anyio = 0;
-	
-	obj = vp->v_object;
-	if (obj != NULL && obj->flags & OBJ_MIGHTBEDIRTY) {
-	    if (!vget(vp, LK_EXCLUSIVE | LK_RETRY, curthread)) {
-		    obj = vp->v_object;
-		    if (obj != NULL) {
-			AFS_VM_OBJECT_WLOCK(obj);
-			vm_object_page_clean(obj, 0, 0, OBJPC_SYNC);
-			AFS_VM_OBJECT_WUNLOCK(obj);
-			anyio = 1;
-		    }
-		    vput(vp);
-		}
-	    }
-    } while (anyio && (--tries > 0));
-    AFS_GLOCK();
-    ObtainWriteLock(&avc->lock, 94);
+    osi_Assert(VOP_ISLOCKED(vp) != 0);
+
+    obj = vp->v_object;
+
+    if (obj != NULL && (obj->flags & OBJ_MIGHTBEDIRTY) != 0) {
+	ReleaseWriteLock(&avc->lock);
+	AFS_GUNLOCK();
+
+	AFS_VM_OBJECT_WLOCK(obj);
+	vm_object_page_clean(obj, 0, 0, OBJPC_SYNC);
+	AFS_VM_OBJECT_WUNLOCK(obj);
+
+	AFS_GLOCK();
+	ObtainWriteLock(&avc->lock, 94);
+    }
 }
 
 /* Try to invalidate pages, for "fs flush" or "fs flushv"; or
diff --git a/src/afs/HPUX/osi_machdep.h b/src/afs/HPUX/osi_machdep.h
index bc90b81dc..f2afe21ce 100644
--- a/src/afs/HPUX/osi_machdep.h
+++ b/src/afs/HPUX/osi_machdep.h
@@ -121,4 +121,13 @@ extern caddr_t kmem_alloc();
 
 #define osi_procname(procname, size) strncpy(procname, "", size)
 
+static_inline void
+osi_GetTime(osi_timeval32_t *atv)
+{
+    struct timeval now;
+    uniqtime(&now);
+    atv->tv_sec = now.tv_sec;
+    atv->tv_usec = now.tv_usec;
+}
+
 #endif /* _OSI_MACHDEP_H_ */
diff --git a/src/afs/HPUX/osi_vfsops.c b/src/afs/HPUX/osi_vfsops.c
index df0ca593c..0ddc227c7 100644
--- a/src/afs/HPUX/osi_vfsops.c
+++ b/src/afs/HPUX/osi_vfsops.c
@@ -103,7 +103,7 @@ afs_unmount(struct vfs *afsp)
     AFS_STATCNT(afs_unmount);
 
     afs_globalVFS = 0;
-    afs_shutdown();
+    afs_shutdown(AFS_WARM);
 
     AFS_GUNLOCK();
     return 0;
diff --git a/src/afs/IRIX/osi_machdep.h b/src/afs/IRIX/osi_machdep.h
index 3c0f78d29..56defecf9 100644
--- a/src/afs/IRIX/osi_machdep.h
+++ b/src/afs/IRIX/osi_machdep.h
@@ -387,5 +387,18 @@ extern long afs_global_owner;
 
 #define osi_procname(procname, size) strncpy(procname, proc_name(curproc()), size)
 
+static_inline void
+osi_GetTime(osi_timeval32_t *atv)
+{
+#ifdef _K64U64
+    struct __irix5_timeval now;
+    irix5_microtime(&now);
+#else
+    struct timeval now;
+    microtime(&now);
+#endif
+    atv->tv_sec = now.tv_sec;
+    atv->tv_usec = now.tv_usec;
+}
 
 #endif /* _OSI_MACHDEP_H_ */
diff --git a/src/afs/IRIX/osi_vfsops.c b/src/afs/IRIX/osi_vfsops.c
index a7e838745..a03ac33bd 100644
--- a/src/afs/IRIX/osi_vfsops.c
+++ b/src/afs/IRIX/osi_vfsops.c
@@ -245,7 +245,7 @@ afs_unmount(OSI_VFS_ARG(afsp), flags, cr)
     }
     ReleaseWriteLock(&afs_xvcache);
     afs_globalVFS = 0;
-    afs_shutdown();
+    afs_shutdown(AFS_WARM);
 #ifdef AFS_SGI65_ENV
     VFS_REMOVEBHV(afsp, &afs_vfs_bhv);
 #endif
diff --git a/src/afs/LINUX/osi_compat.h b/src/afs/LINUX/osi_compat.h
index 726b6559c..53a079b67 100644
--- a/src/afs/LINUX/osi_compat.h
+++ b/src/afs/LINUX/osi_compat.h
@@ -27,6 +27,10 @@
 # endif
 #endif
 
+#if !defined(HAVE_LINUX_KTHREAD_COMPLETE_AND_EXIT)
+# define kthread_complete_and_exit complete_and_exit
+#endif
+
 #if defined(STRUCT_DENTRY_OPERATIONS_HAS_D_AUTOMOUNT) && !defined(DCACHE_NEED_AUTOMOUNT)
 # define DCACHE_NEED_AUTOMOUNT DMANAGED_AUTOMOUNT
 #endif
diff --git a/src/afs/LINUX/osi_export.c b/src/afs/LINUX/osi_export.c
index a3175b5d5..631500146 100644
--- a/src/afs/LINUX/osi_export.c
+++ b/src/afs/LINUX/osi_export.c
@@ -93,7 +93,7 @@ static int afs_encode_fh(struct dentry *de, __u32 *fh, int *max_len,
 		if (*max_len < 5) {
 		    return 255;
 		}
-		/* fall through */
+		AFS_FALLTHROUGH;
 
 	    case VN_TYPE_CELL:
 	    case VN_TYPE_ALIAS:
@@ -349,7 +349,7 @@ redo:
      */
     while ((adp->f.states & CStatd)
 	   && (tdc->dflags & DFFetching)
-	   && hsame(adp->f.m.DataVersion, tdc->f.versionNo)) {
+	   && afs_IsDCacheFresh(tdc, adp)) {
 	ReleaseReadLock(&tdc->lock);
 	ReleaseSharedLock(&adp->lock);
 	afs_osi_Sleep(&tdc->validPos);
@@ -357,7 +357,7 @@ redo:
 	ObtainReadLock(&tdc->lock);
     }
     if (!(adp->f.states & CStatd)
-	|| !hsame(adp->f.m.DataVersion, tdc->f.versionNo)) {
+	|| !afs_IsDCacheFresh(tdc, adp)) {
 	ReleaseReadLock(&tdc->lock);
 	ReleaseSharedLock(&adp->lock);
 	afs_PutDCache(tdc);
@@ -770,7 +770,7 @@ redo:
      */
     while ((vcp->f.states & CStatd)
 	   && (tdc->dflags & DFFetching)
-	   && hsame(vcp->f.m.DataVersion, tdc->f.versionNo)) {
+	   && afs_IsDCacheFresh(tdc, vcp)) {
 	ReleaseReadLock(&tdc->lock);
 	ReleaseReadLock(&vcp->lock);
 	afs_osi_Sleep(&tdc->validPos);
@@ -778,7 +778,7 @@ redo:
 	ObtainReadLock(&tdc->lock);
     }
     if (!(vcp->f.states & CStatd)
-	|| !hsame(vcp->f.m.DataVersion, tdc->f.versionNo)) {
+	|| !afs_IsDCacheFresh(tdc, vcp)) {
 	ReleaseReadLock(&tdc->lock);
 	ReleaseReadLock(&vcp->lock);
 	afs_PutDCache(tdc);
diff --git a/src/afs/LINUX/osi_file.c b/src/afs/LINUX/osi_file.c
index 03777f563..004799c4c 100644
--- a/src/afs/LINUX/osi_file.c
+++ b/src/afs/LINUX/osi_file.c
@@ -65,8 +65,12 @@ afs_linux_raw_open(afs_dcache_id_t *ainode)
 
     dp = afs_get_dentry_from_fh(afs_cacheSBp, ainode, cache_fh_len, cache_fh_type,
 		afs_fh_acceptable);
-    if ((!dp) || IS_ERR(dp))
-           osi_Panic("Can't get dentry\n");
+    if ((!dp) || IS_ERR(dp)) {
+	   afs_warn("afs: Cannot get dentry for cache file (code %d). Trying to continue, "
+		    "but AFS accesses may return errors or panic the system\n",
+		    (int) PTR_ERR(dp));
+	   return NULL;
+    }
     tip = dp->d_inode;
     tip->i_flags |= S_NOATIME;	/* Disable updating access times. */
 
@@ -115,8 +119,11 @@ osi_UFSOpen(afs_dcache_id_t *ainode)
     AFS_GUNLOCK();
     afile = kmalloc(sizeof(struct osi_file), GFP_NOFS);
     if (!afile) {
-	osi_Panic("osi_UFSOpen: Failed to allocate %d bytes for osi_file.\n",
-		  (int)sizeof(struct osi_file));
+	afs_warn("afs: Failed to allocate memory for opening a cache file. "
+		 "Trying to continue, but AFS access may return errors or panic "
+		 "the system\n");
+	AFS_GLOCK();
+	return NULL;
     }
     memset(afile, 0, sizeof(struct osi_file));
 
diff --git a/src/afs/LINUX/osi_groups.c b/src/afs/LINUX/osi_groups.c
index a52cc68b5..87d149f56 100644
--- a/src/afs/LINUX/osi_groups.c
+++ b/src/afs/LINUX/osi_groups.c
@@ -340,7 +340,7 @@ afs_xsetgroups32(int gidsetsize, gid_t * grouplist)
     return (-code);
 }
 
-# if defined(AFS_PPC64_LINUX20_ENV)
+# if defined(AFS_PPC64_LINUX_ENV)
 /* Intercept the uid16 system call as used by 32bit programs. */
 extern asmlinkage long (*sys32_setgroupsp)(int gidsetsize, gid_t *grouplist);
 asmlinkage long afs32_xsetgroups(int gidsetsize, gid_t *grouplist)
@@ -370,15 +370,15 @@ asmlinkage long afs32_xsetgroups(int gidsetsize, gid_t *grouplist)
 }
 # endif
 
-# if defined(AFS_SPARC64_LINUX20_ENV) || defined(AFS_AMD64_LINUX20_ENV)
+# if defined(AFS_SPARC64_LINUX_ENV) || defined(AFS_AMD64_LINUX_ENV)
 /* Intercept the uid16 system call as used by 32bit programs. */
-#  ifdef AFS_AMD64_LINUX20_ENV
+#  ifdef AFS_AMD64_LINUX_ENV
 extern asmlinkage long (*sys32_setgroupsp) (int gidsetsize, u16 * grouplist);
-#  endif /* AFS_AMD64_LINUX20_ENV */
-#  ifdef AFS_SPARC64_LINUX26_ENV
+#  endif /* AFS_AMD64_LINUX_ENV */
+#  ifdef AFS_SPARC64_LINUX_ENV
 extern asmlinkage int (*sys32_setgroupsp) (int gidsetsize,
 					   __kernel_gid32_t * grouplist);
-#  endif /* AFS_SPARC64_LINUX26_ENV */
+#  endif /* AFS_SPARC64_LINUX_ENV */
 asmlinkage long
 afs32_xsetgroups(int gidsetsize, u16 * grouplist)
 {
@@ -407,13 +407,13 @@ afs32_xsetgroups(int gidsetsize, u16 * grouplist)
 }
 
 /* Intercept the uid32 system call as used by 32bit programs. */
-#  ifdef AFS_AMD64_LINUX20_ENV
+#  ifdef AFS_AMD64_LINUX_ENV
 extern asmlinkage long (*sys32_setgroups32p) (int gidsetsize, gid_t * grouplist);
-#  endif /* AFS_AMD64_LINUX20_ENV */
-#  ifdef AFS_SPARC64_LINUX26_ENV
+#  endif /* AFS_AMD64_LINUX_ENV */
+#  ifdef AFS_SPARC64_LINUX_ENV
 extern asmlinkage int (*sys32_setgroups32p) (int gidsetsize,
 					     __kernel_gid32_t * grouplist);
-#  endif /* AFS_SPARC64_LINUX26_ENV */
+#  endif /* AFS_SPARC64_LINUX_ENV */
 asmlinkage long
 afs32_xsetgroups32(int gidsetsize, gid_t * grouplist)
 {
diff --git a/src/afs/LINUX/osi_ioctl.c b/src/afs/LINUX/osi_ioctl.c
index 7d355674d..327520c02 100644
--- a/src/afs/LINUX/osi_ioctl.c
+++ b/src/afs/LINUX/osi_ioctl.c
@@ -21,7 +21,7 @@
 #include <linux/unistd.h>		/* For syscall numbers. */
 #include <linux/mm.h>
 
-#ifdef AFS_AMD64_LINUX20_ENV
+#ifdef AFS_AMD64_LINUX_ENV
 #include <asm/ia32_unistd.h>
 #endif
 
diff --git a/src/afs/LINUX/osi_machdep.h b/src/afs/LINUX/osi_machdep.h
index f1828c99b..34940c60d 100644
--- a/src/afs/LINUX/osi_machdep.h
+++ b/src/afs/LINUX/osi_machdep.h
@@ -99,23 +99,23 @@ static inline time_t osi_Time(void) {
 #endif
 
 #if defined(HAVE_LINUX_KTIME_GET_REAL_TS64)
-# define osi_GetTime(V)                                      \
-    do {                                                     \
-	struct timespec64 __afs_tv;                          \
-	ktime_get_real_ts64(&__afs_tv);                      \
-	(V)->tv_sec = (afs_int32)__afs_tv.tv_sec;            \
-	(V)->tv_usec = (afs_int32)__afs_tv.tv_nsec / 1000;   \
-    } while(0)
-#elif defined(AFS_LINUX_64BIT_KERNEL) || !defined(HAVE_LINUX_TIME_T)
-# define osi_GetTime(V)                                 \
-    do {                                               \
-       struct timeval __afs_tv;                              \
-       do_gettimeofday(&__afs_tv);                           \
-       (V)->tv_sec = (afs_int32)__afs_tv.tv_sec;             \
-       (V)->tv_usec = (afs_int32)__afs_tv.tv_usec;           \
-    } while (0)
+static inline void
+osi_GetTime(osi_timeval32_t *atv)
+{
+    struct timespec64 now;
+    ktime_get_real_ts64(&now);
+    atv->tv_sec = now.tv_sec;
+    atv->tv_usec = now.tv_nsec / 1000;
+}
 #else
-# define osi_GetTime(V) do_gettimeofday((V))
+static inline void
+osi_GetTime(osi_timeval32_t *atv)
+{
+    struct timeval now;
+    do_gettimeofday(&now);
+    atv->tv_sec = now.tv_sec;
+    atv->tv_usec = now.tv_usec;
+}
 #endif
 
 #undef gop_lookupname
@@ -162,35 +162,25 @@ static inline long copyinstr(char *from, char *to, int count, int *length) {
  * Test to see for 64/32bit compatibility mode
  * Return non-zero if in a 64bit kernel and handing a 32bit syscall
  */
-#if defined(AFS_LINUX_64BIT_KERNEL) && !defined(AFS_ALPHA_LINUX20_ENV) && !defined(AFS_IA64_LINUX20_ENV)
+#if defined(AFS_LINUX_64BIT_KERNEL) && !defined(AFS_ALPHA_LINUX_ENV) && !defined(AFS_IA64_LINUX_ENV)
 static inline int
 afs_in_compat_syscall(void)
 {
 # if defined(HAVE_LINUX_IN_COMPAT_SYSCALL)
     return in_compat_syscall();
-# elif defined(AFS_SPARC64_LINUX26_ENV)
+# elif defined(AFS_SPARC64_LINUX_ENV)
     return test_thread_flag(TIF_32BIT);
-# elif defined(AFS_SPARC64_LINUX24_ENV)
-    return (current->thread.flags & SPARC_FLAG_32BIT) != 0;
-# elif defined(AFS_SPARC64_LINUX20_ENV)
-    return (current->tss.flags & SPARC_FLAG_32BIT) != 0;
-# elif defined(AFS_AMD64_LINUX26_ENV)
+# elif defined(AFS_AMD64_LINUX_ENV)
     return test_thread_flag(TIF_IA32);
-# elif defined(AFS_AMD64_LINUX20_ENV)
-    return (current->thread.flags & THREAD_IA32) != 0;
-# elif defined(AFS_PPC64_LINUX26_ENV)
+# elif defined(AFS_PPC64_LINUX_ENV)
 #  if defined(STRUCT_TASK_STRUCT_HAS_THREAD_INFO)
     return (current->thread_info->flags & _TIF_32BIT) != 0;
 #  else
     return (task_thread_info(current)->flags & _TIF_32BIT) != 0;
 #  endif
-# elif defined(AFS_PPC64_LINUX20_ENV)
-   return (current->thread.flags & PPC_FLAG_32BIT) != 0;
-# elif defined(AFS_S390X_LINUX26_ENV)
+# elif defined(AFS_S390X_LINUX_ENV)
    return test_thread_flag(TIF_31BIT);
-# elif defined(AFS_S390X_LINUX20_ENV)
-  return (current->thread.flags & S390_FLAG_31BIT) != 0;
-# elif defined(AFS_ARM64_LINUX26_ENV)
+# elif defined(AFS_ARM64_LINUX_ENV)
   return is_compat_task();
 # else
 #  error afs_in_compat_syscall not done for this linux
@@ -364,7 +354,7 @@ struct uio {
 
 #define OSIFILE_INODE(a) FILE_INODE((a)->filp)
 
-#if defined(AFS_LINUX_64BIT_KERNEL) && !defined(AFS_ALPHA_LINUX20_ENV) && !defined(AFS_IA64_LINUX20_ENV)
+#if defined(AFS_LINUX_64BIT_KERNEL) && !defined(AFS_ALPHA_LINUX_ENV) && !defined(AFS_IA64_LINUX_ENV)
 # define NEED_IOCTL32
 #endif
 
@@ -402,7 +392,7 @@ do { \
 
 #define osi_InitGlock()
 
-#ifdef AFS_AMD64_LINUX20_ENV
+#ifdef AFS_AMD64_LINUX_ENV
 /* RHEL5 beta's kernel doesn't define these. They aren't gonna change, so... */
 
 # ifndef __NR_ia32_afs_syscall
diff --git a/src/afs/LINUX/osi_module.c b/src/afs/LINUX/osi_module.c
index 47e32cf1b..79ba57c4d 100644
--- a/src/afs/LINUX/osi_module.c
+++ b/src/afs/LINUX/osi_module.c
@@ -21,7 +21,7 @@
 #include <linux/unistd.h>		/* For syscall numbers. */
 #include <linux/mm.h>
 
-#ifdef AFS_AMD64_LINUX20_ENV
+#ifdef AFS_AMD64_LINUX_ENV
 #include <asm/ia32_unistd.h>
 #endif
 
diff --git a/src/afs/LINUX/osi_pag_module.c b/src/afs/LINUX/osi_pag_module.c
index ac4f800c2..e832c5abd 100644
--- a/src/afs/LINUX/osi_pag_module.c
+++ b/src/afs/LINUX/osi_pag_module.c
@@ -20,7 +20,7 @@
 #include <linux/unistd.h>		/* For syscall numbers. */
 #include <linux/mm.h>
 
-#ifdef AFS_AMD64_LINUX20_ENV
+#ifdef AFS_AMD64_LINUX_ENV
 #include <asm/ia32_unistd.h>
 #endif
 
diff --git a/src/afs/LINUX/osi_probe.c b/src/afs/LINUX/osi_probe.c
index fc8153c97..87c506f87 100644
--- a/src/afs/LINUX/osi_probe.c
+++ b/src/afs/LINUX/osi_probe.c
@@ -74,11 +74,11 @@
 #include <linux/unistd.h>
 #include <linux/mm.h>
 
-#if defined(AFS_PPC64_LINUX26_ENV)
+#if defined(AFS_PPC64_LINUX_ENV)
 # include <asm/abs_addr.h>
 #endif
 
-#ifdef AFS_AMD64_LINUX20_ENV
+#ifdef AFS_AMD64_LINUX_ENV
 # include <asm/ia32_unistd.h>
 #endif
 
@@ -89,9 +89,9 @@
 #endif
 
 /* lower bound of valid kernel text pointers */
-#ifdef AFS_IA64_LINUX20_ENV
+#ifdef AFS_IA64_LINUX_ENV
 #define ktxt_lower_bound (((unsigned long)&kernel_thread )  & 0xfff00000L)
-#elif defined(AFS_PPC64_LINUX20_ENV)
+#elif defined(AFS_PPC64_LINUX_ENV)
 #define ktxt_lower_bound (KERNELBASE)
 #else
 #define ktxt_lower_bound (((unsigned long)&kernel_thread )  & ~0xfffffL)
@@ -100,7 +100,7 @@
 /* On SPARC64 and S390X, sys_call_table contains 32-bit entries
  * even though pointers are 64 bit quantities.
  */
-#if defined(AFS_SPARC64_LINUX20_ENV) || defined(AFS_S390X_LINUX24_ENV)
+#if defined(AFS_SPARC64_LINUX_ENV) || defined(AFS_S390X_LINUX_ENV)
 #define SYSCALLTYPE unsigned int
 #define PROBETYPE int
 #else
@@ -108,7 +108,7 @@
 #define PROBETYPE long
 #endif
 
-#if defined(AFS_S390X_LINUX20_ENV) && !defined(AFS_S390X_LINUX26_ENV) 
+#if defined(AFS_S390X_LINUX_ENV) && !defined(AFS_S390X_LINUX_ENV) 
 #define _SS(x) ((x) << 1)
 #define _SX(x) ((x) &~ 1)
 #else
@@ -299,7 +299,7 @@ typedef struct {
     int debug_ignore_NR[4];         /* syscalls to ignore for debugging */
 } probectl;
 
-#if defined(AFS_I386_LINUX26_ENV) || defined(AFS_AMD64_LINUX26_ENV)
+#if defined(AFS_I386_LINUX_ENV) || defined(AFS_AMD64_LINUX_ENV)
 static int check_access(unsigned long, int);
 static int check_table_readable(probectl *, PROBETYPE *);
 #endif
@@ -310,13 +310,13 @@ static int check_table_readable(probectl *, PROBETYPE *);
 /* syscall pairs/triplets to probe */
 /* On PPC64 and SPARC64, we need to omit the ones that might match both tables */
 static tryctl main_try[] = {
-#if !defined(AFS_PPC64_LINUX20_ENV) && !defined(AFS_SPARC64_LINUX20_ENV)
+#if !defined(AFS_PPC64_LINUX_ENV) && !defined(AFS_SPARC64_LINUX_ENV)
 #if defined(EXPORTED_SYS_CHDIR)
     { "scan: close+chdir+write", __NR_close, &sys_close, __NR_chdir, &sys_chdir, __NR_write, &sys_write },
 #endif
 #endif
     { "scan: close+wait4",       __NR_close, &sys_close, __NR_wait4, &sys_wait4, -1,         0          },
-#if !defined(AFS_PPC64_LINUX20_ENV) && !defined(AFS_SPARC64_LINUX20_ENV)
+#if !defined(AFS_PPC64_LINUX_ENV) && !defined(AFS_SPARC64_LINUX_ENV)
 #if defined(EXPORTED_SYS_CHDIR)
     { "scan: close+chdir",       __NR_close, &sys_close, __NR_chdir, &sys_chdir, -1,         0          },
 #endif
@@ -346,13 +346,13 @@ static int main_zapped_syscalls[] = {
  * other entries, or we might get a sys_ni_syscall into the list and
  * the test would no longer work.
  */
-#if defined(AFS_SPARC64_LINUX20_ENV)
+#if defined(AFS_SPARC64_LINUX_ENV)
     /* mmap2, fstat64, getmsg, putmsg, modify_ldt */
     56, 63, 151, 152, 218,
-#elif defined(AFS_SPARC_LINUX20_ENV)
+#elif defined(AFS_SPARC_LINUX_ENV)
     /* memory_ordering, getmsg, putmsg, unimplemented, modify_ldt */
     52, 151, 152, 164, 218,
-#else /* !AFS_SPARC_LINUX20_ENV */
+#else /* !AFS_SPARC_LINUX_ENV */
 
 /* 
  * These 7 syscalls are present in the syscall table on most "older"
@@ -386,7 +386,7 @@ static int main_zapped_syscalls[] = {
  * corresponding __NR macros are not defined, so the tests above fail.
  * Instead, we just have to know the numbers for these.
  */
-#if defined(AFS_S390_LINUX20_ENV) || defined(AFS_S390X_LINUX20_ENV)
+#if defined(AFS_S390_LINUX_ENV) || defined(AFS_S390X_LINUX_ENV)
     /* break, stty, gtty, ftime, prof, lock, mpx */
     17, 31, 32, 35, 44, 53, 56,
 #endif
@@ -422,7 +422,7 @@ static int main_zapped_syscalls[] = {
  * unimplemented, but the __NR macros are not defined.  Again,
  * we simply have to know their numbers.
  */
-#ifdef AFS_IA64_LINUX26_ENV
+#ifdef AFS_IA64_LINUX_ENV
     /* create_module, query_module, get_kernel_sysms */
     1132, 1136, 1135,
 #endif
@@ -456,23 +456,23 @@ static int main_zapped_syscalls[] = {
  * unimplemented calls are very similar.
  * mmap2 and fstat64 are implemented only for 32-bit calls
  */
-#ifdef AFS_PPC64_LINUX20_ENV
+#ifdef AFS_PPC64_LINUX_ENV
     /* _mmap2, _fstat64 */
     192, 197,
-#endif /* AFS_PPC64_LINUX20_ENV */
+#endif /* AFS_PPC64_LINUX_ENV */
 
 /* Similarly for S390X, with lcown16 and fstat64 */
-#ifdef AFS_S390X_LINUX20_ENV
+#ifdef AFS_S390X_LINUX_ENV
     /* lchown16, fstat64 */
     16, 197,
 #endif
-#endif /* !AFS_SPARC_LINUX20_ENV */
+#endif /* !AFS_SPARC_LINUX_ENV */
     0
 };
 
 /* unique syscalls for try_harder */
 static int main_unique_syscalls[] = {
-#if defined(AFS_SPARC64_LINUX24_ENV) || defined(AFS_SPARC_LINUX24_ENV)
+#if defined(AFS_SPARC64_LINUX_ENV) || defined(AFS_SPARC_LINUX_ENV)
     /* 
      * On SPARC, we need some additional unique calls to make sure
      * we don't match the SunOS-compatibility table.
@@ -490,7 +490,7 @@ static probectl main_probe = {
     "system call table",
 
     /* syscall number of first entry in table */
-#ifdef AFS_IA64_LINUX20_ENV
+#ifdef AFS_IA64_LINUX_ENV
     1024,
 #else
     0,
@@ -507,9 +507,9 @@ static probectl main_probe = {
     main_try,                     /* array of combinations to try */
 
     /* symbol in section to try scanning */
-#if defined(AFS_SPARC64_LINUX20_ENV) || defined(AFS_S390_LINUX20_ENV) || defined(AFS_S390X_LINUX20_ENV)
+#if defined(AFS_SPARC64_LINUX_ENV) || defined(AFS_S390_LINUX_ENV) || defined(AFS_S390X_LINUX_ENV)
     (unsigned long)&sys_close,
-#elif defined(AFS_AMD64_LINUX26_ENV)
+#elif defined(AFS_AMD64_LINUX_ENV)
     /* On this platform, it's in a different section! */
     (unsigned long)&generic_ro_fops,
 #else
@@ -519,24 +519,24 @@ static probectl main_probe = {
     /* default base address for scan */
     /* base address bits to force to zero */
     /* default length for scan */
-#if   defined(AFS_SPARC64_LINUX20_ENV)
+#if   defined(AFS_SPARC64_LINUX_ENV)
     (unsigned long)(&sys_close),
     0xfffff,
     0x10000,
-#elif   defined(AFS_S390_LINUX20_ENV) || defined(AFS_S390X_LINUX20_ENV)
+#elif   defined(AFS_S390_LINUX_ENV) || defined(AFS_S390X_LINUX_ENV)
     /* bleah; this is so suboptimal */
     (unsigned long)(&sys_close),
     0xfffff,
     0x20000,
-#elif   defined(AFS_IA64_LINUX20_ENV)
+#elif   defined(AFS_IA64_LINUX_ENV)
     (unsigned long)(&init_mm),
     0x1fffff,
     0x30000,
-#elif defined(AFS_AMD64_LINUX26_ENV)
+#elif defined(AFS_AMD64_LINUX_ENV)
     (unsigned long)(&generic_ro_fops) - 0x30000,
     0,
     0x6000,
-#elif defined(AFS_PPC64_LINUX26_ENV)
+#elif defined(AFS_PPC64_LINUX_ENV)
     (unsigned long)(&do_signal),
     0xfff,
     0x400,
@@ -564,13 +564,13 @@ static probectl main_probe = {
 
     /* syscalls to ignore for debugging */
     {
-#if   defined(AFS_ALPHA_LINUX20_ENV)
+#if   defined(AFS_ALPHA_LINUX_ENV)
 	338,
-#elif defined(AFS_AMD64_LINUX20_ENV)
+#elif defined(AFS_AMD64_LINUX_ENV)
 	183,
-#elif defined(AFS_IA64_LINUX20_ENV)
+#elif defined(AFS_IA64_LINUX_ENV)
 	1141,
-#elif defined(AFS_SPARC_LINUX20_ENV) || defined(AFS_SPARC64_LINUX20_ENV)
+#elif defined(AFS_SPARC_LINUX_ENV) || defined(AFS_SPARC64_LINUX_ENV)
 	227,
 #else
 	137,
@@ -587,7 +587,7 @@ static probectl main_probe = {
 
 
 /********** Probing Configuration: amd64 ia32_sys_call_table **********/
-#if defined(AFS_AMD64_LINUX20_ENV)
+#if defined(AFS_AMD64_LINUX_ENV)
 
 /* syscall pairs/triplets to probe */
 static tryctl ia32_try[] = {
@@ -672,7 +672,7 @@ static probectl *probe_list[] = {
 
 
 /********** Probing Configuration: IA64 **********/
-#elif defined(AFS_IA64_LINUX20_ENV)
+#elif defined(AFS_IA64_LINUX_ENV)
 struct fptr {
     void *ip;
     unsigned long gp;
@@ -685,7 +685,7 @@ static probectl *probe_list[] = {
 
 
 /********** Probing Configuration: ppc64, sparc64 sys_call_table32 **********/
-#elif defined(AFS_PPC64_LINUX20_ENV) || defined(AFS_SPARC64_LINUX20_ENV)
+#elif defined(AFS_PPC64_LINUX_ENV) || defined(AFS_SPARC64_LINUX_ENV)
 struct fptr {
     void *ip;
     unsigned long gp;
@@ -702,12 +702,12 @@ static tryctl sct32_try[] = {
 
 /* zapped syscalls for try_harder */
 static int sct32_zapped_syscalls[] = {
-#ifdef AFS_PPC64_LINUX20_ENV
+#ifdef AFS_PPC64_LINUX_ENV
     /* These should be sufficient */
     __NR_break, __NR_stty, __NR_gtty, __NR_ftime,
     __NR_prof, __NR_lock, __NR_mpx,
 #endif
-#ifdef AFS_SPARC64_LINUX20_ENV
+#ifdef AFS_SPARC64_LINUX_ENV
     /* memory_ordering, getmsg, putmsg, unimplemented, modify_ldt */
     52, 151, 152, 164, 218,
 #endif
@@ -717,11 +717,11 @@ static int sct32_zapped_syscalls[] = {
 /* unique syscalls for try_harder */
 /* mmap2 and fstat64 are implemented only for 32-bit calls */
 static int sct32_unique_syscalls[] = {
-#ifdef AFS_PPC64_LINUX20_ENV
+#ifdef AFS_PPC64_LINUX_ENV
     /* _mmap2, _fstat64 */
     192, 197,
 #endif
-#ifdef AFS_SPARC64_LINUX24_ENV
+#ifdef AFS_SPARC64_LINUX_ENV
     /* 
      * On SPARC, we need some additional unique calls to make sure
      * we don't match the SunOS-compatibility table.
@@ -752,7 +752,7 @@ static probectl sct32_probe = {
     sct32_try,                   /* array of combinations to try */
 
     /* symbol in section to try scanning */
-#if defined(AFS_SPARC64_LINUX20_ENV)
+#if defined(AFS_SPARC64_LINUX_ENV)
     (unsigned long)&sys_close,
 #else
     (unsigned long)&init_mm,
@@ -761,11 +761,11 @@ static probectl sct32_probe = {
     /* default base address for scan */
     /* base address bits to force to zero */
     /* default length for scan */
-#if   defined(AFS_SPARC64_LINUX20_ENV)
+#if   defined(AFS_SPARC64_LINUX_ENV)
     (unsigned long)(&sys_close),
     0xfffff,
     0x10000,
-#elif defined(AFS_PPC64_LINUX26_ENV)
+#elif defined(AFS_PPC64_LINUX_ENV)
     (unsigned long)(&do_signal),
     0xfff,
     0x400,
@@ -793,7 +793,7 @@ static probectl sct32_probe = {
 
     /* syscalls to ignore for debugging */
     {
-#if defined(AFS_SPARC64_LINUX20_ENV)
+#if defined(AFS_SPARC64_LINUX_ENV)
 	227,
 #else
 	137,
@@ -814,7 +814,7 @@ static probectl *probe_list[] = {
  * On earlier versions, the two tables were interleaved and so
  * have related base addresses.
  */
-#elif defined(AFS_S390X_LINUX26_ENV)
+#elif defined(AFS_S390X_LINUX_ENV)
 
 /* syscall pairs/triplets to probe */
 /* nothing worthwhile is exported, so this is empty */
@@ -917,7 +917,7 @@ static int check_table(probectl *P, PROBETYPE *ptr)
     PROBETYPE *x;
     int i, j;
 
-#if defined(AFS_I386_LINUX26_ENV) || defined(AFS_AMD64_LINUX26_ENV)
+#if defined(AFS_I386_LINUX_ENV) || defined(AFS_AMD64_LINUX_ENV)
     i = check_table_readable(P, ptr);
     if (i >= 0) return i;
 #endif
@@ -964,7 +964,7 @@ static void *try(probectl *P, tryctl *T, PROBETYPE *aptr,
     int ret;
     PROBETYPE *ptr;
 
-#if defined(AFS_IA64_LINUX20_ENV) || defined(AFS_PPC64_LINUX20_ENV)
+#if defined(AFS_IA64_LINUX_ENV) || defined(AFS_PPC64_LINUX_ENV)
     ip1 = T->fn1 ? (unsigned long)((struct fptr *)T->fn1)->ip : 0;
     ip2 = T->fn2 ? (unsigned long)((struct fptr *)T->fn2)->ip : 0;
     ip3 = T->fn3 ? (unsigned long)((struct fptr *)T->fn3)->ip : 0;
@@ -984,7 +984,7 @@ static void *try(probectl *P, tryctl *T, PROBETYPE *aptr,
 	return 0;
 
     for (offset = 0; offset < datalen; offset++, aptr++) {
-#if defined(AFS_PPC64_LINUX20_ENV)
+#if defined(AFS_PPC64_LINUX_ENV)
 	ptr = (PROBETYPE*)(*aptr);
 	if ((unsigned long)ptr <= KERNELBASE) {
 		continue;
@@ -993,7 +993,7 @@ static void *try(probectl *P, tryctl *T, PROBETYPE *aptr,
 	ptr = aptr;
 #endif
 	if ((unsigned long)ptr < init_mm.start_code ||
-#if defined(AFS_AMD64_LINUX20_ENV)
+#if defined(AFS_AMD64_LINUX_ENV)
 		(unsigned long)ptr > init_mm.brk)
 #else
 		(unsigned long)ptr > init_mm.end_data)
@@ -1044,7 +1044,7 @@ static int check_harder(probectl *P, PROBETYPE *p)
     unsigned long ip1;
     int i, s;
 
-#if defined(AFS_I386_LINUX26_ENV) || defined(AFS_AMD64_LINUX26_ENV)
+#if defined(AFS_I386_LINUX_ENV) || defined(AFS_AMD64_LINUX_ENV)
     i = check_table_readable(P, p);
     if (i >= 0) return 0;
 #endif
@@ -1074,7 +1074,7 @@ static int check_harder(probectl *P, PROBETYPE *p)
 	}
     }
 
-#if defined(AFS_IA64_LINUX20_ENV) || defined(AFS_PPC64_LINUX20_ENV)
+#if defined(AFS_IA64_LINUX_ENV) || defined(AFS_PPC64_LINUX_ENV)
     ip1 = P->verify_fn ? (unsigned long)((struct fptr *)(P->verify_fn))->ip : 0;
 #else
     ip1 = (unsigned long)(P->verify_fn);
@@ -1113,7 +1113,7 @@ static void *try_harder(probectl *P, PROBETYPE *ptr, unsigned long datalen)
 #endif
     for (offset = 0; offset < datalen; offset++, ptr++) {
 	 if ((unsigned long)ptr < init_mm.start_code ||
-#if defined(AFS_AMD64_LINUX20_ENV)
+#if defined(AFS_AMD64_LINUX_ENV)
 		(unsigned long)ptr > init_mm.brk)
 #else
 		(unsigned long)ptr > init_mm.end_data)
@@ -1190,7 +1190,7 @@ static void *scan_for_syscall_table(probectl *P, PROBETYPE *B, unsigned long L)
 {
     tryctl *T;
     void *answer;
-#if defined(AFS_S390_LINUX20_ENV) || defined(AFS_S390X_LINUX20_ENV)
+#if defined(AFS_S390_LINUX_ENV) || defined(AFS_S390X_LINUX_ENV)
     void *answer2;
 #endif
 #ifdef OSI_PROBE_DEBUG
@@ -1210,7 +1210,7 @@ static void *scan_for_syscall_table(probectl *P, PROBETYPE *B, unsigned long L)
 
     for (T = P->trylist; T->name; T++) {
 	answer = try(P, T, B, L);
-#if defined(AFS_S390_LINUX20_ENV) || defined(AFS_S390X_LINUX20_ENV)
+#if defined(AFS_S390_LINUX_ENV) || defined(AFS_S390X_LINUX_ENV)
 	answer2 = try(P, T, (PROBETYPE *)(2 + (void *)B), L);
 #ifdef OSI_PROBE_DEBUG
 	if (probe_debug & 0x0003) {
@@ -1230,7 +1230,7 @@ static void *scan_for_syscall_table(probectl *P, PROBETYPE *B, unsigned long L)
     /* XXX more checks here */
 
     answer = try_harder(P, B, L);
-#if defined(AFS_S390_LINUX20_ENV) || defined(AFS_S390X_LINUX20_ENV)
+#if defined(AFS_S390_LINUX_ENV) || defined(AFS_S390X_LINUX_ENV)
     answer2 = try_harder(P, (PROBETYPE *)(2 + (void *)B), L);
 #ifdef OSI_PROBE_DEBUG
     if (probe_debug & 0x0005) {
@@ -1335,7 +1335,7 @@ static void *do_find_syscall_table(probectl *P, char **method)
 #endif
 }
 
-#if defined(AFS_I386_LINUX26_ENV) || defined(AFS_AMD64_LINUX26_ENV)
+#if defined(AFS_I386_LINUX_ENV) || defined(AFS_AMD64_LINUX_ENV)
 static int check_access(unsigned long address, int mode) 
 { 
     pgd_t *pgd = pgd_offset_k(address);
@@ -1415,7 +1415,7 @@ void *osi_find_syscall_table(int which)
 	return 0;
     }
     printk("Found %s at 0x%lx (%s)\n", P->desc, (unsigned long)answer, method);
-#if defined(AFS_I386_LINUX26_ENV) || defined(AFS_AMD64_LINUX26_ENV)
+#if defined(AFS_I386_LINUX_ENV) || defined(AFS_AMD64_LINUX_ENV)
     if (!check_access((unsigned long)answer, 1)) {
 	printk("Address 0x%lx is not writable.\n", (unsigned long)answer);
 	printk("System call hooks will not be installed; proceeding anyway\n");
diff --git a/src/afs/LINUX/osi_proc.c b/src/afs/LINUX/osi_proc.c
index 4ac51d3f4..9c5a080f0 100644
--- a/src/afs/LINUX/osi_proc.c
+++ b/src/afs/LINUX/osi_proc.c
@@ -25,7 +25,7 @@
 #include <linux/unistd.h>		/* For syscall numbers. */
 #include <linux/mm.h>
 
-#ifdef AFS_AMD64_LINUX20_ENV
+#ifdef AFS_AMD64_LINUX_ENV
 # include <asm/ia32_unistd.h>
 #endif
 
diff --git a/src/afs/LINUX/osi_syscall.c b/src/afs/LINUX/osi_syscall.c
index 921a7a8de..836491c29 100644
--- a/src/afs/LINUX/osi_syscall.c
+++ b/src/afs/LINUX/osi_syscall.c
@@ -37,7 +37,7 @@ osi_syscall_clean(void)
 #include <linux/unistd.h>		/* For syscall numbers. */
 #include <linux/mm.h>
 
-#ifdef AFS_AMD64_LINUX20_ENV
+#ifdef AFS_AMD64_LINUX_ENV
 #include <asm/ia32_unistd.h>
 #endif
 
@@ -54,7 +54,7 @@ osi_syscall_clean(void)
  * even though pointers are 64 bit quantities.
  * XXX unify this with osi_probe.c
  */
-#if defined(AFS_SPARC64_LINUX20_ENV) || defined(AFS_S390X_LINUX24_ENV)
+#if defined(AFS_SPARC64_LINUX_ENV) || defined(AFS_S390X_LINUX_ENV)
 #define SYSCALLTYPE unsigned int
 #define POINTER2SYSCALL (unsigned int)(unsigned long)
 #define SYSCALL2POINTER (void *)(long)
@@ -64,7 +64,7 @@ osi_syscall_clean(void)
 #define SYSCALL2POINTER (void *)
 #endif
 
-#if defined(AFS_S390X_LINUX24_ENV) 
+#if defined(AFS_S390X_LINUX_ENV) 
 #define INSERT_SYSCALL(SLOT, TMPPAGE, FUNC) \
 	if (SYSCALL2POINTER FUNC > 0x7fffffff) { \
 	    TMPPAGE = kmalloc ( PAGE_SIZE, GFP_DMA|GFP_KERNEL );	\
@@ -82,7 +82,7 @@ osi_syscall_clean(void)
     afs_sys_call_table[_S(SLOT)] = POINTER2SYSCALL FUNC;
 #endif 
 
-#if defined(AFS_IA64_LINUX20_ENV)
+#if defined(AFS_IA64_LINUX_ENV)
 #define _S(x) ((x)-1024)
 #else
 #define _S(x) x
@@ -96,7 +96,7 @@ afs_syscall(long syscall, long parm1, long parm2, long parm3, long parm4);
 static SYSCALLTYPE *afs_sys_call_table;
 static SYSCALLTYPE afs_ni_syscall = 0;
 
-#ifdef AFS_S390X_LINUX24_ENV
+#ifdef AFS_S390X_LINUX_ENV
 static void *afs_sys_setgroups_page = 0;
 #if defined(__NR_setgroups32)
 static void *afs_sys_setgroups32_page = 0;
@@ -123,7 +123,7 @@ asmlinkage int (*sys_setgroups32p) (int gidsetsize,
 				    __kernel_gid32_t * grouplist);
 
 /***** AMD64 *****/
-#ifdef AFS_AMD64_LINUX20_ENV
+#ifdef AFS_AMD64_LINUX_ENV
 static SYSCALLTYPE *afs_ia32_sys_call_table;
 static SYSCALLTYPE ia32_ni_syscall = 0;
 
@@ -131,11 +131,11 @@ extern asmlinkage long afs32_xsetgroups(int gidsetsize, u16 * grouplist);
 asmlinkage long (*sys32_setgroupsp) (int gidsetsize, u16 * grouplist);
 extern asmlinkage long afs32_xsetgroups32(int gidsetsize, gid_t * grouplist);
 asmlinkage long (*sys32_setgroups32p) (int gidsetsize, gid_t * grouplist);
-#endif /* AFS_AMD64_LINUX20_ENV */
+#endif /* AFS_AMD64_LINUX_ENV */
 
 
 /***** PPC64 *****/
-#ifdef AFS_PPC64_LINUX26_ENV
+#ifdef AFS_PPC64_LINUX_ENV
 static SYSCALLTYPE *afs_sys_call_table32;
 static SYSCALLTYPE afs_ni_syscall32 = 0;
 static SYSCALLTYPE old_sys_setgroupsp = 0;
@@ -159,11 +159,11 @@ static void sys32_setgroups_stub(void)
 	printf("*** error! sys32_setgroups_stub called\n");
 }
 
-#endif /* AFS_PPC64_LINUX26_ENV */
+#endif /* AFS_PPC64_LINUX_ENV */
 
 
 /***** SPARC64 *****/
-#ifdef AFS_SPARC64_LINUX26_ENV
+#ifdef AFS_SPARC64_LINUX_ENV
 static SYSCALLTYPE *afs_sys_call_table32;
 static SYSCALLTYPE afs_ni_syscall32 = 0;
 
@@ -187,11 +187,11 @@ afs_syscall32(long syscall, long parm1, long parm2, long parm3, long parm4,
 			 "ret\n\t"
                          "nop");
 }
-#endif /* AFS_SPARC64_LINUX20_ENV */
+#endif /* AFS_SPARC64_LINUX_ENV */
 
 
 /***** IA64 *****/
-#ifdef AFS_IA64_LINUX20_ENV
+#ifdef AFS_IA64_LINUX_ENV
 
 asmlinkage long
 afs_syscall_stub(int r0, int r1, long r2, long r3, long r4, long gp)
@@ -266,7 +266,7 @@ struct fptr {
     unsigned long gp;
 };
 
-#endif /* AFS_IA64_LINUX20_ENV */
+#endif /* AFS_IA64_LINUX_ENV */
 
 /***** PPC64 ***** 
  * Spring 2005
@@ -277,7 +277,7 @@ struct fptr {
  * Horst Birthelmer <Horst.Birthelmer@sysgo.de>
  * Marius Groeger <Marius.Groeger@sysgo.de>
  */
-#if defined(AFS_PPC64_LINUX26_ENV)
+#if defined(AFS_PPC64_LINUX_ENV)
 extern void flush_cache(void *, unsigned long);
 #define PPC_LO(v) ((v) & 0xffff)
 #define PPC_HI(v) (((v) >> 16) & 0xffff)
@@ -388,7 +388,7 @@ static void * create_stub(struct ppc64_stub *stub,
 PPC64_STUB(afs_sys_call_stub);
 PPC64_STUB(afs_xsetgroups_stub);
 PPC64_STUB(afs_xsetgroups32_stub);
-#endif /* AFS_PPC64_LINUX26_ENV */
+#endif /* AFS_PPC64_LINUX_ENV */
 
 
 /**********************************************************************/
@@ -398,7 +398,7 @@ PPC64_STUB(afs_xsetgroups32_stub);
 int osi_syscall_init(void)
 {
 /***** IA64 *****/
-#ifdef AFS_IA64_LINUX20_ENV
+#ifdef AFS_IA64_LINUX_ENV
     /* This needs to be first because we are declaring variables, and
      * also because the handling of syscall pointers is bizarre enough
      * that we want to special-case even the "common" part.
@@ -436,7 +436,7 @@ int osi_syscall_init(void)
     /* XXX no 32-bit syscalls on IA64? */
 
 
-#elif defined(AFS_PPC64_LINUX26_ENV)
+#elif defined(AFS_PPC64_LINUX_ENV)
 
     afs_sys_call_table = osi_find_syscall_table(0);
     if (afs_sys_call_table) {
@@ -481,7 +481,7 @@ int osi_syscall_init(void)
 	sys32_setgroupsp = POINTER2SYSCALL sys32_setgroups_stub;
     }
 /***** COMMON (except IA64 or PPC64) *****/
-#else /* !AFS_IA64_LINUX20_ENV */
+#else /* !AFS_IA64_LINUX_ENV */
 
     afs_sys_call_table = osi_find_syscall_table(0);
     if (afs_sys_call_table) {
@@ -508,11 +508,11 @@ int osi_syscall_init(void)
 	INSERT_SYSCALL(__NR_setgroups32, afs_sys_setgroups32_page, afs_xsetgroups32)
 #endif
     }
-#endif /* !AFS_IA64_LINUX20_ENV */
+#endif /* !AFS_IA64_LINUX_ENV */
 
 
 /***** AMD64 *****/
-#ifdef AFS_AMD64_LINUX20_ENV
+#ifdef AFS_AMD64_LINUX_ENV
     afs_ia32_sys_call_table = osi_find_syscall_table(1);
     if (afs_ia32_sys_call_table) {
 	/* setup AFS entry point for IA32 */
@@ -532,11 +532,11 @@ int osi_syscall_init(void)
 	afs_ia32_sys_call_table[__NR_ia32_setgroups32] =
 	    POINTER2SYSCALL afs32_xsetgroups32;
     }
-#endif /* AFS_AMD64_LINUX20_ENV */
+#endif /* AFS_AMD64_LINUX_ENV */
 
 
 /***** SPARC64 *****/
-#ifdef AFS_SPARC64_LINUX20_ENV
+#ifdef AFS_SPARC64_LINUX_ENV
     afs_sys_call_table32 = osi_find_syscall_table(1);
     if (afs_sys_call_table32) {
 	/* setup AFS entry point for 32-bit SPARC */
@@ -553,7 +553,7 @@ int osi_syscall_init(void)
 	afs_sys_call_table32[__NR_setgroups32] =
 	    POINTER2SYSCALL afs32_xsetgroups32;
     }
-#endif /* AFS_SPARC64_LINUX20_ENV */
+#endif /* AFS_SPARC64_LINUX_ENV */
     return 0;
 }
 
@@ -571,26 +571,26 @@ void osi_syscall_clean(void)
 	afs_sys_call_table[_S(__NR_afs_syscall)] = afs_ni_syscall;
 
 	/* put back setgroups */
-#if defined(AFS_IA64_LINUX20_ENV)
+#if defined(AFS_IA64_LINUX_ENV)
 	afs_sys_call_table[_S(__NR_setgroups)] =
 	    POINTER2SYSCALL((struct fptr *)sys_setgroupsp)->ip;
-#elif defined(AFS_PPC64_LINUX26_ENV)
+#elif defined(AFS_PPC64_LINUX_ENV)
 	afs_sys_call_table[_S(__NR_setgroups)] =
 	    POINTER2SYSCALL old_sys_setgroupsp;
 	/* put back setgroups32 for PPC64 */
 	afs_sys_call_table32[__NR_setgroups] =
 	    POINTER2SYSCALL old_sys32_setgroupsp;
-#else /* AFS_IA64_LINUX20_ENV */
+#else /* AFS_IA64_LINUX_ENV */
 	afs_sys_call_table[_S(__NR_setgroups)] =
 	    POINTER2SYSCALL sys_setgroupsp;
 #endif
 
-#if defined(__NR_setgroups32) && !defined(AFS_IA64_LINUX20_ENV)
+#if defined(__NR_setgroups32) && !defined(AFS_IA64_LINUX_ENV)
 	/* put back setgroups32 */
 	afs_sys_call_table[__NR_setgroups32] = POINTER2SYSCALL sys_setgroups32p;
 #endif
-#if defined(AFS_S390X_LINUX24_ENV)
-#if defined(__NR_setgroups32) && !defined(AFS_IA64_LINUX20_ENV)
+#if defined(AFS_S390X_LINUX_ENV)
+#if defined(__NR_setgroups32) && !defined(AFS_IA64_LINUX_ENV)
 	if (afs_sys_setgroups32_page)
 	    kfree(afs_sys_setgroups32_page);
 #endif
@@ -603,13 +603,13 @@ void osi_syscall_clean(void)
 
 
 /***** IA64 *****/
-#ifdef AFS_IA64_LINUX20_ENV
+#ifdef AFS_IA64_LINUX_ENV
     /* XXX no 32-bit syscalls on IA64? */
 #endif
 
 
 /***** AMD64 *****/
-#ifdef AFS_AMD64_LINUX20_ENV
+#ifdef AFS_AMD64_LINUX_ENV
     if (afs_ia32_sys_call_table) {
 	/* put back AFS entry point for IA32 */
 	afs_ia32_sys_call_table[__NR_ia32_afs_syscall] =
@@ -627,7 +627,7 @@ void osi_syscall_clean(void)
 
 
 /***** SPARC64 *****/
-#ifdef AFS_SPARC64_LINUX20_ENV
+#ifdef AFS_SPARC64_LINUX_ENV
     if (afs_sys_call_table32) {
 	/* put back AFS entry point for 32-bit SPARC */
 	afs_sys_call_table32[__NR_afs_syscall] = afs_ni_syscall32;
diff --git a/src/afs/LINUX/osi_vfsops.c b/src/afs/LINUX/osi_vfsops.c
index ca1d5c83b..b85ab3fdf 100644
--- a/src/afs/LINUX/osi_vfsops.c
+++ b/src/afs/LINUX/osi_vfsops.c
@@ -353,7 +353,7 @@ afs_put_super(struct super_block *sbp)
     afs_globalVFS = 0;
     afs_globalVp = 0;
 
-    afs_shutdown();
+    afs_shutdown(AFS_WARM);
     mntput(afs_cacheMnt);
 
     osi_linux_verify_alloced_memory();
diff --git a/src/afs/LINUX/osi_vnodeops.c b/src/afs/LINUX/osi_vnodeops.c
index 00103a538..54118637f 100644
--- a/src/afs/LINUX/osi_vnodeops.c
+++ b/src/afs/LINUX/osi_vnodeops.c
@@ -447,7 +447,7 @@ afs_linux_readdir(struct file *fp, void *dirbuf, filldir_t filldir)
      */
     while ((avc->f.states & CStatd)
 	   && (tdc->dflags & DFFetching)
-	   && hsame(avc->f.m.DataVersion, tdc->f.versionNo)) {
+	   && afs_IsDCacheFresh(tdc, avc)) {
 	ReleaseReadLock(&tdc->lock);
 	ReleaseWriteLock(&avc->lock);
 	afs_osi_Sleep(&tdc->validPos);
@@ -455,7 +455,7 @@ afs_linux_readdir(struct file *fp, void *dirbuf, filldir_t filldir)
 	ObtainReadLock(&tdc->lock);
     }
     if (!(avc->f.states & CStatd)
-	|| !hsame(avc->f.m.DataVersion, tdc->f.versionNo)) {
+	|| !afs_IsDCacheFresh(tdc, avc)) {
 	ReleaseReadLock(&tdc->lock);
 	ReleaseWriteLock(&avc->lock);
 	afs_PutDCache(tdc);
@@ -2386,7 +2386,7 @@ afs_linux_readpage_fastpath(struct file *fp, struct page *pp, int *codep)
 	ObtainReadLock(&tdc->lock);
 
     /* Is the dcache we've been given currently up to date */
-    if (!hsame(avc->f.m.DataVersion, tdc->f.versionNo) ||
+    if (!afs_IsDCacheFresh(tdc, avc) ||
 	(tdc->dflags & DFFetching))
 	goto out;
 
@@ -2398,7 +2398,11 @@ afs_linux_readpage_fastpath(struct file *fp, struct page *pp, int *codep)
     /* XXX - I suspect we should be locking the inodes before we use them! */
     AFS_GUNLOCK();
     cacheFp = afs_linux_raw_open(&tdc->f.inode);
-    osi_Assert(cacheFp);
+    if (cacheFp == NULL) {
+	/* Problem getting the inode */
+	AFS_GLOCK();
+	goto out;
+    }
     if (!cacheFp->f_dentry->d_inode->i_mapping->a_ops->readpage) {
 	cachefs_noreadpage = 1;
 	AFS_GLOCK();
@@ -2532,12 +2536,98 @@ afs_linux_prefetch(struct file *fp, struct page *pp)
 
 }
 
+#if defined(STRUCT_ADDRESS_SPACE_OPERATIONS_HAS_READAHEAD)
+/*
+ * Bypass the cache while performing a readahead.
+ * See the comments for afs_linux_readahead for the semantics
+ * for 'rac'.
+ */
+static void
+afs_linux_bypass_readahead(struct readahead_control *rac)
+{
+    struct file *fp = rac->file;
+    unsigned num_pages = readahead_count(rac);
+    afs_int32 page_ix;
+    afs_offs_t offset;
+    struct iovec* iovecp;
+    struct nocache_read_request *ancr;
+    struct page *pp;
+    afs_int32 code = 0;
+
+    cred_t *credp;
+    struct inode *ip = FILE_INODE(fp);
+    struct vcache *avc = VTOAFS(ip);
+    afs_int32 base_index = 0;
+    afs_int32 page_count = 0;
+    afs_int32 isize;
+
+    ancr = afs_alloc_ncr(num_pages);
+    if (ancr == NULL)
+	goto done;
+
+    iovecp = ancr->auio->uio_iov;
+
+    for (page_ix = 0; page_ix < num_pages; ++page_ix) {
+	pp = readahead_page(rac);
+	if (pp == NULL)
+	    break;
+
+	isize = (i_size_read(fp->f_mapping->host) - 1) >> PAGE_SHIFT;
+	if (pp->index > isize) {
+	    if (PageLocked(pp))
+		unlock_page(pp);
+	    put_page(pp);
+	    continue;
+	}
+
+	if (page_ix == 0) {
+	    offset = page_offset(pp);
+	    ancr->offset = ancr->auio->uio_offset = offset;
+	    base_index = pp->index;
+	}
+	iovecp[page_ix].iov_len = PAGE_SIZE;
+	if (base_index != pp->index) {
+	    if (PageLocked(pp))
+		 unlock_page(pp);
+	    put_page(pp);
+	    iovecp[page_ix].iov_base = NULL;
+	    base_index++;
+	    ancr->length -= PAGE_SIZE;
+	    continue;
+	}
+	base_index++;
+	page_count++;
+	/* save the page for background map */
+	iovecp[page_ix].iov_base = pp;
+    }
+
+    /* If there were useful pages in the page list, schedule
+     * the read */
+    if (page_count > 0) {
+	credp = crref();
+	/* The background thread frees the ancr */
+	code = afs_ReadNoCache(avc, ancr, credp);
+	crfree(credp);
+    } else {
+	/* If there is nothing for the background thread to handle,
+	 * it won't be freeing the things that we never gave it */
+	afs_free_ncr(&ancr);
+    }
+    /* we do not flush, release, or unmap pages--that will be
+     * done for us by the background thread as each page comes in
+     * from the fileserver */
+
+ done:
+    /* The vfs layer will unlock/put any of the pages in the rac that were not
+     * processed */
+    return;
+}
+#else /* STRUCT_ADDRESS_SPACE_OPERATIONS_HAS_READAHEAD */
 static int
 afs_linux_bypass_readpages(struct file *fp, struct address_space *mapping,
 			   struct list_head *page_list, unsigned num_pages)
 {
     afs_int32 page_ix;
-    struct uio *auio;
     afs_offs_t offset;
     struct iovec* iovecp;
     struct nocache_read_request *ancr;
@@ -2552,20 +2642,10 @@ afs_linux_bypass_readpages(struct file *fp, struct address_space *mapping,
     afs_int32 page_count = 0;
     afs_int32 isize;
 
-    /* background thread must free: iovecp, auio, ancr */
-    iovecp = osi_Alloc(num_pages * sizeof(struct iovec));
-
-    auio = osi_Alloc(sizeof(struct uio));
-    auio->uio_iov = iovecp;
-    auio->uio_iovcnt = num_pages;
-    auio->uio_flag = UIO_READ;
-    auio->uio_seg = AFS_UIOSYS;
-    auio->uio_resid = num_pages * PAGE_SIZE;
-
-    ancr = osi_Alloc(sizeof(struct nocache_read_request));
-    ancr->auio = auio;
-    ancr->offset = auio->uio_offset;
-    ancr->length = auio->uio_resid;
+    ancr = afs_alloc_ncr(num_pages);
+    if (ancr == NULL)
+	return afs_convert_code(ENOMEM);
+    iovecp = ancr->auio->uio_iov;
 
     afs_lru_cache_init(&lrupages);
 
@@ -2587,7 +2667,7 @@ afs_linux_bypass_readpages(struct file *fp, struct address_space *mapping,
 
 	if(page_ix == 0) {
 	    offset = page_offset(pp);
-	    ancr->offset = auio->uio_offset = offset;
+	    ancr->offset = ancr->auio->uio_offset = offset;
 	    base_index = pp->index;
 	}
         iovecp[page_ix].iov_len = PAGE_SIZE;
@@ -2626,21 +2706,20 @@ afs_linux_bypass_readpages(struct file *fp, struct address_space *mapping,
     if(page_count) {
 	afs_lru_cache_finalize(&lrupages);
 	credp = crref();
+	/* background thread frees the ancr */
         code = afs_ReadNoCache(avc, ancr, credp);
 	crfree(credp);
     } else {
         /* If there is nothing for the background thread to handle,
          * it won't be freeing the things that we never gave it */
-        osi_Free(iovecp, num_pages * sizeof(struct iovec));
-        osi_Free(auio, sizeof(struct uio));
-        osi_Free(ancr, sizeof(struct nocache_read_request));
+	afs_free_ncr(&ancr);
     }
     /* we do not flush, release, or unmap pages--that will be
      * done for us by the background thread as each page comes in
      * from the fileserver */
     return afs_convert_code(code);
 }
-
+#endif /* STRUCT_ADDRESS_SPACE_OPERATIONS_HAS_READAHEAD */
 
 static int
 afs_linux_bypass_readpage(struct file *fp, struct page *pp)
@@ -2665,8 +2744,17 @@ afs_linux_bypass_readpage(struct file *fp, struct page *pp)
     ClearPageError(pp);
 
     /* receiver frees */
-    auio = osi_Alloc(sizeof(struct uio));
-    iovecp = osi_Alloc(sizeof(struct iovec));
+    ancr = afs_alloc_ncr(1);
+    if (ancr == NULL) {
+	SetPageError(pp);
+	return afs_convert_code(ENOMEM);
+    }
+    /*
+     * afs_alloc_ncr has already set the auio->uio_iov, make sure setup_uio
+     * uses the existing value when it sets auio->uio_iov.
+     */
+    auio = ancr->auio;
+    iovecp = auio->uio_iov;
 
     /* address can be NULL, because we overwrite it with 'pp', below */
     setup_uio(auio, iovecp, NULL, page_offset(pp),
@@ -2676,8 +2764,6 @@ afs_linux_bypass_readpage(struct file *fp, struct page *pp)
     get_page(pp); /* see above */
     auio->uio_iov->iov_base = (void*) pp;
     /* the background thread will free this */
-    ancr = osi_Alloc(sizeof(struct nocache_read_request));
-    ancr->auio = auio;
     ancr->offset = page_offset(pp);
     ancr->length = PAGE_SIZE;
 
@@ -2699,7 +2785,7 @@ afs_linux_can_bypass(struct inode *ip) {
 	case LARGE_FILES_BYPASS_CACHE:
 	    if (i_size_read(ip) > cache_bypass_threshold)
 		return 1;
-	    /* fall through */
+	    AFS_FALLTHROUGH;
 	default:
 	    return 0;
      }
@@ -2739,11 +2825,179 @@ afs_linux_readpage(struct file *fp, struct page *pp)
     return code;
 }
 
+/*
+ * Updates the adc and acacheFp parameters
+ * Returns:
+ *    0 - success
+ *   -1 - problem getting inode or no mapping function
+ */
+static int
+get_dcache_readahead(struct dcache **adc, struct file **acacheFp,
+		     struct vcache *avc, loff_t offset)
+{
+    struct dcache *tdc = *adc;
+    struct file *cacheFp = *acacheFp;
+    int code;
+
+    if (tdc != NULL && tdc->f.chunk != AFS_CHUNK(offset)) {
+	AFS_GLOCK();
+	ReleaseReadLock(&tdc->lock);
+	afs_PutDCache(tdc);
+	AFS_GUNLOCK();
+	tdc = NULL;
+	if (cacheFp != NULL) {
+	    filp_close(cacheFp, NULL);
+	    cacheFp = NULL;
+	}
+    }
+
+    if (tdc == NULL) {
+	AFS_GLOCK();
+	tdc = afs_FindDCache(avc, offset);
+	if (tdc != NULL) {
+	    ObtainReadLock(&tdc->lock);
+	    if (!afs_IsDCacheFresh(tdc, avc) ||
+		(tdc->dflags & DFFetching) != 0) {
+		ReleaseReadLock(&tdc->lock);
+		afs_PutDCache(tdc);
+		tdc = NULL;
+	    }
+	}
+	AFS_GUNLOCK();
+	if (tdc != NULL) {
+	    cacheFp = afs_linux_raw_open(&tdc->f.inode);
+	    if (cacheFp == NULL) {
+		/* Problem getting the inode */
+		code = -1;
+		goto out;
+	    }
+	    if (cacheFp->f_dentry->d_inode->i_mapping->a_ops->readpage == NULL) {
+		cachefs_noreadpage = 1;
+		/* No mapping function */
+		code = -1;
+		goto out;
+	    }
+	}
+    }
+    code = 0;
+
+ out:
+    if (code != 0) {
+	if (cacheFp != NULL) {
+	    filp_close(cacheFp, NULL);
+	    cacheFp = NULL;
+	}
+	if (tdc != NULL) {
+	    AFS_GLOCK();
+	    ReleaseReadLock(&tdc->lock);
+	    afs_PutDCache(tdc);
+	    AFS_GUNLOCK();
+	    tdc = NULL;
+	}
+    }
+    *adc = tdc;
+    *acacheFp = cacheFp;
+    return code;
+}
+
+#if defined(STRUCT_ADDRESS_SPACE_OPERATIONS_HAS_READAHEAD)
+/*
+ * Readahead reads a number of pages for a particular file. We use
+ * this to optimise the reading, by limiting the number of times upon which
+ * we have to lookup, lock and open vcaches and dcaches.
+ *
+ * Upon return, the vfs layer handles unlocking and putting any pages in the
+ * rac that we did not process here.
+ *
+ * Note: any errors detected during readahead are ignored at this stage by the
+ * vfs. We just need to unlock/put the page and return.  Errors will be detected
+ * later in the vfs processing.
+ */
+static void
+afs_linux_readahead(struct readahead_control *rac)
+{
+    struct page *page;
+    struct address_space *mapping = rac->mapping;
+    struct inode *inode = mapping->host;
+    struct vcache *avc = VTOAFS(inode);
+    struct dcache *tdc;
+    struct file *cacheFp = NULL;
+    int code;
+    loff_t offset;
+    struct afs_lru_pages lrupages;
+    struct afs_pagecopy_task *task;
+
+    if (afs_linux_bypass_check(inode)) {
+	afs_linux_bypass_readahead(rac);
+	return;
+    }
+    if (cacheDiskType == AFS_FCACHE_TYPE_MEM)
+	return;
+
+    /* No readpage (ex: tmpfs) , skip */
+    if (cachefs_noreadpage)
+	return;
+
+    AFS_GLOCK();
+    code = afs_linux_VerifyVCache(avc, NULL);
+    if (code != 0) {
+	AFS_GUNLOCK();
+	return;
+    }
+
+    ObtainWriteLock(&avc->lock, 912);
+    AFS_GUNLOCK();
+
+    task = afs_pagecopy_init_task();
+
+    tdc = NULL;
+
+    afs_lru_cache_init(&lrupages);
+
+    while ((page = readahead_page(rac)) != NULL) {
+	offset = page_offset(page);
+
+	code = get_dcache_readahead(&tdc, &cacheFp, avc, offset);
+	if (code != 0) {
+	    if (PageLocked(page)) {
+		unlock_page(page);
+	    }
+	    put_page(page);
+	    goto done;
+	}
+
+	if (tdc != NULL) {
+	    /* afs_linux_read_cache will unlock the page */
+	    afs_linux_read_cache(cacheFp, page, tdc->f.chunk, &lrupages, task);
+	} else if (PageLocked(page)) {
+	    unlock_page(page);
+	}
+	put_page(page);
+    }
+
+ done:
+    afs_lru_cache_finalize(&lrupages);
+
+    if (cacheFp != NULL)
+	filp_close(cacheFp, NULL);
+
+    afs_pagecopy_put_task(task);
+
+    AFS_GLOCK();
+    if (tdc != NULL) {
+	ReleaseReadLock(&tdc->lock);
+	afs_PutDCache(tdc);
+    }
+
+    ReleaseWriteLock(&avc->lock);
+    AFS_GUNLOCK();
+    return;
+}
+#else /* STRUCT_ADDRESS_SPACE_OPERATIONS_HAS_READAHEAD */
 /* Readpages reads a number of pages for a particular file. We use
  * this to optimise the reading, by limiting the number of times upon which
  * we have to lookup, lock and open vcaches and dcaches
  */
-
 static int
 afs_linux_readpages(struct file *fp, struct address_space *mapping,
 		    struct list_head *page_list, unsigned int num_pages)
@@ -2788,37 +3042,9 @@ afs_linux_readpages(struct file *fp, struct address_space *mapping,
 	list_del(&page->lru);
 	offset = page_offset(page);
 
-	if (tdc && tdc->f.chunk != AFS_CHUNK(offset)) {
-	    AFS_GLOCK();
-	    ReleaseReadLock(&tdc->lock);
-	    afs_PutDCache(tdc);
-	    AFS_GUNLOCK();
-	    tdc = NULL;
-	    if (cacheFp)
-		filp_close(cacheFp, NULL);
-	}
-
-	if (!tdc) {
-	    AFS_GLOCK();
-	    if ((tdc = afs_FindDCache(avc, offset))) {
-		ObtainReadLock(&tdc->lock);
-		if (!hsame(avc->f.m.DataVersion, tdc->f.versionNo) ||
-		    (tdc->dflags & DFFetching)) {
-		    ReleaseReadLock(&tdc->lock);
-		    afs_PutDCache(tdc);
-		    tdc = NULL;
-		}
-	    }
-	    AFS_GUNLOCK();
-	    if (tdc) {
-		cacheFp = afs_linux_raw_open(&tdc->f.inode);
-                osi_Assert(cacheFp);
-		if (!cacheFp->f_dentry->d_inode->i_mapping->a_ops->readpage) {
-		    cachefs_noreadpage = 1;
-		    goto out;
-		}
-	    }
-	}
+	code = get_dcache_readahead(&tdc, &cacheFp, avc, offset);
+	if (code != 0)
+	    goto out;
 
 	if (tdc && !add_to_page_cache(page, mapping, page->index,
 				      GFP_KERNEL)) {
@@ -2833,7 +3059,7 @@ afs_linux_readpages(struct file *fp, struct address_space *mapping,
     afs_lru_cache_finalize(&lrupages);
 
 out:
-    if (tdc)
+    if (cacheFp)
 	filp_close(cacheFp, NULL);
 
     afs_pagecopy_put_task(task);
@@ -2848,6 +3074,7 @@ out:
     AFS_GUNLOCK();
     return 0;
 }
+#endif /* STRUCT_ADDRESS_SPACE_OPERATIONS_HAS_READAHEAD */
 
 /* Prepare an AFS vcache for writeback. Should be called with the vcache
  * locked */
@@ -3286,9 +3513,17 @@ static struct inode_operations afs_file_iops = {
 
 static struct address_space_operations afs_file_aops = {
   .readpage =		afs_linux_readpage,
+#if defined(STRUCT_ADDRESS_SPACE_OPERATIONS_HAS_READAHEAD)
+  .readahead =		afs_linux_readahead,
+#else
   .readpages = 		afs_linux_readpages,
+#endif
   .writepage =		afs_linux_writepage,
+#if defined(STRUCT_ADDRESS_SPACE_OPERATIONS_HAS_DIRTY_FOLIO)
+  .dirty_folio =	block_dirty_folio,
+#else
   .set_page_dirty =	__set_page_dirty_buffers,
+#endif
 #if defined (STRUCT_ADDRESS_SPACE_OPERATIONS_HAS_WRITE_BEGIN)
   .write_begin =        afs_linux_write_begin,
   .write_end =          afs_linux_write_end,
diff --git a/src/afs/NBSD/osi_machdep.h b/src/afs/NBSD/osi_machdep.h
index 2ded63dd3..43aa62101 100644
--- a/src/afs/NBSD/osi_machdep.h
+++ b/src/afs/NBSD/osi_machdep.h
@@ -96,7 +96,6 @@ typedef struct kauth_cred afs_ucred_t;
 
 /* time */
 #define	afs_hz		hz
-#define osi_GetTime(x)	getmicrotime(x)
 #define osi_Time()      time_second
 
 /* str */
@@ -207,4 +206,13 @@ extern int afs_debug;
 
 #define AFS_USE_NBSD_NAMECACHE 0
 
+static_inline void
+osi_GetTime(osi_timeval32_t *atv)
+{
+    struct timeval now;
+    getmicrotime(&now);
+    atv->tv_sec = now.tv_sec;
+    atv->tv_usec = now.tv_usec;
+}
+
 #endif /* _OSI_MACHDEP_H_ */
diff --git a/src/afs/NBSD/osi_vfsops.c b/src/afs/NBSD/osi_vfsops.c
index a52629b73..a78943da0 100644
--- a/src/afs/NBSD/osi_vfsops.c
+++ b/src/afs/NBSD/osi_vfsops.c
@@ -302,8 +302,7 @@ afs_unmount(struct mount *mp, int mntflags)
     vflush(mp, NULLVP, 0);	/* don't support forced */
     AFS_GLOCK();
     afs_globalVFS = NULL;
-    afs_cold_shutdown = 1;
-    afs_shutdown();		/* XXX */
+    afs_shutdown(AFS_COLD);
     AFS_GUNLOCK();
 
     mp->mnt_data = NULL;
diff --git a/src/afs/OBSD/osi_machdep.h b/src/afs/OBSD/osi_machdep.h
index aec0f69ce..1179e273c 100644
--- a/src/afs/OBSD/osi_machdep.h
+++ b/src/afs/OBSD/osi_machdep.h
@@ -97,7 +97,6 @@ typedef struct ucred afs_ucred_t;
 
 /* time */
 #define	afs_hz		hz
-#define osi_GetTime(x)	microtime(x)
 extern time_t osi_Time();
 
 /* str */
@@ -243,4 +242,13 @@ extern int (**afs_vnodeop_p) ();
 
 #define osi_procname(procname, size) strncpy(procname, curproc->p_comm, size)
 
+static_inline void
+osi_GetTime(osi_timeval32_t *atv)
+{
+    struct timeval now;
+    microtime(&now);
+    atv->tv_sec = now.tv_sec;
+    atv->tv_usec = now.tv_usec;
+}
+
 #endif /* _OSI_MACHDEP_H_ */
diff --git a/src/afs/OBSD/osi_vfsops.c b/src/afs/OBSD/osi_vfsops.c
index 4377494bb..830906cc3 100644
--- a/src/afs/OBSD/osi_vfsops.c
+++ b/src/afs/OBSD/osi_vfsops.c
@@ -290,8 +290,7 @@ afs_unmount(afsp, flags, p)
     afsp->mnt_data = NULL;
     AFS_GLOCK();
     afs_globalVFS = 0;
-    afs_cold_shutdown = 1;
-    afs_shutdown();		/* XXX */
+    afs_shutdown(AFS_COLD);
     AFS_GUNLOCK();
 
     /* give up syscall entries for ioctl & setgroups, which we've stolen */
diff --git a/src/afs/SOLARIS/osi_machdep.h b/src/afs/SOLARIS/osi_machdep.h
index c34ffb584..45ee8deb3 100644
--- a/src/afs/SOLARIS/osi_machdep.h
+++ b/src/afs/SOLARIS/osi_machdep.h
@@ -125,4 +125,13 @@ struct afs_ifinfo {
 
 #define osi_procname(procname, size) strncpy(procname, PTOU(ttoproc(curthread))->u_comm, size)
 
+static_inline void
+osi_GetTime(osi_timeval32_t *atv)
+{
+    struct timeval32 now;
+    uniqtime32(&now);
+    atv->tv_sec = now.tv_sec;
+    atv->tv_usec = now.tv_usec;
+}
+
 #endif /* _OSI_MACHDEP_H_ */
diff --git a/src/afs/SOLARIS/osi_vfsops.c b/src/afs/SOLARIS/osi_vfsops.c
index 5b1a3a5d7..c6c9ddf56 100644
--- a/src/afs/SOLARIS/osi_vfsops.c
+++ b/src/afs/SOLARIS/osi_vfsops.c
@@ -75,7 +75,7 @@ afs_freevfs(void)
 
     afs_globalVFS = 0;
 
-    afs_shutdown();
+    afs_shutdown(AFS_WARM);
 }
 
 int
diff --git a/src/afs/SOLARIS/osi_vnodeops.c b/src/afs/SOLARIS/osi_vnodeops.c
index fde268401..76b55b351 100644
--- a/src/afs/SOLARIS/osi_vnodeops.c
+++ b/src/afs/SOLARIS/osi_vnodeops.c
@@ -350,7 +350,7 @@ afs_GetOnePage(struct vnode *vp, u_offset_t off, u_int alen, u_int *protp,
 
     /* Check to see whether the cache entry is still valid */
     if (!(avc->f.states & CStatd)
-	|| !hsame(avc->f.m.DataVersion, tdc->f.versionNo)) {
+	|| !afs_IsDCacheFresh(tdc, avc)) {
 	ReleaseReadLock(&tdc->lock);
 	ReleaseReadLock(&avc->lock);
 	afs_PutDCache(tdc);
@@ -882,12 +882,12 @@ afs_nfsrdwr(struct vcache *avc, struct uio *auio, enum uio_rw arw,
 		AFS_GLOCK();
 		dcp_newpage = afs_FindDCache(avc, pageBase);
 		if (dcp_newpage
-		    && hsame(avc->f.m.DataVersion, dcp_newpage->f.versionNo)) {
+		    && afs_IsDCacheFresh(dcp_newpage, avc)) {
 		    ObtainWriteLock(&avc->lock, 251);
 		    ObtainWriteLock(&avc->vlock, 576);
 		    ObtainReadLock(&dcp_newpage->lock);
 		    if ((avc->activeV == 0)
-			&& hsame(avc->f.m.DataVersion, dcp_newpage->f.versionNo)
+			&& afs_IsDCacheFresh(dcp_newpage, avc)
 			&& !(dcp_newpage->dflags & (DFFetching))) {
 			AFS_GUNLOCK();
 			segmap_pagecreate(segkmap, raddr, rsize, 1);
diff --git a/src/afs/UKERNEL/afs_usrops.c b/src/afs/UKERNEL/afs_usrops.c
index 0e38fb84b..a151cec05 100644
--- a/src/afs/UKERNEL/afs_usrops.c
+++ b/src/afs/UKERNEL/afs_usrops.c
@@ -935,19 +935,6 @@ afs_osi_Visible(void)
     return;
 }
 
-int
-osi_GetTime(struct timeval *tv)
-{
-    gettimeofday(tv, NULL);
-    return 0;
-}
-
-int
-osi_SetTime(struct timeval *tv)
-{
-    return 0;
-}
-
 int
 osi_Active(struct vcache *avc)
 {
@@ -2398,12 +2385,16 @@ uafs_pread_nocache_r(int fd, char *buf, int len, off_t offset)
     }
 
     /* these get freed in PrefetchNoCache, so... */
-    bparms = afs_osi_Alloc(sizeof(struct nocache_read_request));
+    bparms = afs_alloc_ncr(0);
+    if (bparms == NULL) {
+	errno = ENOMEM;
+	return -1;
+    }
 
     code = afs_CreateReq(&bparms->areq, get_user_struct()->u_cred);
     if (code) {
 	afs_DestroyReq(bparms->areq);
-	afs_osi_Free(bparms, sizeof(struct nocache_read_request));
+	afs_free_ncr(&bparms);
 	errno = code;
 	return -1;
     }
diff --git a/src/afs/UKERNEL/osi_machdep.h b/src/afs/UKERNEL/osi_machdep.h
index 7e11e4d63..161fe7ecf 100644
--- a/src/afs/UKERNEL/osi_machdep.h
+++ b/src/afs/UKERNEL/osi_machdep.h
@@ -83,4 +83,14 @@ extern int afs_suser(void *credp);
 #define osi_curcred()    get_user_struct()->u_cred
 
 #define osi_procname(procname, size) strncpy(procname, "(unknown)", size)
+
+static_inline void
+osi_GetTime(osi_timeval32_t *atv)
+{
+    struct timeval now;
+    gettimeofday(&now, NULL);
+    atv->tv_sec = now.tv_sec;
+    atv->tv_usec = now.tv_usec;
+}
+
 #endif /* _OSI_MACHDEP_H_ */
diff --git a/src/afs/UKERNEL/osi_vfsops.c b/src/afs/UKERNEL/osi_vfsops.c
index b44709b54..cfae3d3d7 100644
--- a/src/afs/UKERNEL/osi_vfsops.c
+++ b/src/afs/UKERNEL/osi_vfsops.c
@@ -53,7 +53,7 @@ afs_unmount(struct vfs *afsp)
 {
     AFS_STATCNT(afs_unmount);
     afs_globalVFS = 0;
-    afs_shutdown();
+    afs_shutdown(AFS_WARM);
     return 0;
 }
 
diff --git a/src/afs/UKERNEL/sysincludes.h b/src/afs/UKERNEL/sysincludes.h
index 15000652f..03666b02a 100644
--- a/src/afs/UKERNEL/sysincludes.h
+++ b/src/afs/UKERNEL/sysincludes.h
@@ -82,7 +82,7 @@
 #include  <arpa/inet.h>
 #endif /* AFS_USR_HPUX_ENV */
 
-#ifdef AFS_USR_LINUX22_ENV
+#ifdef AFS_USR_LINUX_ENV
 #include  <sys/ioctl.h>		/* _IOW() */
 #include  <sys/uio.h>		/* struct iovec */
 #include  <sys/time.h>		/* struct timeval */
@@ -97,7 +97,7 @@
 #include  <netdb.h>
 #include  <arpa/inet.h>
 #define FREAD			0x0001
-#endif /* AFS_USR_LINUX22_ENV */
+#endif /* AFS_USR_LINUX_ENV */
 
 #if defined(AFS_USR_DARWIN_ENV) || defined(AFS_USR_FBSD_ENV) || defined(AFS_USR_DFBSD_ENV)
 #ifdef _KERNEL
@@ -150,7 +150,7 @@ typedef unsigned int fsblkcnt_t;
 #include <resolv.h>
 
 /* glibc 2.2 has pthread_attr_setstacksize */
-#if (defined(AFS_LINUX22_ENV) && !defined(AFS_USR_LINUX22_ENV)) || (defined(AFS_USR_LINUX22_ENV) && (__GLIBC_MINOR__ < 2))
+#if (defined(AFS_LINUX_ENV) && !defined(AFS_USR_LINUX_ENV)) || (defined(AFS_USR_LINUX_ENV) && (__GLIBC_MINOR__ < 2))
 #define pthread_attr_setstacksize(a,b) 0
 #endif
 
diff --git a/src/afs/VNOPS/afs_vnop_attrs.c b/src/afs/VNOPS/afs_vnop_attrs.c
index 64abe7f35..d10333788 100644
--- a/src/afs/VNOPS/afs_vnop_attrs.c
+++ b/src/afs/VNOPS/afs_vnop_attrs.c
@@ -141,7 +141,7 @@ afs_CopyOutAttrs(struct vcache *avc, struct vattr *attrs)
     attrs->va_atime.tv_nsec = attrs->va_mtime.tv_nsec =
 	attrs->va_ctime.tv_nsec = 0;
     attrs->va_gen = hgetlo(avc->f.m.DataVersion);
-#elif defined(AFS_SGI_ENV) || defined(AFS_SUN5_ENV) || defined(AFS_AIX41_ENV) || defined(AFS_OBSD_ENV) || defined(AFS_NBSD_ENV) || defined(AFS_LINUX26_ENV)
+#elif defined(AFS_SGI_ENV) || defined(AFS_SUN5_ENV) || defined(AFS_AIX41_ENV) || defined(AFS_OBSD_ENV) || defined(AFS_NBSD_ENV) || defined(AFS_LINUX_ENV)
     attrs->va_atime.tv_nsec = attrs->va_mtime.tv_nsec =
 	attrs->va_ctime.tv_nsec =
 	(hgetlo(avc->f.m.DataVersion) & 0x7ffff) * 1000;
@@ -298,7 +298,7 @@ afs_getattr(OSI_VC_DECL(avc), struct vattr *attrs, afs_ucred_t *acred)
 		    /* If it's the root of AFS, replace the inode number with the
 		     * inode number of the mounted on directory; otherwise this
 		     * confuses getwd()... */
-#ifdef AFS_LINUX22_ENV
+#ifdef AFS_LINUX_ENV
 		    if (avc == afs_globalVp) {
 			struct inode *ip = AFSTOV(avc)->i_sb->s_root->d_inode;
 			attrs->va_nodeid = ip->i_ino;	/* VTOI()? */
@@ -333,7 +333,7 @@ afs_getattr(OSI_VC_DECL(avc), struct vattr *attrs, afs_ucred_t *acred)
 			}
 # endif /* AFS_DARWIN80_ENV */
 		    }
-#endif /* AFS_LINUX22_ENV */
+#endif /* AFS_LINUX_ENV */
 		}
 		afs_PutUser(au, READ_LOCK);
 	    }
@@ -365,7 +365,7 @@ afs_VAttrToAS(struct vcache *avc, struct vattr *av,
 #elif defined(AFS_AIX_ENV)
 /* Boy, was this machine dependent bogosity hard to swallow????.... */
     if (av->va_mode != -1) {
-#elif defined(AFS_LINUX22_ENV) || defined(UKERNEL)
+#elif defined(AFS_LINUX_ENV) || defined(UKERNEL)
     if (av->va_mask & ATTR_MODE) {
 #elif defined(AFS_SUN5_ENV) || defined(AFS_SGI_ENV)
     if (av->va_mask & AT_MODE) {
@@ -384,7 +384,7 @@ afs_VAttrToAS(struct vcache *avc, struct vattr *av,
     }
 #if defined(AFS_DARWIN80_ENV)
     if (VATTR_IS_ACTIVE(av, va_gid)) {
-#elif defined(AFS_LINUX22_ENV) || defined(UKERNEL)
+#elif defined(AFS_LINUX_ENV) || defined(UKERNEL)
     if (av->va_mask & ATTR_GID) {
 #elif defined(AFS_SUN5_ENV) || defined(AFS_SGI_ENV)
     if (av->va_mask & AT_GID) {
@@ -404,7 +404,7 @@ afs_VAttrToAS(struct vcache *avc, struct vattr *av,
     }
 #if defined(AFS_DARWIN80_ENV)
     if (VATTR_IS_ACTIVE(av, va_uid)) {
-#elif defined(AFS_LINUX22_ENV) || defined(UKERNEL)
+#elif defined(AFS_LINUX_ENV) || defined(UKERNEL)
     if (av->va_mask & ATTR_UID) {
 #elif defined(AFS_SUN5_ENV) || defined(AFS_SGI_ENV)
     if (av->va_mask & AT_UID) {
@@ -424,7 +424,7 @@ afs_VAttrToAS(struct vcache *avc, struct vattr *av,
     }
 #if defined(AFS_DARWIN80_ENV)
     if (VATTR_IS_ACTIVE(av, va_modify_time)) {
-#elif defined(AFS_LINUX22_ENV) || defined(UKERNEL)
+#elif defined(AFS_LINUX_ENV) || defined(UKERNEL)
     if (av->va_mask & ATTR_MTIME) {
 #elif defined(AFS_SUN5_ENV) || defined(AFS_SGI_ENV)
     if (av->va_mask & AT_MTIME) {
@@ -433,7 +433,7 @@ afs_VAttrToAS(struct vcache *avc, struct vattr *av,
 #endif /* AFS_DARWIN80_ENV */
 	mask |= AFS_SETMODTIME;
 #ifndef	AFS_SGI_ENV
-# if defined(AFS_SUN5_ENV) || defined(AFS_AIX41_ENV) || defined(AFS_DARWIN_ENV) || defined(AFS_XBSD_ENV) || defined(AFS_LINUX26_ENV)
+# if defined(AFS_SUN5_ENV) || defined(AFS_AIX41_ENV) || defined(AFS_DARWIN_ENV) || defined(AFS_XBSD_ENV) || defined(AFS_LINUX_ENV)
 	if (av->va_mtime.tv_nsec == -1)
 # else
 	if (av->va_mtime.tv_usec == -1)
@@ -470,7 +470,7 @@ afs_setattr(OSI_VC_DECL(avc), struct vattr *attrs,
     OSI_VC_CONVERT(avc);
 
     AFS_STATCNT(afs_setattr);
-#if defined(AFS_SUN5_ENV) || defined(AFS_SGI_ENV) || defined(AFS_LINUX22_ENV)
+#if defined(AFS_SUN5_ENV) || defined(AFS_SGI_ENV) || defined(AFS_LINUX_ENV)
     afs_Trace4(afs_iclSetp, CM_TRACE_SETATTR, ICL_TYPE_POINTER, avc,
 	       ICL_TYPE_INT32, attrs->va_mask, ICL_TYPE_OFFSET,
 	       ICL_HANDLE_OFFSET(attrs->va_size), ICL_TYPE_OFFSET,
@@ -510,7 +510,7 @@ afs_setattr(OSI_VC_DECL(avc), struct vattr *attrs,
      */
 #if defined(AFS_DARWIN80_ENV)
     if (VATTR_IS_ACTIVE(attrs, va_data_size)) {
-#elif defined(AFS_LINUX22_ENV) || defined(UKERNEL)
+#elif defined(AFS_LINUX_ENV) || defined(UKERNEL)
     if (attrs->va_mask & ATTR_SIZE) {
 #elif defined(AFS_SUN5_ENV) || defined(AFS_SGI_ENV)
     if (attrs->va_mask & AT_SIZE) {
@@ -545,7 +545,7 @@ afs_setattr(OSI_VC_DECL(avc), struct vattr *attrs,
 #endif
 #if defined(AFS_DARWIN80_ENV)
     if (VATTR_IS_ACTIVE(attrs, va_data_size)) {
-#elif defined(AFS_LINUX22_ENV) || defined(UKERNEL)
+#elif defined(AFS_LINUX_ENV) || defined(UKERNEL)
     if (attrs->va_mask & ATTR_SIZE) {
 #elif defined(AFS_SUN5_ENV) || defined(AFS_SGI_ENV)
     if (attrs->va_mask & AT_SIZE) {
@@ -567,13 +567,13 @@ afs_setattr(OSI_VC_DECL(avc), struct vattr *attrs,
 	} else {
 	    code = afs_TruncateAllSegments(avc, tsize, treq, acred);
 	}
-#ifdef AFS_LINUX26_ENV
+#ifdef AFS_LINUX_ENV
 	/* We must update the Linux kernel's idea of file size as soon as
 	 * possible, to avoid racing with delayed writepages delivered by
 	 * pdflush */
 	if (code == 0)
 	    i_size_write(AFSTOV(avc), tsize);
-#endif /* AFS_LINUX26_ENV */
+#endif /* AFS_LINUX_ENV */
 #if defined(AFS_FBSD_ENV) || defined(AFS_DFBSD_ENV)
 	vnode_pager_setsize(vp, (u_long) tsize);
 #endif
diff --git a/src/afs/VNOPS/afs_vnop_create.c b/src/afs/VNOPS/afs_vnop_create.c
index fe37eed36..70b531a6a 100644
--- a/src/afs/VNOPS/afs_vnop_create.c
+++ b/src/afs/VNOPS/afs_vnop_create.c
@@ -149,7 +149,7 @@ afs_create(OSI_VC_DECL(adp), char *aname, struct vattr *attrs,
      * received a callback while we were waiting for the write lock.
      */
     if (!(adp->f.states & CStatd)
-	|| (tdc && !hsame(adp->f.m.DataVersion, tdc->f.versionNo))) {
+	|| (tdc && !afs_IsDCacheFresh(tdc, adp))) {
 	ReleaseWriteLock(&adp->lock);
 	if (tdc) {
 	    ReleaseSharedLock(&tdc->lock);
@@ -543,7 +543,7 @@ afs_LocalHero(struct vcache *avc, struct dcache *adc,
     if (adc) {
 	/* does what's in the dcache *now* match what's in the vcache *now*,
 	 * and do we have a valid callback? if not, our local copy is not "ok" */
-	ok = (hsame(avc->f.m.DataVersion, adc->f.versionNo) && avc->callback
+	ok = (afs_IsDCacheFresh(adc, avc) && avc->callback
 	      && (avc->f.states & CStatd) && avc->cbExpires >= osi_Time());
     } else {
 	ok = 0;
diff --git a/src/afs/VNOPS/afs_vnop_fid.c b/src/afs/VNOPS/afs_vnop_fid.c
index 3fa2edb1f..54e1956ba 100644
--- a/src/afs/VNOPS/afs_vnop_fid.c
+++ b/src/afs/VNOPS/afs_vnop_fid.c
@@ -17,7 +17,7 @@
 #include "afs/param.h"
 
 
-#if !defined(AFS_LINUX20_ENV) && !defined(AFS_DARWIN_ENV) && !defined(AFS_OBSD_ENV) && !defined(AFS_NBSD_ENV)
+#if !defined(AFS_LINUX_ENV) && !defined(AFS_DARWIN_ENV) && !defined(AFS_OBSD_ENV) && !defined(AFS_NBSD_ENV)
 #include "afs/sysincludes.h"	/* Standard vendor system headers */
 #include "afsincludes.h"	/* Afs-based standard headers */
 #include "afs/afs_stats.h"	/* statistics */
@@ -151,4 +151,4 @@ afs_fid(OSI_VC_DECL(avc), struct fid **fidpp)
 }
 
 
-#endif /* !AFS_LINUX20_ENV */
+#endif /* !AFS_LINUX_ENV */
diff --git a/src/afs/VNOPS/afs_vnop_flock.c b/src/afs/VNOPS/afs_vnop_flock.c
index 9efeeeb78..2ece900c8 100644
--- a/src/afs/VNOPS/afs_vnop_flock.c
+++ b/src/afs/VNOPS/afs_vnop_flock.c
@@ -122,7 +122,7 @@ lockIdSet(struct AFS_FLOCK *flock, struct SimpleLocks *slp, int clid)
 	flock->l_pid = clid;
     }
 }
-#elif defined(AFS_LINUX20_ENV) || defined(AFS_HPUX_ENV)
+#elif defined(AFS_LINUX_ENV) || defined(AFS_HPUX_ENV)
 void
 lockIdSet(struct AFS_FLOCK *flock, struct SimpleLocks *slp, int clid)
 {
@@ -173,7 +173,7 @@ lockIdcmp2(struct AFS_FLOCK *flock1, struct vcache *vp,
 #if	defined(AFS_SUN5_ENV)
     proc_t *procp = ttoproc(curthread);
 #else
-#if !defined(AFS_AIX41_ENV) && !defined(AFS_LINUX20_ENV) && !defined(AFS_SGI65_ENV) && !defined(AFS_DARWIN_ENV) && !defined(AFS_XBSD_ENV)
+#if !defined(AFS_AIX41_ENV) && !defined(AFS_LINUX_ENV) && !defined(AFS_SGI65_ENV) && !defined(AFS_DARWIN_ENV) && !defined(AFS_XBSD_ENV)
 #ifdef AFS_SGI64_ENV
     afs_proc_t *procp = curprocp;
 #elif defined(UKERNEL)
@@ -191,7 +191,7 @@ lockIdcmp2(struct AFS_FLOCK *flock1, struct vcache *vp,
 	}
 #endif
 	if ((flock1->l_pid == alp->pid) ||
-#if defined(AFS_AIX41_ENV) || defined(AFS_LINUX20_ENV) || defined(AFS_HPUX_ENV)
+#if defined(AFS_AIX41_ENV) || defined(AFS_LINUX_ENV) || defined(AFS_HPUX_ENV)
 	    (!onlymine && (flock1->l_pid == getppid()))
 #else
 #if defined(AFS_SGI65_ENV) || defined(AFS_DARWIN_ENV) || defined(AFS_XBSD_ENV)
@@ -541,7 +541,7 @@ DoLockWarning(struct vcache *avc, afs_ucred_t * acred)
     lastWarnTime = avc->lastBRLWarnTime = now;
     lastWarnPid = pid;
 
-#ifdef AFS_LINUX26_ENV
+#ifdef AFS_LINUX_ENV
     message = "byte-range locks only enforced for processes on this machine";
 #else
     message = "byte-range lock/unlock ignored; make sure no one else is running this program";
diff --git a/src/afs/VNOPS/afs_vnop_lookup.c b/src/afs/VNOPS/afs_vnop_lookup.c
index b42d6db43..b0bdcd41f 100644
--- a/src/afs/VNOPS/afs_vnop_lookup.c
+++ b/src/afs/VNOPS/afs_vnop_lookup.c
@@ -752,7 +752,7 @@ afs_DoBulkStat(struct vcache *adp, long dirCookie, struct vrequest *areqp)
      */
     while ((adp->f.states & CStatd)
 	   && (dcp->dflags & DFFetching)
-	   && hsame(adp->f.m.DataVersion, dcp->f.versionNo)) {
+	   && afs_IsDCacheFresh(dcp, adp)) {
 	afs_Trace4(afs_iclSetp, CM_TRACE_DCACHEWAIT, ICL_TYPE_STRING,
 		   __FILE__, ICL_TYPE_INT32, __LINE__, ICL_TYPE_POINTER, dcp,
 		   ICL_TYPE_INT32, dcp->dflags);
@@ -763,7 +763,7 @@ afs_DoBulkStat(struct vcache *adp, long dirCookie, struct vrequest *areqp)
 	ObtainReadLock(&dcp->lock);
     }
     if (!(adp->f.states & CStatd)
-	|| !hsame(adp->f.m.DataVersion, dcp->f.versionNo)) {
+	|| !afs_IsDCacheFresh(dcp, adp)) {
 	ReleaseReadLock(&dcp->lock);
 	ReleaseReadLock(&adp->lock);
 	afs_PutDCache(dcp);
@@ -1225,7 +1225,7 @@ afs_DoBulkStat(struct vcache *adp, long dirCookie, struct vrequest *areqp)
 	 * We only do this if the entry looks clear.
 	 */
 	afs_ProcessFS(tvcp, &statsp[i], areqp);
-#if defined(AFS_LINUX22_ENV)
+#if defined(AFS_LINUX_ENV)
 	afs_fill_inode(AFSTOV(tvcp), NULL);	/* reset inode operations */
 #endif
 
@@ -1597,7 +1597,7 @@ afs_lookup(OSI_VC_DECL(adp), char *aname, struct vcache **avcp, afs_ucred_t *acr
 	goto done;
     }
 
-#ifdef AFS_LINUX26_ENV
+#ifdef AFS_LINUX_ENV
     /*
      * Special case of the dynamic mount volume in a static root.
      * This is really unfortunate, but we need this for the translator.
@@ -1634,7 +1634,7 @@ afs_lookup(OSI_VC_DECL(adp), char *aname, struct vcache **avcp, afs_ucred_t *acr
 	    code = EACCES;
 	    goto done;
 	}
-#ifdef AFS_LINUX22_ENV
+#ifdef AFS_LINUX_ENV
 	if (tvc->mvstat == AFS_MVSTAT_ROOT) {	/* we don't trust the dnlc for root vcaches */
 	    AFS_RELE(AFSTOV(tvc));
 	    *avcp = 0;
@@ -1643,11 +1643,11 @@ afs_lookup(OSI_VC_DECL(adp), char *aname, struct vcache **avcp, afs_ucred_t *acr
 	    hit = 1;
 	    goto done;
 	}
-#else /* non - LINUX */
+#else
 	code = 0;
 	hit = 1;
 	goto done;
-#endif /* linux22 */
+#endif /* AFS_LINUX_ENV */
     }
 
     {				/* sub-block just to reduce stack usage */
@@ -1685,7 +1685,7 @@ afs_lookup(OSI_VC_DECL(adp), char *aname, struct vcache **avcp, afs_ucred_t *acr
 	if (!afs_InReadDir(adp)) {
 	    while ((adp->f.states & CStatd)
 		   && (tdc->dflags & DFFetching)
-		   && hsame(adp->f.m.DataVersion, tdc->f.versionNo)) {
+		   && afs_IsDCacheFresh(tdc, adp)) {
 		ReleaseReadLock(&tdc->lock);
 		ReleaseReadLock(&adp->lock);
 		afs_osi_Sleep(&tdc->validPos);
@@ -1693,7 +1693,7 @@ afs_lookup(OSI_VC_DECL(adp), char *aname, struct vcache **avcp, afs_ucred_t *acr
 		ObtainReadLock(&tdc->lock);
 	    }
 	    if (!(adp->f.states & CStatd)
-		|| !hsame(adp->f.m.DataVersion, tdc->f.versionNo)) {
+		|| !afs_IsDCacheFresh(tdc, adp)) {
 		ReleaseReadLock(&tdc->lock);
 		ReleaseReadLock(&adp->lock);
 		afs_PutDCache(tdc);
@@ -1966,7 +1966,7 @@ afs_lookup(OSI_VC_DECL(adp), char *aname, struct vcache **avcp, afs_ucred_t *acr
 	    if (!hit && (force_eval || tvc->mvstat != AFS_MVSTAT_MTPT)) {
 		osi_dnlc_enter(adp, aname, tvc, &versionNo);
 	    } else {
-#ifdef AFS_LINUX20_ENV
+#ifdef AFS_LINUX_ENV
 		/* So Linux inode cache is up to date. */
 		code = afs_VerifyVCache(tvc, treq);
 #else
diff --git a/src/afs/VNOPS/afs_vnop_open.c b/src/afs/VNOPS/afs_vnop_open.c
index 678a4a7de..fc947e8da 100644
--- a/src/afs/VNOPS/afs_vnop_open.c
+++ b/src/afs/VNOPS/afs_vnop_open.c
@@ -151,7 +151,7 @@ afs_open(struct vcache **avcp, afs_int32 aflags, afs_ucred_t *acred)
     if (writing)
 	tvc->execsOrWriters++;
     tvc->opens++;
-#if defined(AFS_SGI_ENV) || defined (AFS_LINUX26_ENV)
+#if defined(AFS_SGI_ENV) || defined (AFS_LINUX_ENV)
     if (writing && tvc->cred == NULL) {
 	crhold(acred);
 	tvc->cred = acred;
diff --git a/src/afs/VNOPS/afs_vnop_read.c b/src/afs/VNOPS/afs_vnop_read.c
index dba411715..27065e6aa 100644
--- a/src/afs/VNOPS/afs_vnop_read.c
+++ b/src/afs/VNOPS/afs_vnop_read.c
@@ -46,7 +46,6 @@ afs_read(struct vcache *avc, struct uio *auio, afs_ucred_t *acred,
 	 int noLock)
 {
     afs_size_t totalLength;
-    afs_size_t transferLength;
     afs_size_t filePos;
     afs_size_t offset, tlen;
     afs_size_t len = 0;
@@ -96,7 +95,6 @@ afs_read(struct vcache *avc, struct uio *auio, afs_ucred_t *acred,
 	       totalLength, ICL_TYPE_OFFSET,
 	       ICL_HANDLE_OFFSET(avc->f.m.Length));
     error = 0;
-    transferLength = 0;
     if (!noLock)
 	ObtainReadLock(&avc->lock);
 #if	defined(AFS_TEXT_ENV) && !defined(AFS_VM_RDWR_ENV)
@@ -190,7 +188,7 @@ afs_read(struct vcache *avc, struct uio *auio, afs_ucred_t *acred,
 	     * 2 requests never return a null dcache entry, btw.
 	     */
 	    if (!(tdc->dflags & DFFetching)
-		&& !hsame(avc->f.m.DataVersion, tdc->f.versionNo)) {
+		&& !afs_IsDCacheFresh(tdc, avc)) {
 		/* have cache entry, it is not coming in now,
 		 * and we'll need new data */
 	      tagain:
@@ -270,7 +268,7 @@ afs_read(struct vcache *avc, struct uio *auio, afs_ucred_t *acred,
 	    } else {
 		/* no longer fetching, verify data version 
 		 * (avoid new GetDCache call) */
-		if (hsame(avc->f.m.DataVersion, tdc->f.versionNo)
+		if (afs_IsDCacheFresh(tdc, avc)
 		    && ((len = tdc->validPos - filePos) > 0)) {
 		    offset = filePos - AFS_CHUNKTOBASE(tdc->f.chunk);
 		} else {
@@ -352,7 +350,6 @@ afs_read(struct vcache *avc, struct uio *auio, afs_ucred_t *acred,
 	trimlen = len;
 	afsio_skip(auio, trimlen);	/* update input uio structure */
 	totalLength -= len;
-	transferLength += len;
 	filePos += len;
 
 	if (len <= 0)
@@ -548,7 +545,7 @@ afs_UFSReadUIO(afs_dcache_id_t *cacheId, struct uio *tuiop)
     AFS_GUNLOCK();
     code = VOP_RDWR(tfile->vnode, tuiop, UIO_READ, 0, afs_osi_credp);
     AFS_GLOCK();
-#elif defined(AFS_LINUX20_ENV)
+#elif defined(AFS_LINUX_ENV)
     AFS_GUNLOCK();
     code = osi_rdwr(tfile, tuiop, UIO_READ);
     AFS_GLOCK();
diff --git a/src/afs/VNOPS/afs_vnop_readdir.c b/src/afs/VNOPS/afs_vnop_readdir.c
index cdc5af56d..ac2441ed1 100644
--- a/src/afs/VNOPS/afs_vnop_readdir.c
+++ b/src/afs/VNOPS/afs_vnop_readdir.c
@@ -111,7 +111,7 @@ BlobScan(struct dcache * afile, afs_int32 ablob, int *ablobOut)
 }
 
 
-#if !defined(AFS_LINUX20_ENV)
+#if !defined(AFS_LINUX_ENV)
 /* Changes to afs_readdir which affect dcache or vcache handling or use of
  * bulk stat data should also be reflected in the Linux specific verison of
  * the readdir routine.
@@ -702,7 +702,7 @@ afs_readdir(OSI_VC_DECL(avc), struct uio *auio, afs_ucred_t *acred)
      */
     while ((avc->f.states & CStatd)
 	   && (tdc->dflags & DFFetching)
-	   && hsame(avc->f.m.DataVersion, tdc->f.versionNo)) {
+	   && afs_IsDCacheFresh(tdc, avc)) {
 	afs_Trace4(afs_iclSetp, CM_TRACE_DCACHEWAIT, ICL_TYPE_STRING,
 		   __FILE__, ICL_TYPE_INT32, __LINE__, ICL_TYPE_POINTER, tdc,
 		   ICL_TYPE_INT32, tdc->dflags);
@@ -713,7 +713,7 @@ afs_readdir(OSI_VC_DECL(avc), struct uio *auio, afs_ucred_t *acred)
 	ObtainReadLock(&tdc->lock);
     }
     if (!(avc->f.states & CStatd)
-	|| !hsame(avc->f.m.DataVersion, tdc->f.versionNo)) {
+	|| !afs_IsDCacheFresh(tdc, avc)) {
 	ReleaseReadLock(&tdc->lock);
 	ReleaseReadLock(&avc->lock);
 	afs_PutDCache(tdc);
@@ -952,4 +952,4 @@ afs_readdir(OSI_VC_DECL(avc), struct uio *auio, afs_ucred_t *acred)
     return code;
 }
 
-#endif /* !AFS_LINUX20_ENV */
+#endif /* !AFS_LINUX_ENV */
diff --git a/src/afs/VNOPS/afs_vnop_remove.c b/src/afs/VNOPS/afs_vnop_remove.c
index 33bc14218..9e0e86eb4 100644
--- a/src/afs/VNOPS/afs_vnop_remove.c
+++ b/src/afs/VNOPS/afs_vnop_remove.c
@@ -235,7 +235,7 @@ afs_remove(OSI_VC_DECL(adp), char *aname, afs_ucred_t *acred)
      * received a callback while we were waiting for the write lock.
      */
     if (!(adp->f.states & CStatd)
-	|| (tdc && !hsame(adp->f.m.DataVersion, tdc->f.versionNo))) {
+	|| (tdc && !afs_IsDCacheFresh(tdc, adp))) {
 	ReleaseWriteLock(&adp->lock);
 	if (tdc) {
 	    ReleaseSharedLock(&tdc->lock);
diff --git a/src/afs/VNOPS/afs_vnop_rename.c b/src/afs/VNOPS/afs_vnop_rename.c
index 2d4b9c185..fcf2bcb69 100644
--- a/src/afs/VNOPS/afs_vnop_rename.c
+++ b/src/afs/VNOPS/afs_vnop_rename.c
@@ -135,7 +135,7 @@ afsrename(struct vcache *aodp, char *aname1, struct vcache *andp,
      */
     if (tdc1) {
 	if (!(aodp->f.states & CStatd)
-	    || !hsame(aodp->f.m.DataVersion, tdc1->f.versionNo)) {
+	    || !afs_IsDCacheFresh(tdc1, aodp)) {
 
 	    ReleaseWriteLock(&aodp->lock);
 	    if (!oneDir) {
diff --git a/src/afs/VNOPS/afs_vnop_strategy.c b/src/afs/VNOPS/afs_vnop_strategy.c
index 978df8858..c4296bb6f 100644
--- a/src/afs/VNOPS/afs_vnop_strategy.c
+++ b/src/afs/VNOPS/afs_vnop_strategy.c
@@ -16,7 +16,7 @@
 #include "afs/param.h"
 
 
-#if !defined(AFS_HPUX_ENV) && !defined(AFS_SGI_ENV) && !defined(AFS_LINUX20_ENV) && !defined(AFS_DARWIN80_ENV)
+#if !defined(AFS_HPUX_ENV) && !defined(AFS_SGI_ENV) && !defined(AFS_LINUX_ENV) && !defined(AFS_DARWIN80_ENV)
 
 #include "afs/sysincludes.h"	/* Standard vendor system headers */
 #include "afsincludes.h"	/* Afs-based standard headers */
@@ -224,4 +224,4 @@ int afs_ustrategy(struct buf *abp)
     return code;
 }
 
-#endif /* !AFS_HPUX_ENV  && !AFS_SGI_ENV && !AFS_LINUX20_ENV */
+#endif /* !AFS_HPUX_ENV  && !AFS_SGI_ENV && !AFS_LINUX_ENV */
diff --git a/src/afs/VNOPS/afs_vnop_write.c b/src/afs/VNOPS/afs_vnop_write.c
index 32d69f4da..cf8e3345c 100644
--- a/src/afs/VNOPS/afs_vnop_write.c
+++ b/src/afs/VNOPS/afs_vnop_write.c
@@ -145,7 +145,7 @@ afs_UFSWriteUIO(struct vcache *avc, afs_dcache_id_t *inode, struct uio *tuiop)
 	code = VOP_RDWR(tfile->vnode, tuiop, UIO_WRITE, 0, afs_osi_credp);
 	AFS_GLOCK();
     }
-#elif defined(AFS_LINUX20_ENV)
+#elif defined(AFS_LINUX_ENV)
     AFS_GUNLOCK();
     code = osi_rdwr(tfile, tuiop, UIO_WRITE);
     AFS_GLOCK();
@@ -198,7 +198,6 @@ afs_write(struct vcache *avc, struct uio *auio, int aio,
 	     afs_ucred_t *acred, int noLock)
 {
     afs_size_t totalLength;
-    afs_size_t transferLength;
     afs_size_t filePos;
     afs_size_t offset, len;
     afs_int32 tlen;
@@ -232,7 +231,6 @@ afs_write(struct vcache *avc, struct uio *auio, int aio,
     totalLength = AFS_UIO_RESID(auio);
     filePos = AFS_UIO_OFFSET(auio);
     error = 0;
-    transferLength = 0;
     afs_Trace4(afs_iclSetp, CM_TRACE_WRITE, ICL_TYPE_POINTER, avc,
 	       ICL_TYPE_OFFSET, ICL_HANDLE_OFFSET(filePos), ICL_TYPE_OFFSET,
 	       ICL_HANDLE_OFFSET(totalLength), ICL_TYPE_OFFSET,
@@ -358,7 +356,6 @@ afs_write(struct vcache *avc, struct uio *auio, int aio,
 		tdc->validPos = filePos + len;
 	}
 	totalLength -= len;
-	transferLength += len;
 	filePos += len;
 #if defined(AFS_SGI_ENV)
 	/* afs_xwrite handles setting m.Length */
diff --git a/src/afs/afs.h b/src/afs/afs.h
index f436cc6c3..68eeadfd4 100644
--- a/src/afs/afs.h
+++ b/src/afs/afs.h
@@ -53,7 +53,7 @@ extern enum afs_shutdown_state afs_shuttingdown;
 # else
 #  define AFS_VFSFSID		99
 # endif
-#elif defined(AFS_SUN5_ENV) || defined(AFS_HPUX90_ENV) || defined(AFS_LINUX20_ENV)
+#elif defined(AFS_SUN5_ENV) || defined(AFS_HPUX90_ENV) || defined(AFS_LINUX_ENV)
 # define AFS_VFSFSID		99
 #elif defined(AFS_SGI_ENV)
 # define AFS_VFSFSID		afs_fstype
@@ -71,7 +71,7 @@ extern enum afs_shutdown_state afs_shuttingdown;
 #if     defined(AFS_HPUX102_ENV)
 #define AFS_FLOCK       k_flock
 #else
-#if     defined(AFS_SUN5_ENV) || (defined(AFS_LINUX24_ENV) && !(defined(AFS_LINUX26_ENV) && defined(AFS_LINUX_64BIT_KERNEL)))
+#if     defined(AFS_SUN5_ENV) || (defined(AFS_LINUX_ENV) && !defined(AFS_LINUX_64BIT_KERNEL))
 #define AFS_FLOCK       flock64
 #else
 #define AFS_FLOCK       flock
@@ -284,7 +284,7 @@ struct afs_cbr {
     struct AFSFid fid;
 };
 
-#ifdef AFS_LINUX22_ENV
+#ifdef AFS_LINUX_ENV
 /* On Linux, we have to be able to allocate the storage for this using
  * kmalloc, as otherwise we may deadlock. So, it needs to be able to fit
  * in a single page
@@ -738,7 +738,7 @@ struct SimpleLocks {
 #elif defined(AFS_XBSD_ENV) || defined(AFS_DARWIN_ENV)
 #define VREFCOUNT(v)          ((v)->vrefCount)
 #define VREFCOUNT_GT(v, y)    (AFSTOV(v)->v_usecount > (y))
-#elif defined(AFS_LINUX24_ENV)
+#elif defined(AFS_LINUX_ENV)
 #define VREFCOUNT(v)		atomic_read(&(AFSTOV(v)->v_count))
 #define VREFCOUNT_GT(v, y)      (VREFCOUNT(v)>y)
 #define VREFCOUNT_SET(v, c)	atomic_set(&(AFSTOV(v)->v_count), c)
@@ -773,10 +773,11 @@ struct nbvdata {
 };
 #define VTOAFS(v) ((((struct nbvdata *)((v)->v_data)))->afsvc)
 #define AFSTOV(vc) ((vc)->v)
-#elif defined(AFS_XBSD_ENV) || defined(AFS_DARWIN_ENV) || defined(AFS_SUN511_ENV) || (defined(AFS_LINUX22_ENV) && !defined(STRUCT_SUPER_OPERATIONS_HAS_ALLOC_INODE))
+#elif defined(AFS_XBSD_ENV) || defined(AFS_DARWIN_ENV) || defined(AFS_SUN511_ENV) || (defined(AFS_LINUX_ENV) && !defined(STRUCT_SUPER_OPERATIONS_HAS_ALLOC_INODE))
 #define VTOAFS(v) ((struct vcache *)(v)->v_data)
 #define AFSTOV(vc) ((vc)->v)
 #else
+#define AFS_VCACHE_EMBEDDED_VNODE
 #define VTOAFS(V) ((struct vcache *)(V))
 #define AFSTOV(V) (&(V)->v)
 #endif
@@ -847,13 +848,13 @@ struct multiPage_range {
  * !(avc->nextfree) && !avc->vlruq.next => (FreeVCList == avc->nextfree)
  */
 struct vcache {
-#if defined(AFS_XBSD_ENV) || defined(AFS_DARWIN_ENV) || defined(AFS_SUN511_ENV) || (defined(AFS_LINUX22_ENV) && !defined(STRUCT_SUPER_OPERATIONS_HAS_ALLOC_INODE))
-    struct vnode *v;
-#else
+#if defined(AFS_VCACHE_EMBEDDED_VNODE)
     struct vnode v;		/* Has reference count in v.v_count */
+#else
+    struct vnode *v;
 #endif
     struct afs_q vlruq;		/* lru q next and prev */
-#if !defined(AFS_LINUX22_ENV)
+#if !defined(AFS_LINUX_ENV)
     struct vcache *nextfree;	/* next on free list (if free) */
 #endif
     struct vcache *hnext;	/* Hash next */
@@ -931,7 +932,7 @@ struct vcache {
     char cachingStates;			/* Caching policies for this file */
     afs_uint32 cachingTransitions;		/* # of times file has flopped between caching and not */
 
-#if defined(AFS_LINUX24_ENV)
+#if defined(AFS_LINUX_ENV)
     off_t next_seq_offset;	/* Next sequential offset (used by prefetch/readahead) */
 #elif defined(AFS_SUN5_ENV) || defined(AFS_SGI65_ENV)
     off_t next_seq_blk_offset; /* accounted in blocks for Solaris & IRIX */
@@ -958,10 +959,10 @@ struct vcache {
     struct bhv_desc vc_bhv_desc;	/* vnode's behavior data. */
 #endif
 #endif				/* AFS_SGI_ENV */
-#if defined(AFS_LINUX26_ENV)
+#if defined(AFS_LINUX_ENV)
     cred_t *cred;		/* last writer's cred */
 #endif
-#ifdef AFS_LINUX24_ENV
+#ifdef AFS_LINUX_ENV
     struct dentry *target_link; /* dentry we prefer, when we are redirecting
                                  * all requests due to duplicate dentry aliases.
                                  * See LINUX/osi_vnodeops.c. Note that this is
@@ -980,13 +981,13 @@ struct vcache {
     void *vpacRock;		/* used to read or write in visible partitions */
 #endif
     afs_uint32 lastBRLWarnTime; /* last time we warned about byte-range locks */
-#ifdef AFS_LINUX26_ENV
+#ifdef AFS_LINUX_ENV
     spinlock_t pagewriter_lock;
     struct list_head pagewriters;	/* threads that are writing vm pages */
 #endif
 };
 
-#ifdef AFS_LINUX26_ENV
+#ifdef AFS_LINUX_ENV
 struct pagewriter {
     struct list_head link;
     pid_t writer;
@@ -1191,7 +1192,7 @@ typedef char *afs_ufs_dcache_id_t;
  * the size correctly.
  */
 typedef ino64_t afs_ufs_dcache_id_t;
-#elif defined(AFS_LINUX26_ENV)
+#elif defined(AFS_LINUX_ENV)
 #define MAX_FH_LEN 10
 typedef union {
 #if defined(NEW_EXPORT_OPS)
@@ -1201,7 +1202,7 @@ typedef union {
 } afs_ufs_dcache_id_t;
 extern int cache_fh_type;
 extern int cache_fh_len;
-#elif defined(AFS_LINUX_64BIT_KERNEL) && !defined(AFS_S390X_LINUX24_ENV)
+#elif defined(AFS_LINUX_64BIT_KERNEL) && !defined(AFS_S390X_LINUX_ENV)
 typedef long afs_ufs_dcache_id_t;
 #elif defined(AFS_AIX51_ENV) || defined(AFS_HPUX1123_ENV)
 typedef ino_t afs_ufs_dcache_id_t;
@@ -1552,7 +1553,7 @@ extern int afsd_dynamic_vcaches;
 #elif defined (AFS_DARWIN110_ENV)
 #define afs_cr_uid(cred) kauth_cred_getuid((kauth_cred_t)(cred))
 #define afs_cr_gid(cred) kauth_cred_getgid((kauth_cred_t)(cred))
-#elif !(defined(AFS_LINUX26_ENV) && defined(STRUCT_TASK_STRUCT_HAS_CRED))
+#elif !(defined(AFS_LINUX_ENV) && defined(STRUCT_TASK_STRUCT_HAS_CRED))
 #define afs_cr_uid(cred) ((cred)->cr_uid)
 #define afs_cr_gid(cred) ((cred)->cr_gid)
 #if !defined(AFS_OBSD_ENV)
@@ -1624,7 +1625,7 @@ typedef struct afs_event {
     /* no cond member */
 #elif defined(AFS_FBSD_ENV) || defined(AFS_OBSD_ENV)
     int cond;			/* "all this gluck should probably be replaced by CVs" */
-#elif defined(AFS_LINUX24_ENV)
+#elif defined(AFS_LINUX_ENV)
     wait_queue_head_t cond;
 #elif defined(AFS_NBSD_ENV) || defined(AFS_SUN5_ENV) || defined(AFS_SGI_ENV)
     kcondvar_t cond;		/* Currently associated condition variable */
diff --git a/src/afs/afs_analyze.c b/src/afs/afs_analyze.c
index 4bb212ba6..188d36e81 100644
--- a/src/afs/afs_analyze.c
+++ b/src/afs/afs_analyze.c
@@ -18,7 +18,7 @@
 #include "afs/sysincludes.h"	/* Standard vendor system headers */
 
 #ifndef UKERNEL
-#if !defined(AFS_LINUX20_ENV) && !defined(AFS_FBSD_ENV)
+#if !defined(AFS_LINUX_ENV) && !defined(AFS_FBSD_ENV)
 #include <net/if.h>
 #include <netinet/in.h>
 #endif
@@ -26,7 +26,7 @@
 #ifdef AFS_SGI62_ENV
 #include "h/hashing.h"
 #endif
-#if !defined(AFS_HPUX110_ENV) && !defined(AFS_LINUX20_ENV) && !defined(AFS_FBSD_ENV) && !defined(AFS_DARWIN_ENV)
+#if !defined(AFS_HPUX110_ENV) && !defined(AFS_LINUX_ENV) && !defined(AFS_FBSD_ENV) && !defined(AFS_DARWIN_ENV)
 #include <netinet/in_var.h>
 #endif
 #endif /* !UKERNEL */
diff --git a/src/afs/afs_buffer.c b/src/afs/afs_buffer.c
index 55a456488..11f181991 100644
--- a/src/afs/afs_buffer.c
+++ b/src/afs/afs_buffer.c
@@ -14,7 +14,7 @@
 #include "afs/sysincludes.h"
 #include "afsincludes.h"
 #if !defined(UKERNEL)
-#if !defined(AFS_LINUX26_ENV)
+#if !defined(AFS_LINUX_ENV)
 # include "h/param.h"
 #endif
 #include "h/types.h"
@@ -22,7 +22,7 @@
 #if	defined(AFS_AIX31_ENV)
 #include "h/limits.h"
 #endif
-#if	!defined(AFS_AIX_ENV) && !defined(AFS_SUN5_ENV) && !defined(AFS_SGI_ENV) && !defined(AFS_LINUX20_ENV)
+#if	!defined(AFS_AIX_ENV) && !defined(AFS_SUN5_ENV) && !defined(AFS_SGI_ENV) && !defined(AFS_LINUX_ENV)
 #include "h/kernel.h"		/* Doesn't needed, so it should go */
 #endif
 #endif /* !defined(UKERNEL) */
@@ -31,7 +31,7 @@
 #include "afsint.h"
 #include "afs/lock.h"
 
-#if !defined(UKERNEL) && !defined(AFS_LINUX20_ENV)
+#if !defined(UKERNEL) && !defined(AFS_LINUX_ENV)
 #include "h/buf.h"
 #endif /* !defined(UKERNEL) */
 
diff --git a/src/afs/afs_bypasscache.c b/src/afs/afs_bypasscache.c
index 64da1ed19..c716060dd 100644
--- a/src/afs/afs_bypasscache.c
+++ b/src/afs/afs_bypasscache.c
@@ -114,6 +114,86 @@ int cache_bypass_prefetch = 1;	/* Should we do prefetching ? */
 
 extern afs_rwlock_t afs_xcbhash;
 
+/*
+ * Allocate and initialize nocache_read_request/uid/iovec.
+ * Returns NULL if there was a memory allocation error.
+ * Note: UKERNEL always passes 0 for the number of pages since the iovec
+ * and the uio are allocated by the caller
+ */
+struct nocache_read_request *
+afs_alloc_ncr(unsigned num_pages)
+{
+    struct nocache_read_request *ancr = NULL;
+#if !defined(UKERNEL)
+    struct uio *auio = NULL;
+    struct iovec *iovecp = NULL;
+#endif
+
+    ancr = osi_Alloc(sizeof(*ancr));
+    if (ancr == NULL)
+	goto error;
+
+#if defined(UKERNEL)
+    osi_Assert(num_pages == 0);
+#else
+    iovecp = osi_Alloc(num_pages * sizeof(*iovecp));
+    if (iovecp == NULL)
+	goto error;
+
+    auio = osi_Alloc(sizeof(*auio));
+    if (auio == NULL)
+	goto error;
+    auio->uio_iov = iovecp;
+    auio->uio_iovcnt = num_pages;
+    auio->uio_flag = UIO_READ;
+    auio->uio_seg = AFS_UIOSYS;
+    auio->uio_offset = 0;
+    auio->uio_resid = num_pages * PAGE_SIZE;
+
+    ancr->auio = auio;
+    ancr->offset = auio->uio_offset;
+    ancr->length = auio->uio_resid;
+#endif
+
+    return ancr;
+
+ error:
+#if !defined(UKERNEL)
+    osi_Free(iovecp, num_pages * sizeof(*iovecp));
+    osi_Free(auio, sizeof(*auio));
+#endif
+    osi_Free(ancr, sizeof(*ancr));
+    return NULL;
+}
+
+/*
+ * Free a nocache_read_request and associated structures
+ * Note: UKERNEL the iovec and uio structures are managed by the caller
+ */
+void
+afs_free_ncr(struct nocache_read_request **a_ancr)
+{
+    struct nocache_read_request *ancr = *a_ancr;
+#if !defined(UKERNEL)
+    struct uio *auio;
+    struct iovec *aiovec;
+#endif
+
+    if (ancr == NULL)
+	return;
+
+#if !defined(UKERNEL)
+    auio = ancr->auio;
+    if (auio != NULL) {
+	aiovec = auio->uio_iov;
+	osi_Free(aiovec, auio->uio_iovcnt * sizeof(*aiovec));
+    }
+    osi_Free(auio, sizeof(*auio));
+#endif
+    osi_Free(ancr, sizeof(*ancr));
+    *a_ancr = NULL;
+}
+
 /*
  * This is almost exactly like the PFlush() routine in afs_pioctl.c,
  * but that routine is static.  We are about to change a file from
@@ -519,10 +599,7 @@ cleanup:
     AFS_GLOCK();
     afs_DestroyReq(areq);
     AFS_GUNLOCK();
-    osi_Free(bparms->auio->uio_iov,
-	     bparms->auio->uio_iovcnt * sizeof(struct iovec));
-    osi_Free(bparms->auio, sizeof(struct uio));
-    osi_Free(bparms, sizeof(struct nocache_read_request));
+    afs_free_ncr(&bparms);
     return code;
 }
 
@@ -649,12 +726,7 @@ done:
 
     afs_DestroyReq(areq);
     osi_Free(tcallspec, sizeof(struct tlocal1));
-    osi_Free(bparms, sizeof(struct nocache_read_request));
-#ifndef UKERNEL
-    /* in UKERNEL, the "pages" are passed in */
-    osi_Free(iovecp, auio->uio_iovcnt * sizeof(struct iovec));
-    osi_Free(auio, sizeof(struct uio));
-#endif
+    afs_free_ncr(&bparms);
     return code;
 }
 #endif
diff --git a/src/afs/afs_bypasscache.h b/src/afs/afs_bypasscache.h
index 37c5669b3..11f5464c8 100644
--- a/src/afs/afs_bypasscache.h
+++ b/src/afs/afs_bypasscache.h
@@ -84,7 +84,7 @@ struct nocache_read_request {
     u_offset_t offset;
     struct seg *segment;
     caddr_t address;
-#elif defined(AFS_LINUX24_ENV) || defined(UKERNEL)
+#elif defined(AFS_LINUX_ENV) || defined(UKERNEL)
     /* The tested platform, as CITI impl. just packs ab->parms */
     struct uio *auio;
     struct vrequest *areq;
@@ -103,7 +103,8 @@ enum cache_bypass_strategies
 extern int cache_bypass_prefetch;
 extern int cache_bypass_strategy;
 extern afs_size_t cache_bypass_threshold;
-
+struct nocache_read_request *afs_alloc_ncr(unsigned num_pages);
+void afs_free_ncr(struct nocache_read_request **ancr);
 void afs_TransitionToBypass(struct vcache *, afs_ucred_t *, int);
 void afs_TransitionToCaching(struct vcache *, afs_ucred_t *, int);
 
diff --git a/src/afs/afs_call.c b/src/afs/afs_call.c
index 32ad210c4..e75cce7c8 100644
--- a/src/afs/afs_call.c
+++ b/src/afs/afs_call.c
@@ -19,7 +19,9 @@
 #include "afs/afs_stats.h"
 #include "rx/rx_globals.h"
 #if !defined(UKERNEL)
-# if !defined(AFS_LINUX20_ENV)
+# if defined(AFS_LINUX_ENV)
+#  include "osi_compat.h"
+# else
 #  include "net/if.h"
 #  ifdef AFS_SGI62_ENV
 #   include "h/hashing.h"
@@ -41,7 +43,7 @@
 #define	AFS_MINBUFFERS	50
 #endif
 
-#if (defined(AFS_SUN5_ENV) || defined(AFS_LINUX26_ENV) || defined(AFS_DARWIN80_ENV)) && !defined(UKERNEL)
+#if (defined(AFS_SUN5_ENV) || defined(AFS_LINUX_ENV) || defined(AFS_DARWIN80_ENV)) && !defined(UKERNEL)
 /* If AFS_DAEMONOP_ENV is defined, it indicates we run "daemon" AFS syscalls by
  * spawning a kernel thread to do the work, instead of running them in the
  * calling process. */
@@ -281,7 +283,7 @@ afs_DaemonOp(long parm, long parm2, long parm3, long parm4, long parm5,
 #endif
 
 
-#if defined(AFS_LINUX26_ENV)
+#if defined(AFS_LINUX_ENV)
 struct afsd_thread_info {
 # if !defined(INIT_WORK_HAS_DATA)
     struct work_struct tq;
@@ -299,7 +301,7 @@ afsd_thread(void *rock)
     int (*sys_setpriority) (int, int, int) = sys_call_table[__NR_setpriority];
 # endif
 # if !defined(HAVE_LINUX_KTHREAD_RUN)
-#  if defined(AFS_LINUX26_ENV)
+#  if defined(AFS_LINUX_ENV)
     daemonize("afsd");
 #  else
     daemonize();
@@ -308,7 +310,7 @@ afsd_thread(void *rock)
 				/* doesn't do much, since we were forked from keventd, but
 				 * does call mm_release, which wakes up our parent (since it
 				 * used CLONE_VFORK) */
-# if !defined(AFS_LINUX26_ENV)
+# if !defined(AFS_LINUX_ENV)
     reparent_to_init();
 # endif
     afs_osi_MaskSignals();
@@ -328,7 +330,7 @@ afsd_thread(void *rock)
 	sprintf(current->comm, "afs_callback");
 	afs_RXCallBackServer();
 	AFS_GUNLOCK();
-	complete_and_exit(0, 0);
+	kthread_complete_and_exit(0, 0);
 	break;
     case AFSOP_START_AFS:
 	sprintf(current->comm, "afs_afsstart");
@@ -342,7 +344,7 @@ afsd_thread(void *rock)
 	sprintf(current->comm, "afsd");
 	afs_Daemon();
 	AFS_GUNLOCK();
-	complete_and_exit(0, 0);
+	kthread_complete_and_exit(0, 0);
 	break;
     case AFSOP_START_BKG:
 #ifdef AFS_NEW_BKG
@@ -361,7 +363,7 @@ afsd_thread(void *rock)
 	afs_BackgroundDaemon();
 	AFS_GUNLOCK();
 #endif
-	complete_and_exit(0, 0);
+	kthread_complete_and_exit(0, 0);
 	break;
     case AFSOP_START_TRUNCDAEMON:
 	sprintf(current->comm, "afs_trimstart");
@@ -372,7 +374,7 @@ afsd_thread(void *rock)
 	sprintf(current->comm, "afs_cachetrim");
 	afs_CacheTruncateDaemon();
 	AFS_GUNLOCK();
-	complete_and_exit(0, 0);
+	kthread_complete_and_exit(0, 0);
 	break;
     case AFSOP_START_CS:
 	sprintf(current->comm, "afs_checkserver");
@@ -380,7 +382,7 @@ afsd_thread(void *rock)
 	complete(arg->complete);
 	afs_CheckServerDaemon();
 	AFS_GUNLOCK();
-	complete_and_exit(0, 0);
+	kthread_complete_and_exit(0, 0);
 	break;
     case AFSOP_RXEVENT_DAEMON:
 	sprintf(current->comm, "afs_evtstart");
@@ -398,7 +400,7 @@ afsd_thread(void *rock)
 	sprintf(current->comm, "afs_rxevent");
 	afs_rxevent_daemon();
 	AFS_GUNLOCK();
-	complete_and_exit(0, 0);
+	kthread_complete_and_exit(0, 0);
 	break;
 #ifdef RXK_LISTENER_ENV
     case AFSOP_RXLISTENER_DAEMON:
@@ -420,7 +422,7 @@ afsd_thread(void *rock)
 	sprintf(current->comm, "afs_rxlistener");
 	rxk_Listener();
 	AFS_GUNLOCK();
-	complete_and_exit(0, 0);
+	kthread_complete_and_exit(0, 0);
 	break;
 #endif
     default:
@@ -431,13 +433,13 @@ afsd_thread(void *rock)
 }
 
 void
-# if defined(AFS_LINUX26_ENV) && !defined(INIT_WORK_HAS_DATA)
+# if defined(AFS_LINUX_ENV) && !defined(INIT_WORK_HAS_DATA)
 afsd_launcher(struct work_struct *work)
 # else
 afsd_launcher(void *rock)
 # endif
 {
-# if defined(AFS_LINUX26_ENV) && !defined(INIT_WORK_HAS_DATA)
+# if defined(AFS_LINUX_ENV) && !defined(INIT_WORK_HAS_DATA)
     struct afsd_thread_info *rock = container_of(work, struct afsd_thread_info, tq);
 # endif
 
@@ -456,7 +458,7 @@ afs_DaemonOp(long parm, long parm2, long parm3, long parm4, long parm5,
 	     long parm6)
 {
     DECLARE_COMPLETION(c);
-# if defined(AFS_LINUX26_ENV)
+# if defined(AFS_LINUX_ENV)
 #  if defined(INIT_WORK_HAS_DATA)
     struct work_struct tq;
 #  endif
@@ -469,7 +471,7 @@ afs_DaemonOp(long parm, long parm2, long parm3, long parm4, long parm5,
     }
     info.complete = &c;
     info.parm = parm;
-# if defined(AFS_LINUX26_ENV)
+# if defined(AFS_LINUX_ENV)
 #  if !defined(INIT_WORK_HAS_DATA)
     INIT_WORK(&info.tq, afsd_launcher);
     schedule_work(&info.tq);
@@ -1120,7 +1122,7 @@ afs_syscall_call(long parm, long parm2, long parm3,
 	while (!afs_InitSetup_done)
 	    afs_osi_Sleep(&afs_InitSetup_done);
 
-#if defined(AFS_SGI_ENV) || defined(AFS_HPUX_ENV) || defined(AFS_LINUX20_ENV) || defined(AFS_DARWIN_ENV) || defined(AFS_XBSD_ENV) || defined(AFS_SUN5_ENV)
+#if defined(AFS_SGI_ENV) || defined(AFS_HPUX_ENV) || defined(AFS_LINUX_ENV) || defined(AFS_DARWIN_ENV) || defined(AFS_XBSD_ENV) || defined(AFS_SUN5_ENV)
 	temp = AFS_MINBUFFERS;	/* Should fix this soon */
 #else
 	/* number of 2k buffers we could get from all of the buffer space */
@@ -1456,12 +1458,10 @@ afs_syscall_call(long parm, long parm2, long parm3,
 	if (afs_globalVFS != 0) {
 	    afs_warn("AFS isn't unmounted yet! Call aborted\n");
 	    code = EACCES;
+	} else if (parm2 == AFS_COLD) {
+	    afs_shutdown(AFS_COLD);
 	} else {
-	    afs_cold_shutdown = 0;
-	    if (parm2 == 1) {
-		afs_cold_shutdown = 1;
-	    }
-	    afs_shutdown();
+	    afs_shutdown(AFS_WARM);
 	}
     } else if (parm == AFSOP_AFS_VFSMOUNT) {
 #ifdef	AFS_HPUX_ENV
@@ -1477,7 +1477,7 @@ afs_syscall_call(long parm, long parm2, long parm3,
 	afs_SynchronousCloses = 'S';
     } else if (parm == AFSOP_GETMTU) {
 	afs_uint32 mtu = 0;
-#if	!defined(AFS_SUN5_ENV) && !defined(AFS_LINUX20_ENV)
+#if	!defined(AFS_SUN5_ENV) && !defined(AFS_LINUX_ENV)
 # ifdef AFS_USERSPACE_IP_ADDR
 	afs_int32 i;
 	i = rxi_Findcbi(parm2);
@@ -1610,7 +1610,7 @@ afs_syscall_call(long parm, long parm2, long parm3,
 
   out:
     AFS_GUNLOCK();
-#ifdef AFS_LINUX20_ENV
+#ifdef AFS_LINUX_ENV
     return -code;
 #else
     return code;
@@ -1645,7 +1645,7 @@ afs_CheckInit(void)
 
 enum afs_shutdown_state afs_shuttingdown = AFS_RUNNING;
 void
-afs_shutdown(void)
+afs_shutdown(enum afs_shutdown_type cold_flag)
 {
     extern short afs_brsDaemons;
     extern afs_int32 afs_CheckServerDaemonStarted;
@@ -1661,6 +1661,8 @@ afs_shutdown(void)
     if (afs_shuttingdown != AFS_RUNNING)
 	return;
 
+    afs_cold_shutdown = ((cold_flag == AFS_COLD) ? 1 : 0);
+
     afs_shuttingdown = AFS_FLUSHING_CB;
 
     /* Give up all of our callbacks if we can. */
diff --git a/src/afs/afs_callback.c b/src/afs/afs_callback.c
index c18634733..b441abc4b 100644
--- a/src/afs/afs_callback.c
+++ b/src/afs/afs_callback.c
@@ -66,7 +66,7 @@ static struct ltable {
 };
 unsigned long lastCallBack_vnode;
 unsigned int lastCallBack_dv;
-osi_timeval_t lastCallBack_time;
+osi_timeval32_t lastCallBack_time;
 
 /* these are for storing alternate interface addresses */
 struct interfaceAddr afs_cb_interface;
diff --git a/src/afs/afs_cbqueue.c b/src/afs/afs_cbqueue.c
index 85b3247b7..2dd633588 100644
--- a/src/afs/afs_cbqueue.c
+++ b/src/afs/afs_cbqueue.c
@@ -178,7 +178,7 @@ afs_DequeueCallback(struct vcache *avc)
  */
 
 /* Sanity check on the callback queue. Allow for slop in the computation. */
-#if defined(AFS_LINUX22_ENV)
+#if defined(AFS_LINUX_ENV)
 #define CBQ_LIMIT (afs_maxvcount + 10)
 #else
 #define CBQ_LIMIT (afs_cacheStats + afs_stats_cmperf.vcacheXAllocs + 10)
diff --git a/src/afs/afs_conn.c b/src/afs/afs_conn.c
index 92d36af94..3b9b183b1 100644
--- a/src/afs/afs_conn.c
+++ b/src/afs/afs_conn.c
@@ -18,7 +18,7 @@
 #include "afs/sysincludes.h"	/* Standard vendor system headers */
 
 #if !defined(UKERNEL)
-#if !defined(AFS_LINUX20_ENV)
+#if !defined(AFS_LINUX_ENV)
 #include <net/if.h>
 #endif
 #include <netinet/in.h>
@@ -26,7 +26,7 @@
 #ifdef AFS_SGI62_ENV
 #include "h/hashing.h"
 #endif
-#if !defined(AFS_HPUX110_ENV) && !defined(AFS_LINUX20_ENV) && !defined(AFS_DARWIN_ENV)
+#if !defined(AFS_HPUX110_ENV) && !defined(AFS_LINUX_ENV) && !defined(AFS_DARWIN_ENV)
 #include <netinet/in_var.h>
 #endif /* ! AFS_HPUX110_ENV */
 #endif /* !defined(UKERNEL) */
diff --git a/src/afs/afs_daemons.c b/src/afs/afs_daemons.c
index cca6032f9..f84d94c64 100644
--- a/src/afs/afs_daemons.c
+++ b/src/afs/afs_daemons.c
@@ -348,7 +348,7 @@ afs_CheckRootVolume(void)
 		 * count to zero and fs checkv is executed when the current
 		 * directory is /afs.
 		 */
-#ifdef AFS_LINUX22_ENV
+#ifdef AFS_LINUX_ENV
 		osi_ResetRootVCache(volid);
 #else
 # ifdef AFS_DARWIN80_ENV
@@ -382,7 +382,7 @@ BPath(struct brequest *ab)
     struct dcache *tdc = NULL;
     struct vcache *tvc = NULL;
     struct vnode *tvn = NULL;
-#ifdef AFS_LINUX22_ENV
+#ifdef AFS_LINUX_ENV
     struct dentry *dp = NULL;
 #endif
     afs_size_t offset, len;
@@ -394,7 +394,7 @@ BPath(struct brequest *ab)
 	return;
     }
     AFS_GUNLOCK();
-#ifdef AFS_LINUX22_ENV
+#ifdef AFS_LINUX_ENV
     code = gop_lookupname((char *)ab->ptr_parm[0], AFS_UIOSYS, 1, &dp);
     if (dp)
 	tvn = (struct vnode *)dp->d_inode;
@@ -411,7 +411,7 @@ BPath(struct brequest *ab)
     if (!tvn || !IsAfsVnode(tvn)) {
 	/* release it and give up */
 	if (tvn) {
-#ifdef AFS_LINUX22_ENV
+#ifdef AFS_LINUX_ENV
 	    dput(dp);
 #else
 	    AFS_RELE(tvn);
@@ -426,7 +426,7 @@ BPath(struct brequest *ab)
     if (tdc) {
 	afs_PutDCache(tdc);
     }
-#ifdef AFS_LINUX22_ENV
+#ifdef AFS_LINUX_ENV
     dput(dp);
 #else
     AFS_RELE(tvn);
diff --git a/src/afs/afs_dcache.c b/src/afs/afs_dcache.c
index 6a18f80d5..f298e48ef 100644
--- a/src/afs/afs_dcache.c
+++ b/src/afs/afs_dcache.c
@@ -429,10 +429,10 @@ afs_MaybeWaitForCacheDrain(void)
  * struct so we need only export one symbol for AIX.
  */
 static struct CTD_stats {
-    osi_timeval_t CTD_beforeSleep;
-    osi_timeval_t CTD_afterSleep;
-    osi_timeval_t CTD_sleepTime;
-    osi_timeval_t CTD_runTime;
+    osi_timeval32_t CTD_beforeSleep;
+    osi_timeval32_t CTD_afterSleep;
+    osi_timeval32_t CTD_sleepTime;
+    osi_timeval32_t CTD_runTime;
     int CTD_nSleeps;
 } CTD_stats;
 
@@ -467,7 +467,7 @@ afs_WakeCacheWaitersIfDrained(void)
 void
 afs_CacheTruncateDaemon(void)
 {
-    osi_timeval_t CTD_tmpTime;
+    osi_timeval32_t CTD_tmpTime;
     u_int counter;
     u_int cb_lowat;
     u_int dc_hiwat =
@@ -1734,6 +1734,24 @@ afs_AllocDCache(struct vcache *avc, afs_int32 chunk, afs_int32 lock,
     return tdc;
 }
 
+/*!
+ * Check if a dcache is "fresh". That is, if the dcache's DV matches the DV of
+ * the vcache for that file.
+ *
+ * \param adc The dcache to check
+ * \param avc The vcache for adc
+ *
+ * \return 1 if the dcache does match avc's DV; 0 otherwise.
+ */
+int
+afs_IsDCacheFresh(struct dcache *adc, struct vcache *avc)
+{
+    if (!hsame(adc->f.versionNo, avc->f.m.DataVersion)) {
+	return 0;
+    }
+    return 1;
+}
+
 /*
  * afs_GetDCache
  *
@@ -1772,7 +1790,7 @@ void
 updateV2DC(int lockVc, struct vcache *v, struct dcache *d, int src)
 {
     if (!lockVc || 0 == NBObtainWriteLock(&v->lock, src)) {
-	if (hsame(v->f.m.DataVersion, d->f.versionNo) && v->callback)
+	if (afs_IsDCacheFresh(d, v) && v->callback)
 	    v->dchint = d;
 	if (lockVc)
 	    ReleaseWriteLock(&v->lock);
@@ -1882,7 +1900,7 @@ afs_GetDCache(struct vcache *avc, afs_size_t abyte,
 	    ReleaseReadLock(&afs_xdcache);
 	    shortcut = 1;
 
-	    if (hsame(tdc->f.versionNo, avc->f.m.DataVersion)
+	    if (afs_IsDCacheFresh(tdc, avc)
 		&& !(tdc->dflags & DFFetching)) {
 
 		afs_stats_cmperf.dcacheHits++;
@@ -2119,7 +2137,7 @@ afs_GetDCache(struct vcache *avc, afs_size_t abyte,
 	if (AFS_CHUNKTOBASE(chunk) >= avc->f.m.Length &&
 #endif
 #endif /* defined(AFS_AIX32_ENV) || defined(AFS_SGI_ENV) */
-	    !hsame(avc->f.m.DataVersion, tdc->f.versionNo))
+	    !afs_IsDCacheFresh(tdc, avc))
 	    doReallyAdjustSize = 1;
 
 	if (doReallyAdjustSize || overWriteWholeChunk) {
@@ -2183,7 +2201,7 @@ afs_GetDCache(struct vcache *avc, afs_size_t abyte,
      * avc->lock(W) if !setLocks || slowPass
      * tdc->lock(S)
      */
-    if (!hsame(avc->f.m.DataVersion, tdc->f.versionNo) && !overWriteWholeChunk) {
+    if (!afs_IsDCacheFresh(tdc, avc) && !overWriteWholeChunk) {
 	/*
 	 * Version number mismatch.
 	 */
@@ -2253,7 +2271,7 @@ afs_GetDCache(struct vcache *avc, afs_size_t abyte,
 	 */
 
 	/* Watch for standard race condition around osi_FlushText */
-	if (hsame(avc->f.m.DataVersion, tdc->f.versionNo)) {
+	if (afs_IsDCacheFresh(tdc, avc)) {
 	    updateV2DC(setLocks, avc, tdc, 569);	/* set hint */
 	    afs_stats_cmperf.dcacheHits++;
 	    ConvertWToSLock(&tdc->lock);
@@ -3235,7 +3253,7 @@ afs_InitCacheFile(char *afile, ino_t ainode)
 	    }
 	} else {
 	    /* Add any other 'complex' inode types here ... */
-#if !defined(AFS_LINUX26_ENV) && !defined(AFS_CACHE_VNODE_PATH)
+#if !defined(AFS_LINUX_ENV) && !defined(AFS_CACHE_VNODE_PATH)
 	    tdc->f.inode.ufs = ainode;
 #else
 	    osi_Panic("Can't init cache with inode numbers when complex inodes are "
@@ -3592,7 +3610,7 @@ afs_ObtainDCacheForWriting(struct vcache *avc, afs_size_t filePos,
 	tdc = afs_FindDCache(avc, filePos);
 	if (tdc) {
 	    ObtainWriteLock(&tdc->lock, 658);
-	    if (!hsame(tdc->f.versionNo, avc->f.m.DataVersion)
+	    if (!afs_IsDCacheFresh(tdc, avc)
 		|| (tdc->dflags & DFFetching)) {
 		ReleaseWriteLock(&tdc->lock);
 		afs_PutDCache(tdc);
diff --git a/src/afs/afs_error.c b/src/afs/afs_error.c
index dd346a0b8..5f31c6020 100644
--- a/src/afs/afs_error.c
+++ b/src/afs/afs_error.c
@@ -18,7 +18,7 @@
 #include "afs/sysincludes.h"	/* Standard vendor system headers */
 
 #ifndef UKERNEL
-#if !defined(AFS_LINUX20_ENV) && !defined(AFS_FBSD_ENV)
+#if !defined(AFS_LINUX_ENV) && !defined(AFS_FBSD_ENV)
 #include <net/if.h>
 #include <netinet/in.h>
 #endif
@@ -26,7 +26,7 @@
 #ifdef AFS_SGI62_ENV
 #include "h/hashing.h"
 #endif
-#if !defined(AFS_HPUX110_ENV) && !defined(AFS_LINUX20_ENV) && !defined(AFS_FBSD_ENV) && !defined(AFS_DARWIN_ENV)
+#if !defined(AFS_HPUX110_ENV) && !defined(AFS_LINUX_ENV) && !defined(AFS_FBSD_ENV) && !defined(AFS_DARWIN_ENV)
 #include <netinet/in_var.h>
 #endif
 #endif /* !UKERNEL */
diff --git a/src/afs/afs_fetchstore.c b/src/afs/afs_fetchstore.c
index 501061a9a..7b35b8f7f 100644
--- a/src/afs/afs_fetchstore.c
+++ b/src/afs/afs_fetchstore.c
@@ -25,12 +25,12 @@ extern int cacheDiskType;
 
 #ifndef AFS_NOSTATS
 static void
-FillStoreStats(int code, int idx, osi_timeval_t xferStartTime,
+FillStoreStats(int code, int idx, osi_timeval32_t xferStartTime,
 	       afs_size_t bytesToXfer, afs_size_t bytesXferred)
 {
     struct afs_stats_xferData *xferP;
-    osi_timeval_t xferStopTime;
-    osi_timeval_t elapsedTime;
+    osi_timeval32_t xferStopTime;
+    osi_timeval32_t elapsedTime;
 
     xferP = &(afs_stats_cmfullperf.rpc.fsXferTimes[idx]);
     osi_GetuTime(&xferStopTime);
@@ -450,7 +450,7 @@ afs_CacheStoreDCaches(struct vcache *avc, struct dcache **dclist,
     afs_size_t bytesXferred;
 
 #ifndef AFS_NOSTATS
-    osi_timeval_t xferStartTime;	/*FS xfer start time */
+    osi_timeval32_t xferStartTime;	/*FS xfer start time */
     afs_size_t bytesToXfer = 10000;	/* # bytes to xfer */
 #endif /* AFS_NOSTATS */
     XSTATS_DECLS;
@@ -1116,7 +1116,7 @@ afs_CacheFetchProc(struct afs_conn *tc, struct rx_connection *rxconn,
 
     XSTATS_DECLS;
 #ifndef AFS_NOSTATS
-    osi_timeval_t xferStartTime;	/*FS xfer start time */
+    osi_timeval32_t xferStartTime;	/*FS xfer start time */
     afs_size_t bytesToXfer = 0, bytesXferred = 0;
 #endif
 
diff --git a/src/afs/afs_icl.c b/src/afs/afs_icl.c
index 558d42a4a..ed5474d7d 100644
--- a/src/afs/afs_icl.c
+++ b/src/afs/afs_icl.c
@@ -15,7 +15,7 @@
 #include "afsincludes.h"	/* Afs-based standard headers */
 #include "afs/afs_stats.h"
 #include "rx/rx_globals.h"
-#if !defined(UKERNEL) && !defined(AFS_LINUX20_ENV)
+#if !defined(UKERNEL) && !defined(AFS_LINUX_ENV)
 #include "net/if.h"
 #ifdef AFS_SGI62_ENV
 #include "h/hashing.h"
@@ -614,7 +614,7 @@ afs_icl_AppendRecord(struct afs_icl_log *logp, afs_int32 op,
 {
     int rsize;			/* record size in longs */
     int tsize;		/* temp size */
-    osi_timeval_t tv;
+    osi_timeval32_t tv;
     int t1, t2, t3, t4;
 
     t4 = types & 0x3f;		/* decode types */
diff --git a/src/afs/afs_init.c b/src/afs/afs_init.c
index 21b1ea4ea..364b91642 100644
--- a/src/afs/afs_init.c
+++ b/src/afs/afs_init.c
@@ -22,7 +22,7 @@
 #include "afsincludes.h"	/* Afs-based standard headers */
 #include "afs/afs_stats.h"	/* afs statistics */
 #include "rx/rxstat.h"
-#if defined(AFS_LINUX26_ENV) && defined(STRUCT_TASK_STRUCT_HAS_CRED)
+#if defined(AFS_LINUX_ENV) && defined(STRUCT_TASK_STRUCT_HAS_CRED)
 # include <linux/cred.h>
 #endif
 
@@ -34,7 +34,7 @@ struct osi_dev cacheDev;	/*Cache device */
 afs_int32 cacheInfoModTime;	/*Last time cache info modified */
 #if defined(AFS_DARWIN_ENV) || defined(AFS_FBSD_ENV) || defined(AFS_NBSD_ENV)
 struct mount *afs_cacheVfsp = 0;
-#elif defined(AFS_LINUX20_ENV)
+#elif defined(AFS_LINUX_ENV)
 struct super_block *afs_cacheSBp = 0;
 #else
 struct vfs *afs_cacheVfsp = 0;
@@ -52,7 +52,7 @@ static struct vnode *volumeVnode;
 #endif
 afs_rwlock_t afs_discon_lock;
 extern afs_rwlock_t afs_disconDirtyLock;
-#if defined(AFS_LINUX26_ENV) && defined(STRUCT_TASK_STRUCT_HAS_CRED)
+#if defined(AFS_LINUX_ENV) && defined(STRUCT_TASK_STRUCT_HAS_CRED)
 const struct cred *cache_creds;
 #endif
 
@@ -157,7 +157,7 @@ afs_CacheInit(afs_int32 astatSize, afs_int32 afiles, afs_int32 ablocks,
     if (code) {
 	return code;
     }
-#if defined(AFS_LINUX26_ENV) && defined(STRUCT_TASK_STRUCT_HAS_CRED)
+#if defined(AFS_LINUX_ENV) && defined(STRUCT_TASK_STRUCT_HAS_CRED)
     /*
      * Save current credentials for later access to disk cache files.
      * If selinux, apparmor or other security modules are enabled,
@@ -253,14 +253,14 @@ afs_LookupInodeByPath(char *filename, afs_ufs_dcache_id_t *inode,
 {
     afs_int32 code;
 
-#if defined(AFS_LINUX22_ENV)
+#if defined(AFS_LINUX_ENV)
     struct dentry *dp;
     code = gop_lookupname(filename, AFS_UIOSYS, 0, &dp);
     if (code)
 	return code;
     osi_get_fh(dp, inode);
     dput(dp);
-#else /* AFS_LINUX22_ENV */
+#else /* AFS_LINUX_ENV */
     struct vnode *filevp;
     code = gop_lookupname(filename, AFS_UIOSYS, 0, &filevp);
     if (code)
@@ -275,7 +275,7 @@ afs_LookupInodeByPath(char *filename, afs_ufs_dcache_id_t *inode,
     else {
 	AFS_RELE(filevp);
     }
-#endif /* AFS_LINUX22_ENV */
+#endif /* AFS_LINUX_ENV */
 
     return 0;
 }
@@ -383,7 +383,7 @@ afs_InitCacheInfo(char *afile)
     struct osi_stat tstat;
     struct osi_file *tfile;
     struct afs_fheader theader;
-#ifndef AFS_LINUX22_ENV
+#ifndef AFS_LINUX_ENV
     struct vnode *filevp;
 #endif
     int goodFile;
@@ -391,7 +391,7 @@ afs_InitCacheInfo(char *afile)
     AFS_STATCNT(afs_InitCacheInfo);
     if (cacheDiskType != AFS_FCACHE_TYPE_UFS)
 	osi_Panic("afs_InitCacheInfo --- called for non-ufs cache!");
-#ifdef AFS_LINUX22_ENV
+#ifdef AFS_LINUX_ENV
     code = osi_InitCacheInfo(afile);
     if (code)
 	return code;
@@ -423,14 +423,6 @@ afs_InitCacheInfo(char *afile)
 	if (!VFS_STATVFS(filevp->v_vfsp, &st))
 # elif defined(AFS_AIX41_ENV)
 	if (!VFS_STATFS(filevp->v_vfsp, &st, &afs_osi_cred))
-# elif defined(AFS_LINUX20_ENV)
-	{
-	    KERNEL_SPACE_DECL;
-	    TO_USER_SPACE();
-
-	    VFS_STATFS(filevp->v_vfsp, &st);
-	    TO_KERNEL_SPACE();
-	}
 # elif defined(AFS_DARWIN80_ENV)
 	afs_cacheVfsp = vnode_mount(filevp);
 	if (afs_cacheVfsp && ((st = *(vfs_statfs(afs_cacheVfsp))),1))
@@ -459,10 +451,7 @@ afs_InitCacheInfo(char *afile)
 	    afs_fsfragsize = st.f_bsize - 1;
 # endif /* AFS_SUN5_ENV || AFS_HPUX100_ENV */
     }
-# if defined(AFS_LINUX20_ENV)
-    cacheInode.ufs = filevp->i_ino;
-    afs_cacheSBp = filevp->i_sb;
-# elif defined(AFS_XBSD_ENV)
+# if defined(AFS_XBSD_ENV)
     cacheInode.ufs = VTOI(filevp)->i_number;
     cacheDev.mp = filevp->v_mount;
     cacheDev.held_vnode = filevp;
@@ -483,9 +472,9 @@ afs_InitCacheInfo(char *afile)
     afs_LookupInodeByPath(afile, &cacheInode.ufs, NULL);
 #  endif /* !AFS_CACHE_VNODE_PATH */
     cacheDev.dev = afs_vnodeToDev(filevp);
-# endif /* AFS_LINUX20_ENV */
+# endif /* AFS_XBSD_ENV */
     AFS_RELE(filevp);
-#endif /* AFS_LINUX22_ENV */
+#endif /* AFS_LINUX_ENV */
     if (afs_fsfragsize < AFS_MIN_FRAGSIZE) {
 	afs_fsfragsize = AFS_MIN_FRAGSIZE;
     }
@@ -734,7 +723,7 @@ shutdown_cache(void)
 	memset(&cacheDev, 0, sizeof(struct osi_dev));
 	osi_dnlc_shutdown();
     }
-#if defined(AFS_LINUX26_ENV) && defined(STRUCT_TASK_STRUCT_HAS_CRED)
+#if defined(AFS_LINUX_ENV) && defined(STRUCT_TASK_STRUCT_HAS_CRED)
     put_cred(cache_creds);
 #endif
 }				/*shutdown_cache */
@@ -745,7 +734,7 @@ shutdown_vnodeops(void)
 {
     AFS_STATCNT(shutdown_vnodeops);
     if (afs_cold_shutdown) {
-#ifndef AFS_LINUX20_ENV
+#ifndef AFS_LINUX_ENV
 	afs_rd_stash_i = 0;
 #endif
 	shutdown_mariner();
diff --git a/src/afs/afs_lock.c b/src/afs/afs_lock.c
index f97e6ed65..448985324 100644
--- a/src/afs/afs_lock.c
+++ b/src/afs/afs_lock.c
@@ -122,7 +122,7 @@ ReleaseLock(struct afs_lock *lock, int how)
 void
 Afs_Lock_Obtain(struct afs_lock *lock, int how)
 {
-    osi_timeval_t tt1, tt2, et;
+    osi_timeval32_t tt1, tt2, et;
     afs_uint32 us;
 
     AFS_STATCNT(Lock_Obtain);
diff --git a/src/afs/afs_osi.c b/src/afs/afs_osi.c
index c970ea3c1..24b96b83e 100644
--- a/src/afs/afs_osi.c
+++ b/src/afs/afs_osi.c
@@ -103,13 +103,13 @@ osi_Init(void)
 	afs_osi_credp = kcred;
 #else
 	memset(&afs_osi_cred, 0, sizeof(afs_ucred_t));
-#if defined(AFS_LINUX26_ENV)
+#if defined(AFS_LINUX_ENV)
         afs_set_cr_group_info(&afs_osi_cred, groups_alloc(0));
 #endif
 #if defined(AFS_DARWIN80_ENV)
         afs_osi_cred.cr_ref = 1; /* kauth_cred_get_ref needs 1 existing ref */
 #else
-# if !(defined(AFS_LINUX26_ENV) && defined(STRUCT_TASK_STRUCT_HAS_CRED))
+# if !(defined(AFS_LINUX_ENV) && defined(STRUCT_TASK_STRUCT_HAS_CRED))
 	crhold(&afs_osi_cred);  /* don't let it evaporate */
 # endif
 #endif
@@ -129,7 +129,7 @@ osi_Init(void)
 void
 afs_osi_MaskSignals(void)
 {
-#ifdef AFS_LINUX22_ENV
+#ifdef AFS_LINUX_ENV
     osi_linux_mask();
 #endif
 }
@@ -138,7 +138,7 @@ afs_osi_MaskSignals(void)
 void
 afs_osi_UnmaskRxkSignals(void)
 {
-#ifdef AFS_LINUX22_ENV
+#ifdef AFS_LINUX_ENV
     osi_linux_unmaskrxk();
 #endif
 }
@@ -173,7 +173,7 @@ afs_osi_RxkRegister(void)
 void
 afs_osi_Invisible(void)
 {
-#ifdef AFS_LINUX22_ENV
+#ifdef AFS_LINUX_ENV
     afs_osi_MaskSignals();
 #elif defined(AFS_SUN5_ENV)
     curproc->p_flag |= SSYS;
@@ -221,7 +221,7 @@ shutdown_osi(void)
        afs_osi_ctxtp_initialized = 0;
     }
 #endif
-#if !defined(AFS_HPUX_ENV) && !defined(UKERNEL) && !defined(AFS_DFBSD_ENV) && !defined(AFS_LINUX26_ENV)
+#if !defined(AFS_HPUX_ENV) && !defined(UKERNEL) && !defined(AFS_DFBSD_ENV) && !defined(AFS_LINUX_ENV)
     /* LINUX calls this from afs_cleanup() which hooks into module_exit */
     shutdown_osisleep();
 #endif
@@ -250,10 +250,8 @@ shutdown_osisleep(void)
 		afs_osi_Free(tmp, sizeof(*tmp));
 #elif defined(AFS_SGI_ENV) || defined(AFS_XBSD_ENV) || defined(AFS_SUN5_ENV)
 		osi_FreeSmallSpace(tmp);
-#elif defined(AFS_LINUX26_ENV)
+#elif defined(AFS_LINUX_ENV)
 		kfree(tmp);
-#elif defined(AFS_LINUX20_ENV)
-		osi_linux_free(tmp);
 #endif
 	    }
 	}
diff --git a/src/afs/afs_osi.h b/src/afs/afs_osi.h
index 67d6f995d..2fbe54bc7 100644
--- a/src/afs/afs_osi.h
+++ b/src/afs/afs_osi.h
@@ -11,7 +11,7 @@
 #define _AFS_OSI_
 
 #include "h/types.h"
-#if !defined(AFS_LINUX26_ENV)
+#if !defined(AFS_LINUX_ENV)
 #include "h/param.h"
 #endif
 
@@ -23,7 +23,7 @@
 #include <sys/lock.h>
 #endif
 
-#ifdef AFS_LINUX20_ENV
+#ifdef AFS_LINUX_ENV
 #ifndef _LINUX_CODA_FS_I
 #define _LINUX_CODA_FS_I
 #define _CODA_HEADER_
@@ -60,10 +60,10 @@ struct osi_stat {
 
 struct osi_file {
     afs_int32 size;		/* file size in bytes XXX Must be first field XXX */
-#ifdef AFS_LINUX26_ENV
+#ifdef AFS_LINUX_ENV
     struct file *filp;		/* May need this if we really open the file. */
 #else
-#ifdef AFS_LINUX22_ENV
+#ifdef AFS_LINUX_ENV
     struct dentry dentry;	/* merely to hold the pointer to the inode. */
     struct file file;		/* May need this if we really open the file. */
 #else
@@ -133,7 +133,7 @@ struct afs_osi_WaitHandle {
  *
  * Darwin, all of the BSDs, and Linux have their own
  */
-#if !defined(AFS_DARWIN_ENV) && !defined(AFS_XBSD_ENV) && !defined(AFS_LINUX20_ENV)
+#if !defined(AFS_DARWIN_ENV) && !defined(AFS_XBSD_ENV) && !defined(AFS_LINUX_ENV)
 # define	vType(vc)	    AFSTOV(vc)->v_type
 # define	vSetType(vc,type)   AFSTOV(vc)->v_type = (type)
 # define	vSetVfsp(vc,vfsp)   AFSTOV(vc)->v_vfsp = (vfsp)
@@ -178,30 +178,15 @@ extern int osi_vnhold(struct vcache *);
  */
 #define osi_GetuTime(x) osi_GetTime(x)
 
-/* osi_timeval_t exists because SGI 6.x has two sizes of timeval. */
-/** In 64 bit Solaris the timeval structure has members that are 64 bit
-  * In the GetTime() interface we expect pointers to afs_int32. So the need to
-  * define osi_timeval_t to have 32 bit members. To make this less ambiguous
-  * we now use 32 bit quantities consistently all over the code.
-  * In 64 bit HP-UX the timeval structure has a 64 bit member.
-  */
-
-#if defined(AFS_HPUX_ENV) || defined(AFS_LINUX_64BIT_KERNEL) || (defined(AFS_LINUX26_ENV) && !defined(HAVE_LINUX_TIME_T)) || (defined(AFS_SGI61_ENV) && defined(KERNEL) && defined(_K64U64))
-typedef struct {
-    afs_int32 tv_sec;
-    afs_int32 tv_usec;
-} osi_timeval_t;
+/*
+ * We use osi_timeval32_t because the native timeval varies in size on
+ * different platforms.  We require a fixed size timeval, at least for the
+ * xstats.
+ */
 typedef struct {
     afs_int32 tv_sec;
     afs_int32 tv_usec;
 } osi_timeval32_t;
-#elif defined(AFS_SUN5_ENV)
-typedef struct timeval32 osi_timeval_t;
-typedef struct timeval32 osi_timeval32_t;
-#else
-typedef struct timeval osi_timeval_t;
-typedef struct timeval osi_timeval32_t;
-#endif /* AFS_SGI61_ENV */
 
 #ifndef UKERNEL
 #define osi_getpid() 		getpid()
diff --git a/src/afs/afs_osi_alloc.c b/src/afs/afs_osi_alloc.c
index 78254d6ac..4e76d32df 100644
--- a/src/afs/afs_osi_alloc.c
+++ b/src/afs/afs_osi_alloc.c
@@ -50,7 +50,7 @@ afs_osi_Alloc(size_t size)
 
     AFS_STATS(afs_stats_cmperf.OutStandingAllocs++);
     AFS_STATS(afs_stats_cmperf.OutStandingMemUsage += size);
-#ifdef AFS_LINUX20_ENV
+#ifdef AFS_LINUX_ENV
     return osi_linux_alloc(size, 1);
 #else
     return AFS_KALLOC(size);
@@ -66,7 +66,7 @@ afs_osi_Free(void *x, size_t asize)
 
     AFS_STATS(afs_stats_cmperf.OutStandingAllocs--);
     AFS_STATS(afs_stats_cmperf.OutStandingMemUsage -= asize);
-#if defined(AFS_LINUX20_ENV)
+#if defined(AFS_LINUX_ENV)
     osi_linux_free(x);
 #else
     AFS_KFREE(x, asize);
diff --git a/src/afs/afs_osi_pag.c b/src/afs/afs_osi_pag.c
index 22167f078..f53fc8b14 100644
--- a/src/afs/afs_osi_pag.c
+++ b/src/afs/afs_osi_pag.c
@@ -71,19 +71,19 @@ afs_uint32
 genpag(void)
 {
     AFS_STATCNT(genpag);
-#ifdef AFS_LINUX20_ENV
+#ifdef AFS_LINUX_ENV
     /* Ensure unique PAG's (mod 200 days) when reloading the client. */
     return (('A' << 24) + ((pag_epoch + pagCounter++) & 0xffffff));
-#else /* AFS_LINUX20_ENV */
+#else /* AFS_LINUX_ENV */
     return (('A' << 24) + (pagCounter++ & 0xffffff));
-#endif /* AFS_LINUX20_ENV */
+#endif /* AFS_LINUX_ENV */
 }
 
 afs_uint32
 getpag(void)
 {
     AFS_STATCNT(getpag);
-#ifdef AFS_LINUX20_ENV
+#ifdef AFS_LINUX_ENV
     /* Ensure unique PAG's (mod 200 days) when reloading the client. */
     return (('A' << 24) + ((pag_epoch + pagCounter) & 0xffffff));
 #else
@@ -100,18 +100,18 @@ afs_uint32
 genpag(void)
 {
     AFS_STATCNT(genpag);
-#ifdef AFS_LINUX20_ENV
+#ifdef AFS_LINUX_ENV
     return (pag_epoch + pagCounter++);
 #else
     return (pagCounter++);
-#endif /* AFS_LINUX20_ENV */
+#endif /* AFS_LINUX_ENV */
 }
 
 afs_uint32
 getpag(void)
 {
     AFS_STATCNT(getpag);
-#ifdef AFS_LINUX20_ENV
+#ifdef AFS_LINUX_ENV
     /* Ensure unique PAG's (mod 200 days) when reloading the client. */
     return (pag_epoch + pagCounter);
 #else
@@ -251,7 +251,7 @@ afs_setpag(void)
 	credp = OSI_GET_CURRENT_CRED();
 	code = AddPag(genpag(), &credp);
     }
-#elif	defined(AFS_LINUX20_ENV)
+#elif	defined(AFS_LINUX_ENV)
     {
 	afs_ucred_t *credp = crref();
 	code = AddPag(genpag(), &credp);
@@ -362,7 +362,7 @@ afs_setpag_val(int pagval)
 	credp = OSI_GET_CURRENT_CRED();
 	code = AddPag(pagval, &credp);
     }
-#elif	defined(AFS_LINUX20_ENV)
+#elif	defined(AFS_LINUX_ENV)
     {
 	afs_ucred_t *credp = crref();
 	code = AddPag(pagval, &credp);
@@ -451,7 +451,7 @@ AddPag(afs_int32 aval, afs_ucred_t **credpp)
 int
 afs_InitReq(struct vrequest *av, afs_ucred_t *acred)
 {
-#if defined(AFS_LINUX26_ENV) && !defined(AFS_NONFSTRANS)
+#if defined(AFS_LINUX_ENV) && !defined(AFS_NONFSTRANS)
     int code;
 #endif
 
@@ -460,7 +460,7 @@ afs_InitReq(struct vrequest *av, afs_ucred_t *acred)
     if (afs_shuttingdown == AFS_SHUTDOWN)
 	return EIO;
 
-#ifdef AFS_LINUX26_ENV
+#ifdef AFS_LINUX_ENV
 #if !defined(AFS_NONFSTRANS)
     if (osi_linux_nfs_initreq(av, acred, &code))
 	return code;
@@ -599,7 +599,7 @@ afs_get_groups_from_pag(afs_uint32 pag, gid_t *g0p, gid_t *g1p)
 }
 #endif
 
-#ifdef AFS_LINUX26_ENV
+#ifdef AFS_LINUX_ENV
 /* osi_get_group_pag is defined in <ARCH>/osi_groups.c */
 #elif defined(AFS_PAG_ONEGROUP_ENV)
 /* osi_get_group_pag is defined in <ARCH>/osi_groups.c */
@@ -639,10 +639,10 @@ osi_get_group_pag(afs_ucred_t *cred)
 # if defined(AFS_AIX_ENV)
     if (cred->cr_ngrps < 2)
 	return NOPAG;
-# elif defined(AFS_LINUX26_ENV)
+# elif defined(AFS_LINUX_ENV)
     if (afs_cr_group_info(cred)->ngroups < AFS_NUMPAGGROUPS)
 	return NOPAG;
-# elif defined(AFS_SGI_ENV) || defined(AFS_SUN5_ENV) || defined(AFS_LINUX20_ENV) || defined(AFS_XBSD_ENV)
+# elif defined(AFS_SGI_ENV) || defined(AFS_SUN5_ENV) || defined(AFS_LINUX_ENV) || defined(AFS_XBSD_ENV)
 #  if defined(AFS_SUN510_ENV)
     if (ngroups < 2) {
 #  else
@@ -678,7 +678,7 @@ PagInCred(afs_ucred_t *cred)
 	return NOPAG;
     }
 #ifndef AFS_DARWIN110_ENV
-#if defined(AFS_LINUX26_ENV) && defined(LINUX_KEYRING_SUPPORT)
+#if defined(AFS_LINUX_ENV) && defined(LINUX_KEYRING_SUPPORT)
     /*
      * If linux keyrings are in use and we carry the session keyring in our credentials
      * structure, they should be the only criteria for determining
diff --git a/src/afs/afs_osi_vget.c b/src/afs/afs_osi_vget.c
index 5fd36bff6..e9c6cc484 100644
--- a/src/afs/afs_osi_vget.c
+++ b/src/afs/afs_osi_vget.c
@@ -21,7 +21,7 @@
 
 
 
-#if !defined(AFS_LINUX20_ENV) && !defined(AFS_DARWIN80_ENV)
+#if !defined(AFS_LINUX_ENV) && !defined(AFS_DARWIN80_ENV)
 /* This is the common part of the vget VFS call. */
 int
 afs_osi_vget(struct vcache **avcpp, struct fid *afidp, struct vrequest *areqp)
@@ -72,4 +72,4 @@ afs_osi_vget(struct vcache **avcpp, struct fid *afidp, struct vrequest *areqp)
 
     return code;
 }
-#endif /* AFS_LINUX20_ENV */
+#endif /* AFS_LINUX_ENV */
diff --git a/src/afs/afs_osi_vm.c b/src/afs/afs_osi_vm.c
index 2b02b7d5f..450af206a 100644
--- a/src/afs/afs_osi_vm.c
+++ b/src/afs/afs_osi_vm.c
@@ -22,7 +22,7 @@ int
 osi_Active(struct vcache *avc)
 {
     AFS_STATCNT(osi_Active);
-#if defined(AFS_AIX_ENV) || defined(AFS_SUN5_ENV) || (AFS_LINUX20_ENV) || defined(AFS_DARWIN_ENV) || defined(AFS_XBSD_ENV)
+#if defined(AFS_AIX_ENV) || defined(AFS_SUN5_ENV) || (AFS_LINUX_ENV) || defined(AFS_DARWIN_ENV) || defined(AFS_XBSD_ENV)
     if ((avc->opens > 0) || (avc->f.states & CMAPPED))
 	return 1;		/* XXX: Warning, verify this XXX  */
 #elif defined(AFS_SGI_ENV)
diff --git a/src/afs/afs_pag_call.c b/src/afs/afs_pag_call.c
index a20e3e627..4cfd7cc1a 100644
--- a/src/afs/afs_pag_call.c
+++ b/src/afs/afs_pag_call.c
@@ -16,7 +16,7 @@
 #include "afs/afs_stats.h"
 #include "rx/rx_globals.h"
 #include "rx/rxstat.h"
-#if !defined(UKERNEL) && !defined(AFS_LINUX20_ENV)
+#if !defined(UKERNEL) && !defined(AFS_LINUX_ENV)
 #include "net/if.h"
 #include "netinet/in_var.h"
 #endif /* !defined(UKERNEL) */
diff --git a/src/afs/afs_pioctl.c b/src/afs/afs_pioctl.c
index f77884667..89e7c4125 100644
--- a/src/afs/afs_pioctl.c
+++ b/src/afs/afs_pioctl.c
@@ -312,7 +312,7 @@ DECL_PIOCTL(PNFSNukeCreds);
 DECL_PIOCTL(PNewUuid);
 DECL_PIOCTL(PPrecache);
 DECL_PIOCTL(PGetPAG);
-#if defined(AFS_CACHE_BYPASS) && defined(AFS_LINUX24_ENV)
+#if defined(AFS_CACHE_BYPASS) && defined(AFS_LINUX_ENV)
 DECL_PIOCTL(PSetCachingThreshold);
 #endif
 
@@ -436,7 +436,7 @@ static pioctlFunction CpioctlSw[] = {
 static pioctlFunction OpioctlSw[]  = {
     PBogus,			/* 0 */
     PNFSNukeCreds,		/* 1 -- nuke all creds for NFS client */
-#if defined(AFS_CACHE_BYPASS) && defined(AFS_LINUX24_ENV)
+#if defined(AFS_CACHE_BYPASS) && defined(AFS_LINUX_ENV)
     PSetCachingThreshold        /* 2 -- get/set cache-bypass size threshold */
 #else
     PNoop                       /* 2 -- get/set cache-bypass size threshold */
@@ -708,7 +708,7 @@ afs_xioctl(struct afs_ioctl_sys *uap, rval_t *rvp)
 
     return (code);
 }
-#elif defined(AFS_LINUX22_ENV)
+#elif defined(AFS_LINUX_ENV)
 struct afs_ioctl_sys {
     unsigned int com;
     unsigned long arg;
@@ -1019,7 +1019,7 @@ afs_pioctl(afs_proc_t *p, void *args, int *retval)
 #endif
 
 /* macro to avoid adding any more #ifdef's to pioctl code. */
-#if defined(AFS_LINUX22_ENV) || defined(AFS_AIX41_ENV)
+#if defined(AFS_LINUX_ENV) || defined(AFS_AIX41_ENV)
 #define PIOCTL_FREE_CRED() crfree(credp)
 #else
 #define PIOCTL_FREE_CRED()
@@ -1045,7 +1045,7 @@ afs_syscall_pioctl(char *path, unsigned int com, caddr_t cmarg, int follow)
 #ifdef AFS_NEED_CLIENTCONTEXT
     afs_ucred_t *tmpcred = NULL;
 #endif
-#if defined(AFS_NEED_CLIENTCONTEXT) || defined(AFS_SUN5_ENV) || defined(AFS_AIX41_ENV) || defined(AFS_LINUX22_ENV) || defined(AFS_DARWIN_ENV) || defined(AFS_XBSD_ENV)
+#if defined(AFS_NEED_CLIENTCONTEXT) || defined(AFS_SUN5_ENV) || defined(AFS_AIX41_ENV) || defined(AFS_LINUX_ENV) || defined(AFS_DARWIN_ENV) || defined(AFS_XBSD_ENV)
     afs_ucred_t *foreigncreds = NULL;
 #endif
     afs_int32 code = 0;
@@ -1053,7 +1053,7 @@ afs_syscall_pioctl(char *path, unsigned int com, caddr_t cmarg, int follow)
 #ifdef	AFS_AIX41_ENV
     struct ucred *credp = crref();	/* don't free until done! */
 #endif
-#ifdef AFS_LINUX22_ENV
+#ifdef AFS_LINUX_ENV
     cred_t *credp = crref();	/* don't free until done! */
     struct dentry *dp;
 #endif
@@ -1071,7 +1071,7 @@ afs_syscall_pioctl(char *path, unsigned int com, caddr_t cmarg, int follow)
     }
     if ((com & 0xff) == PSetClientContext) {
 #ifdef AFS_NEED_CLIENTCONTEXT
-#if defined(AFS_SUN5_ENV) || defined(AFS_AIX41_ENV) || defined(AFS_LINUX22_ENV)
+#if defined(AFS_SUN5_ENV) || defined(AFS_AIX41_ENV) || defined(AFS_LINUX_ENV)
 	code = HandleClientContext(&data, &com, &foreigncreds, credp);
 #else
 	code = HandleClientContext(&data, &com, &foreigncreds, osi_curcred());
@@ -1101,7 +1101,7 @@ afs_syscall_pioctl(char *path, unsigned int com, caddr_t cmarg, int follow)
 	 * like afs_osi_suser(cred) which, I think, is better since it
 	 * generalizes and supports multi cred environments...
 	 */
-#if defined(AFS_SUN5_ENV) || defined(AFS_LINUX22_ENV)
+#if defined(AFS_SUN5_ENV) || defined(AFS_LINUX_ENV)
 	tmpcred = credp;
 	credp = foreigncreds;
 #elif defined(AFS_AIX41_ENV)
@@ -1122,7 +1122,7 @@ afs_syscall_pioctl(char *path, unsigned int com, caddr_t cmarg, int follow)
     if ((com & 0xff) == 15) {
 	/* special case prefetch so entire pathname eval occurs in helper process.
 	 * otherwise, the pioctl call is essentially useless */
-#if	defined(AFS_SUN5_ENV) || defined(AFS_AIX41_ENV) || defined(AFS_LINUX22_ENV) || defined(AFS_DARWIN_ENV) || defined(AFS_XBSD_ENV)
+#if	defined(AFS_SUN5_ENV) || defined(AFS_AIX41_ENV) || defined(AFS_LINUX_ENV) || defined(AFS_DARWIN_ENV) || defined(AFS_XBSD_ENV)
 	code =
 	    Prefetch(path, &data, follow,
 		     foreigncreds ? foreigncreds : credp);
@@ -1142,13 +1142,13 @@ afs_syscall_pioctl(char *path, unsigned int com, caddr_t cmarg, int follow)
 	    lookupname(path, USR, follow, NULL, &vp,
 		       foreigncreds ? foreigncreds : credp);
 #else
-#ifdef AFS_LINUX22_ENV
+#ifdef AFS_LINUX_ENV
 	code = gop_lookupname_user(path, AFS_UIOUSER, follow, &dp);
 	if (!code)
 	    vp = (struct vnode *)dp->d_inode;
 #else
 	code = gop_lookupname_user(path, AFS_UIOUSER, follow, &vp);
-#endif /* AFS_LINUX22_ENV */
+#endif /* AFS_LINUX_ENV */
 #endif /* AFS_AIX41_ENV */
 	AFS_GLOCK();
 	if (code) {
@@ -1209,7 +1209,7 @@ afs_syscall_pioctl(char *path, unsigned int com, caddr_t cmarg, int follow)
 	    credp = OSI_GET_CURRENT_CRED();
 	    code = afs_HandlePioctl(vp, com, &data, follow, &credp);
 	}
-#elif defined(AFS_LINUX22_ENV) || defined(AFS_DARWIN_ENV) || defined(AFS_XBSD_ENV)
+#elif defined(AFS_LINUX_ENV) || defined(AFS_DARWIN_ENV) || defined(AFS_XBSD_ENV)
 	code = afs_HandlePioctl(vp, com, &data, follow, &credp);
 #elif defined(UKERNEL)
 	code = afs_HandlePioctl(vp, com, &data, follow,
@@ -1235,7 +1235,7 @@ afs_syscall_pioctl(char *path, unsigned int com, caddr_t cmarg, int follow)
 	set_p_cred(u.u_procp, tmpcred);	/* restore original credentials */
 #elif	defined(AFS_SGI_ENV)
 	OSI_SET_CURRENT_CRED(tmpcred);	/* restore original credentials */
-#elif	defined(AFS_SUN5_ENV) || defined(AFS_LINUX22_ENV)
+#elif	defined(AFS_SUN5_ENV) || defined(AFS_LINUX_ENV)
 	credp = tmpcred;		/* restore original credentials */
 #else
 	osi_curcred() = tmpcred;	/* restore original credentials */
@@ -1245,7 +1245,7 @@ afs_syscall_pioctl(char *path, unsigned int com, caddr_t cmarg, int follow)
     }
 #endif /* AFS_NEED_CLIENTCONTEXT */
     if (vp) {
-#ifdef AFS_LINUX22_ENV
+#ifdef AFS_LINUX_ENV
 	/*
 	 * Holding the global lock when calling dput can cause a deadlock
 	 * when the kernel calls back into afs_dentry_iput
@@ -1828,7 +1828,7 @@ _settok_tokenCell(char *cellName, int *cellNum, int *primary) {
 }
 
 
-#if defined(AFS_LINUX26_ENV)
+#if defined(AFS_LINUX_ENV)
 static_inline int
 _settok_setParentPag(afs_ucred_t **cred)
 {
@@ -4612,7 +4612,7 @@ HandleClientContext(struct afs_ioctl *ablob, int *com,
 #ifdef AFS_AIX51_ENV
     newcred->cr_groupset.gs_union.un_groups[0] = g0;
     newcred->cr_groupset.gs_union.un_groups[1] = g1;
-#elif defined(AFS_LINUX26_ENV)
+#elif defined(AFS_LINUX_ENV)
 # ifdef AFS_PAG_ONEGROUP_ENV
     afs_set_cr_group_info(newcred, groups_alloc(1)); /* nothing sets this */
     l = (((g0-0x3f00) & 0x3fff) << 14) | ((g1-0x3f00) & 0x3fff);
@@ -4639,8 +4639,8 @@ HandleClientContext(struct afs_ioctl *ablob, int *com,
 #endif
 #ifdef AFS_AIX_ENV
     newcred->cr_ngrps = 2;
-#elif !defined(AFS_LINUX26_ENV) && !defined(AFS_SUN510_ENV)
-# if defined(AFS_SGI_ENV) || defined(AFS_SUN5_ENV) || defined(AFS_LINUX22_ENV) || defined(AFS_FBSD_ENV)
+#elif !defined(AFS_LINUX_ENV) && !defined(AFS_SUN510_ENV)
+# if defined(AFS_SGI_ENV) || defined(AFS_SUN5_ENV) || defined(AFS_LINUX_ENV) || defined(AFS_FBSD_ENV)
     newcred->cr_ngroups = 2;
 # else
     for (i = 2; i < NGROUPS; i++)
@@ -5122,7 +5122,7 @@ DECL_PIOCTL(PNewUuid)
     return 0;
 }
 
-#if defined(AFS_CACHE_BYPASS) && defined(AFS_LINUX24_ENV)
+#if defined(AFS_CACHE_BYPASS) && defined(AFS_LINUX_ENV)
 
 DECL_PIOCTL(PSetCachingThreshold)
 {
diff --git a/src/afs/afs_prototypes.h b/src/afs/afs_prototypes.h
index b9fd0782b..5e7568e4e 100644
--- a/src/afs/afs_prototypes.h
+++ b/src/afs/afs_prototypes.h
@@ -33,7 +33,14 @@ extern int afs_cold_shutdown;
 extern char afs_rootVolumeName[MAXROOTVOLNAMELEN];
 extern void afs_FlushCBs(void);
 extern int afs_CheckInit(void);
-extern void afs_shutdown(void);
+/* for afs_shutdown */
+enum afs_shutdown_type {
+	AFS_WARM = 0,
+	AFS_COLD = 1,
+};
+extern void afs_shutdown(enum afs_shutdown_type);
+
+
 extern void shutdown_afstest(void);
 extern int afs_syscall_call(long parm, long parm2, long parm3,
 			    long parm4, long parm5, long parm6);
@@ -54,7 +61,7 @@ extern afs_int32 afs_evenZaps;
 extern afs_int32 afs_connectBacks;
 extern unsigned long lastCallBack_vnode;
 extern unsigned int lastCallBack_dv;
-extern osi_timeval_t lastCallBack_time;
+extern osi_timeval32_t lastCallBack_time;
 extern struct interfaceAddr afs_cb_interface;
 
 extern int afs_RXCallBackServer(void);
@@ -288,6 +295,7 @@ extern struct dcache *afs_ObtainDCacheForWriting(struct vcache *avc,
 						 int noLock);
 extern void afs_PopulateDCache(struct vcache *avc, afs_size_t apos,
 			       struct vrequest *areq);
+extern int afs_IsDCacheFresh(struct dcache *adc, struct vcache *avc);
 
 /* afs_disconnected.c */
 
@@ -630,8 +638,7 @@ extern void osi_ReleaseVM(struct vcache *avc, afs_ucred_t *acred);
 extern int osi_readRandom(void *, afs_size_t);
 
 /* LINUX/osi_misc.c */
-#ifdef AFS_LINUX20_ENV
-#ifdef AFS_LINUX24_ENV
+#ifdef AFS_LINUX_ENV
 extern int osi_lookupname(char *aname, uio_seg_t seg, int followlink,
 			  struct dentry **dpp);
 extern int osi_InitCacheInfo(char *aname);
@@ -641,7 +648,6 @@ extern void setup_uio(struct uio *uiop, struct iovec *iovecp, const char *buf,
 		      uio_seg_t seg);
 extern int uiomove(char *dp, int length, uio_flag_t rw, struct uio *uiop);
 extern void osi_linux_free_inode_pages(void);
-#endif
 extern void osi_linux_mask(void);
 extern void osi_linux_unmaskrxk(void);
 extern int setpag(cred_t ** cr, afs_uint32 pagvalue, afs_uint32 * newpag,
@@ -695,7 +701,7 @@ extern int afs_syscall_iincdec(int, int, int, int);
 /* ARCH/osi_file.c */
 extern int afs_osicred_initialized;
 extern void *osi_UFSOpen(afs_dcache_id_t *ainode);
-#if defined(AFS_LINUX22_ENV)
+#if defined(AFS_LINUX_ENV)
 extern void osi_get_fh(struct dentry *dp, afs_ufs_dcache_id_t *ainode);
 #endif
 extern int afs_osi_Stat(struct osi_file *afile,
@@ -734,7 +740,7 @@ extern int setpag(afs_proc_t *proc, struct ucred **cred, afs_uint32 pagvalue,
 # endif /* AFS_XBSD_ENV */
 #endif /* UKERNEL */
 
-#if defined(AFS_LINUX26_ENV) || defined(AFS_PAG_ONEGROUP_ENV)
+#if defined(AFS_LINUX_ENV) || defined(AFS_PAG_ONEGROUP_ENV)
 extern afs_int32 osi_get_group_pag(afs_ucred_t *cred);
 #endif
 
@@ -780,7 +786,7 @@ extern struct mount *afs_globalVFS;
 extern struct vfs *afs_globalVFS;
 #endif
 extern struct vcache *afs_globalVp;
-#ifdef AFS_LINUX20_ENV
+#ifdef AFS_LINUX_ENV
 extern void vcache2inode(struct vcache *avc);
 extern void vcache2fakeinode(struct vcache *rootvp, struct vcache *mpvp);
 #endif
@@ -964,7 +970,6 @@ extern int afs_ExtractTokensForPioctl(struct tokenJar *, time_t,
 extern void uafs_Shutdown(void);
 extern void osi_ReleaseVM(struct vcache *avc, int len,
 			  afs_ucred_t *credp);
-extern int osi_GetTime(struct timeval *tv);
 extern int iodone(struct usr_buf *bp);
 extern int usr_ioctl(void);
 extern int lookupname(char *fnamep, int segflg, int followlink,
@@ -1445,7 +1450,7 @@ extern void afs_ntohuuid(afsUUID * uuidp);
 extern afs_int32 afs_uuid_create(afsUUID * uuid);
 extern u_short afs_uuid_hash(afsUUID * uuid);
 
-#if defined(AFS_SUN5_ENV) || defined(AFS_LINUX20_ENV) || defined(AFS_AIX_ENV) || defined(AFS_DARWIN_ENV) || defined(AFS_XBSD_ENV) || defined(AFS_HPUX_ENV) || defined(AFS_SGI62_ENV) || defined(UKERNEL)
+#if defined(AFS_SUN5_ENV) || defined(AFS_LINUX_ENV) || defined(AFS_AIX_ENV) || defined(AFS_DARWIN_ENV) || defined(AFS_XBSD_ENV) || defined(AFS_HPUX_ENV) || defined(AFS_SGI62_ENV) || defined(UKERNEL)
 #include "osi_prototypes.h"
 #endif
 
diff --git a/src/afs/afs_server.c b/src/afs/afs_server.c
index 4f433e76e..5940e4e9f 100644
--- a/src/afs/afs_server.c
+++ b/src/afs/afs_server.c
@@ -37,7 +37,7 @@
 #include "afs/sysincludes.h"	/* Standard vendor system headers */
 
 #if !defined(UKERNEL)
-# if !defined(AFS_LINUX20_ENV)
+# if !defined(AFS_LINUX_ENV)
 #  include <net/if.h>
 # endif
 # include <netinet/in.h>
@@ -45,7 +45,7 @@
 # ifdef AFS_SGI62_ENV
 #  include "h/hashing.h"
 # endif
-# if !defined(AFS_HPUX110_ENV) && !defined(AFS_LINUX20_ENV) && !defined(AFS_DARWIN_ENV)
+# if !defined(AFS_HPUX110_ENV) && !defined(AFS_LINUX_ENV) && !defined(AFS_DARWIN_ENV)
 #  include <netinet/in_var.h>
 # endif /* AFS_HPUX110_ENV */
 # ifdef AFS_DARWIN_ENV
@@ -129,7 +129,7 @@ afs_MarkServerUpOrDown(struct srvAddr *sa, int a_isDown)
 {
     struct server *a_serverP = sa->server;
     struct srvAddr *sap;
-    osi_timeval_t currTime, *currTimeP;	/*Current time */
+    osi_timeval32_t currTime, *currTimeP;	/*Current time */
     afs_int32 downTime;		/*Computed downtime, in seconds */
     struct afs_stats_SrvUpDownInfo *upDownP;	/*Ptr to up/down info record */
 
@@ -354,8 +354,8 @@ afs_CountServers(void)
     int currIdx;		/*Curr idx into srv table */
     struct server *currSrvP;	/*Ptr to curr server record */
     afs_int32 currChainLen;	/*Length of curr hash chain */
-    osi_timeval_t currTime;	/*Current time */
-    osi_timeval_t *currTimeP;	/*Ptr to above */
+    osi_timeval32_t currTime;	/*Current time */
+    osi_timeval32_t *currTimeP;	/*Ptr to above */
     afs_int32 srvRecordAge;	/*Age of server record, in secs */
     struct afs_stats_SrvUpDownInfo *upDownP;	/*Ptr to current up/down
 						 * info being manipulated */
@@ -823,7 +823,7 @@ afs_random(void)
 
     AFS_STATCNT(afs_random);
     if (!state) {
-	osi_timeval_t t;
+	osi_timeval32_t t;
 	osi_GetTime(&t);
 	/*
 	 * Clear the low nybble of tv_usec in a size-independent manner before adding
@@ -1820,8 +1820,8 @@ afs_GetServer(afs_uint32 *aserverp, afs_int32 nservers, afs_int32 acell,
 void
 afs_ActivateServer(struct srvAddr *sap)
 {
-    osi_timeval_t currTime;	/*Filled with current time */
-    osi_timeval_t *currTimeP;	/*Ptr to above */
+    osi_timeval32_t currTime;	/*Filled with current time */
+    osi_timeval32_t *currTimeP;	/*Ptr to above */
     struct afs_stats_SrvUpDownInfo *upDownP;	/*Ptr to up/down info record */
     struct server *aserver = sap->server;
 
diff --git a/src/afs/afs_stats.h b/src/afs/afs_stats.h
index f80970f0e..8b578e470 100644
--- a/src/afs/afs_stats.h
+++ b/src/afs/afs_stats.h
@@ -50,7 +50,7 @@ typedef struct {
 #endif /* !KERNEL */
 
 #define XSTATS_DECLS struct afs_stats_opTimingData *opP = NULL; \
-    osi_timeval_t opStartTime = { 0, 0}, opStopTime, elapsedTime
+    osi_timeval32_t opStartTime = { 0, 0}, opStopTime, elapsedTime
 
 #define XSTATS_START_TIME(arg) \
   opP = &(afs_stats_cmfullperf.rpc.fsRPCTimes[arg]); \
diff --git a/src/afs/afs_syscall.c b/src/afs/afs_syscall.c
index 9414f38b8..ebb0d14a7 100644
--- a/src/afs/afs_syscall.c
+++ b/src/afs/afs_syscall.c
@@ -19,7 +19,7 @@
 #include "afsincludes.h"	/* Afs-based standard headers */
 #include "afs/afs_stats.h"
 #include "rx/rx_globals.h"
-#if !defined(UKERNEL) && !defined(AFS_LINUX20_ENV)
+#if !defined(UKERNEL) && !defined(AFS_LINUX_ENV)
 #include "net/if.h"
 #ifdef AFS_SGI62_ENV
 #include "h/hashing.h"
@@ -113,7 +113,7 @@ copyin_afs_ioctl(caddr_t cmarg, struct afs_ioctl *dst)
     }
 #endif /* defined(AFS_SGI_ENV) && (_MIPS_SZLONG==64) */
 
-#if defined(AFS_LINUX_64BIT_KERNEL) && !defined(AFS_ALPHA_LINUX20_ENV) && !defined(AFS_IA64_LINUX20_ENV)
+#if defined(AFS_LINUX_64BIT_KERNEL) && !defined(AFS_ALPHA_LINUX_ENV) && !defined(AFS_IA64_LINUX_ENV)
     if (afs_in_compat_syscall()) {
 	struct afs_ioctl32 dst32;
 
@@ -313,7 +313,7 @@ struct iparam32 {
 };
 
 
-#if defined(AFS_HPUX_64BIT_ENV) || defined(AFS_SUN5_64BIT_ENV) || (defined(AFS_LINUX_64BIT_KERNEL) && !defined(AFS_ALPHA_LINUX20_ENV) && !defined(AFS_IA64_LINUX20_ENV)) || defined(NEED_IOCTL32)
+#if defined(AFS_HPUX_64BIT_ENV) || defined(AFS_SUN5_64BIT_ENV) || (defined(AFS_LINUX_64BIT_KERNEL) && !defined(AFS_ALPHA_LINUX_ENV) && !defined(AFS_IA64_LINUX_ENV)) || defined(NEED_IOCTL32)
 static void
 iparam32_to_iparam(const struct iparam32 *src, struct iparam *dst)
 {
@@ -359,7 +359,7 @@ copyin_iparam(caddr_t cmarg, struct iparam *dst)
     }
 #endif /* AFS_SUN5_64BIT_ENV */
 
-#if defined(AFS_LINUX_64BIT_KERNEL) && !defined(AFS_ALPHA_LINUX20_ENV) && !defined(AFS_IA64_LINUX20_ENV)
+#if defined(AFS_LINUX_64BIT_KERNEL) && !defined(AFS_ALPHA_LINUX_ENV) && !defined(AFS_IA64_LINUX_ENV)
     if (afs_in_compat_syscall()) {
 	struct iparam32 dst32;
 
@@ -439,7 +439,7 @@ afs3_syscall(afs_proc_t *p, void *args, long *retval)
 	long parm5;
 	long parm6;
     } *uap = (struct a *)args;
-#elif defined(AFS_LINUX20_ENV)
+#elif defined(AFS_LINUX_ENV)
 struct afssysargs {
     long syscall;
     long parm1;
@@ -457,7 +457,7 @@ afs_syscall(long syscall, long parm1, long parm2, long parm3, long parm4)
     long linux_ret = 0;
     long *retval = &linux_ret;
     long eparm[4];		/* matches AFSCALL_ICL in fstrace.c */
-# ifdef AFS_SPARC64_LINUX24_ENV
+# ifdef AFS_SPARC64_LINUX_ENV
     afs_int32 eparm32[4];
 # endif
     /* eparm is also used by AFSCALL_CALL in afsd.c */
@@ -506,7 +506,7 @@ Afs_syscall()
 	return (ENODEV);
     }
 #endif
-#ifdef AFS_LINUX20_ENV
+#ifdef AFS_LINUX_ENV
     /* setup uap for use below - pull out the magic decoder ring to know
      * which syscalls have folded argument lists.
      */
@@ -515,7 +515,7 @@ Afs_syscall()
     uap->parm2 = parm2;
     uap->parm3 = parm3;
     if (syscall == AFSCALL_ICL || syscall == AFSCALL_CALL) {
-#ifdef AFS_SPARC64_LINUX24_ENV
+#ifdef AFS_SPARC64_LINUX_ENV
 /* from arch/sparc64/kernel/sys_sparc32.c */
 #define AA(__x)                                \
 ({     unsigned long __ret;            \
@@ -526,7 +526,7 @@ Afs_syscall()
 })
 
 
-#ifdef AFS_SPARC64_LINUX26_ENV
+#ifdef AFS_SPARC64_LINUX_ENV
 	if (test_thread_flag(TIF_32BIT))
 #else
 	if (current->thread.flags & SPARC_FLAG_32BIT)
@@ -782,7 +782,7 @@ Afs_syscall()
 			    uap->parm5, (long *)retval);
 #endif /* !AFS_NBSD40_ENV */
 	    AFS_GUNLOCK();
-#ifdef AFS_LINUX20_ENV
+#ifdef AFS_LINUX_ENV
 	    if (!code) {
 		/* ICL commands can return values. */
 		code = -linux_ret;	/* Gets negated again at exit below */
@@ -793,7 +793,7 @@ Afs_syscall()
 		setuerror(code);
 #endif
 	    }
-#endif /* !AFS_LINUX20_ENV */
+#endif /* !AFS_LINUX_ENV */
 	} else {
 #if defined(KERNEL_HAVE_UERROR)
 	    setuerror(EINVAL);
@@ -808,7 +808,7 @@ Afs_syscall()
     } /* 32 bit procs */
 #endif
 #endif
-#ifdef AFS_LINUX20_ENV
+#ifdef AFS_LINUX_ENV
     code = -code;
 #endif
     return code;
diff --git a/src/afs/afs_user.c b/src/afs/afs_user.c
index e4a51962a..8afc01dc2 100644
--- a/src/afs/afs_user.c
+++ b/src/afs/afs_user.c
@@ -18,7 +18,7 @@
 #include "afs/sysincludes.h"	/* Standard vendor system headers */
 
 #if !defined(UKERNEL)
-#if !defined(AFS_LINUX20_ENV)
+#if !defined(AFS_LINUX_ENV)
 #include <net/if.h>
 #endif
 #include <netinet/in.h>
@@ -26,7 +26,7 @@
 #ifdef AFS_SGI62_ENV
 #include "h/hashing.h"
 #endif
-#if !defined(AFS_HPUX110_ENV) && !defined(AFS_LINUX20_ENV) && !defined(AFS_DARWIN_ENV)
+#if !defined(AFS_HPUX110_ENV) && !defined(AFS_LINUX_ENV) && !defined(AFS_DARWIN_ENV)
 #include <netinet/in_var.h>
 #endif /* ! AFS_HPUX110_ENV */
 #endif /* !defined(UKERNEL) */
@@ -712,7 +712,7 @@ afs_GCPAGs_perproc_func(afs_proc_t * pproc)
     afs_GCPAGs_cred_count++;
 
     pag = PagInCred(pcred);
-#if defined(AFS_DARWIN_ENV) || defined(AFS_FBSD_ENV) || defined(AFS_LINUX22_ENV)
+#if defined(AFS_DARWIN_ENV) || defined(AFS_FBSD_ENV) || defined(AFS_LINUX_ENV)
     uid = (pag != NOPAG ? pag : afs_cr_uid(pcred));
 #elif defined(AFS_SUN510_ENV)
     uid = (pag != NOPAG ? pag : crgetruid(pcred));
diff --git a/src/afs/afs_util.c b/src/afs/afs_util.c
index 8bd595cc1..c360f71f0 100644
--- a/src/afs/afs_util.c
+++ b/src/afs/afs_util.c
@@ -20,7 +20,7 @@
 #include "afs/sysincludes.h"	/* Standard vendor system headers */
 
 #if !defined(UKERNEL)
-#if !defined(AFS_LINUX20_ENV)
+#if !defined(AFS_LINUX_ENV)
 #include <net/if.h>
 #endif
 #include <netinet/in.h>
@@ -28,7 +28,7 @@
 #ifdef AFS_SGI62_ENV
 #include "h/hashing.h"
 #endif
-#if !defined(AFS_HPUX110_ENV) && !defined(AFS_LINUX20_ENV) && !defined(AFS_DARWIN_ENV)
+#if !defined(AFS_HPUX110_ENV) && !defined(AFS_LINUX_ENV) && !defined(AFS_DARWIN_ENV)
 #include <netinet/in_var.h>
 #endif /* ! AFS_HPUX110_ENV */
 #endif /* !defined(UKERNEL) */
diff --git a/src/afs/afs_vcache.c b/src/afs/afs_vcache.c
index 7e3a778ab..351b70c4c 100644
--- a/src/afs/afs_vcache.c
+++ b/src/afs/afs_vcache.c
@@ -62,7 +62,7 @@ afs_rwlock_t afs_xvcdirty;	/*Lock: discon vcache dirty list mgmt */
 afs_rwlock_t afs_xvcache;	/*Lock: alloc new stat cache entries */
 afs_rwlock_t afs_xvreclaim;	/*Lock: entries reclaimed, not on free list */
 afs_lock_t afs_xvcb;		/*Lock: fids on which there are callbacks */
-#if !defined(AFS_LINUX22_ENV)
+#if !defined(AFS_LINUX_ENV)
 static struct vcache *freeVCList;	/*Free list for stat cache entries */
 struct vcache *ReclaimedVCList;	/*Reclaimed list for stat entries */
 static struct vcache *Initial_freeVCList;	/*Initial list for above */
@@ -174,7 +174,7 @@ afs_FlushVCache(struct vcache *avc, int *slept)
 	code = EBUSY;
 	goto bad;
     }
-#if !defined(AFS_LINUX22_ENV)
+#if !defined(AFS_LINUX_ENV)
     if (avc->nextfree || !avc->vlruq.prev || !avc->vlruq.next) {	/* qv afs.h */
 	refpanic("LRU vs. Free inconsistency");
     }
@@ -203,7 +203,7 @@ afs_FlushVCache(struct vcache *avc, int *slept)
     /* remove entry from the volume hash table */
     QRemove(&avc->vhashq);
 
-#if defined(AFS_LINUX26_ENV)
+#if defined(AFS_LINUX_ENV)
     {
 	struct pagewriter *pw, *store;
 	struct list_head tofree;
@@ -274,7 +274,7 @@ afs_FlushVCache(struct vcache *avc, int *slept)
 	afs_evenZaps++;
 
     afs_vcount--;
-#if !defined(AFS_LINUX22_ENV)
+#if !defined(AFS_LINUX_ENV)
     /* put the entry in the free list */
     avc->nextfree = freeVCList;
     freeVCList = avc;
@@ -295,7 +295,7 @@ afs_FlushVCache(struct vcache *avc, int *slept)
 	} else
 	    osi_Panic("flush vc refcnt < 1");
     }
-#endif /* AFS_LINUX22_ENV */
+#endif /* AFS_LINUX_ENV */
     return 0;
 
   bad:
@@ -679,7 +679,7 @@ afs_RemoveVCB(struct VenusFid *afid)
 void
 afs_FlushReclaimedVcaches(void)
 {
-#if !defined(AFS_LINUX22_ENV)
+#if !defined(AFS_LINUX_ENV)
     struct vcache *tvc;
     int code, fv_slept;
     struct vcache *tmpReclaimedVCList = NULL;
@@ -755,7 +755,7 @@ afs_PostPopulateVCache(struct vcache *avc, struct VenusFid *afid, int seq)
  *
  * Returns 1 if the stat cache looks stressed, and 0 otherwise.
  */
-#ifdef AFS_LINUX26_ENV
+#ifdef AFS_LINUX_ENV
 int
 afs_VCacheStressed(void)
 {
@@ -784,7 +784,7 @@ afs_VCacheStressed(void)
 	return 0;
     }
 }
-#else /* AFS_LINUX26_ENV */
+#else /* AFS_LINUX_ENV */
 int
 afs_VCacheStressed(void)
 {
@@ -795,7 +795,7 @@ afs_VCacheStressed(void)
     }
     return 1;
 }
-#endif /* AFS_LINUX26_ENV */
+#endif /* AFS_LINUX_ENV */
 
 int
 afs_ShakeLooseVCaches(afs_int32 anumber)
@@ -1016,7 +1016,7 @@ afs_NewVCache_int(struct VenusFid *afid, struct server *serverp, int seq)
 
     afs_FlushReclaimedVcaches();
 
-#if defined(AFS_LINUX22_ENV)
+#if defined(AFS_LINUX_ENV)
     if(!afsd_dynamic_vcaches && afs_vcount >= afs_maxvcount) {
 	afs_ShakeLooseVCaches(anumber);
 	if (afs_vcount >= afs_maxvcount) {
@@ -1028,7 +1028,7 @@ afs_NewVCache_int(struct VenusFid *afid, struct server *serverp, int seq)
     if (tvc == NULL) {
 	return NULL;
     }
-#else /* AFS_LINUX22_ENV */
+#else /* AFS_LINUX_ENV */
     /* pull out a free cache entry */
     if (!freeVCList) {
 	afs_ShakeLooseVCaches(anumber);
@@ -1046,7 +1046,7 @@ afs_NewVCache_int(struct VenusFid *afid, struct server *serverp, int seq)
 	afs_vcount++; /* balanced by FlushVCache */
     } /* end of if (!freeVCList) */
 
-#endif /* AFS_LINUX22_ENV */
+#endif /* AFS_LINUX_ENV */
 
 #if defined(AFS_XBSD_ENV) || defined(AFS_DARWIN_ENV)
     if (tvc->v)
@@ -1088,7 +1088,7 @@ afs_NewVCache_int(struct VenusFid *afid, struct server *serverp, int seq)
      * we have to do this after attaching the vnode, because the reference
      * count may be held in the vnode itself */
 
-#if defined(AFS_LINUX22_ENV)
+#if defined(AFS_LINUX_ENV)
     /* Hold it for the LRU (should make count 2) */
     osi_Assert(osi_vnhold(tvc) == 0);
 #elif !(defined (AFS_DARWIN_ENV) || defined(AFS_XBSD_ENV))
@@ -2901,21 +2901,21 @@ afs_NFSFindVCache(struct vcache **avcp, struct VenusFid *afid)
 void
 afs_vcacheInit(int astatSize)
 {
-#if !defined(AFS_LINUX22_ENV)
+#if !defined(AFS_LINUX_ENV)
     struct vcache *tvp;
 #endif
     int i;
     if (!afs_maxvcount) {
 	afs_maxvcount = astatSize;	/* no particular limit on linux? */
     }
-#if !defined(AFS_LINUX22_ENV)
+#if !defined(AFS_LINUX_ENV)
     freeVCList = NULL;
 #endif
 
     AFS_RWLOCK_INIT(&afs_xvcache, "afs_xvcache");
     LOCK_INIT(&afs_xvcb, "afs_xvcb");
 
-#if !defined(AFS_LINUX22_ENV)
+#if !defined(AFS_LINUX_ENV)
     /* Allocate and thread the struct vcache entries */
     tvp = afs_osi_Alloc(astatSize * sizeof(struct vcache));
     osi_Assert(tvp != NULL);
@@ -3041,7 +3041,7 @@ shutdown_vcache(void)
     }
     afs_cbrSpace = 0;
 
-#if !defined(AFS_LINUX22_ENV)
+#if !defined(AFS_LINUX_ENV)
     afs_osi_Free(Initial_freeVCList, afs_cacheStats * sizeof(struct vcache));
 
 # ifdef  KERNEL_HAVE_PIN
@@ -3167,7 +3167,10 @@ afs_StaleVCacheFlags(struct vcache *avc, afs_stalevc_flags_t flags,
 
     if (do_dnlc) {
 	if ((avc->f.fid.Fid.Vnode & 1) ||
-	    AFSTOV(avc) == NULL || vType(avc) == VDIR ||
+#if !defined(AFS_VCACHE_EMBEDDED_VNODE)
+	    AFSTOV(avc) == NULL ||
+#endif
+	    vType(avc) == VDIR ||
 	    (avc->f.states & CForeign)) {
 	    /* This vcache is (or could be) a directory. */
 	    osi_dnlc_purgedp(avc);
diff --git a/src/afs/afs_volume.c b/src/afs/afs_volume.c
index 28179db00..1f4a7b6cf 100644
--- a/src/afs/afs_volume.c
+++ b/src/afs/afs_volume.c
@@ -23,7 +23,7 @@
 #include "afs/sysincludes.h"	/* Standard vendor system headers */
 
 #if !defined(UKERNEL)
-#if !defined(AFS_LINUX20_ENV)
+#if !defined(AFS_LINUX_ENV)
 #include <net/if.h>
 #endif
 #include <netinet/in.h>
@@ -31,7 +31,7 @@
 #ifdef AFS_SGI62_ENV
 #include "h/hashing.h"
 #endif
-#if !defined(AFS_HPUX110_ENV) && !defined(AFS_LINUX20_ENV) && !defined(AFS_DARWIN_ENV)
+#if !defined(AFS_HPUX110_ENV) && !defined(AFS_LINUX_ENV) && !defined(AFS_DARWIN_ENV)
 #include <netinet/in_var.h>
 #endif /* ! AFS_HPUX110_ENV */
 #endif /* !defined(UKERNEL) */
diff --git a/src/afs/afs_warn.c b/src/afs/afs_warn.c
index ba0b757ac..074e53fa9 100644
--- a/src/afs/afs_warn.c
+++ b/src/afs/afs_warn.c
@@ -21,7 +21,7 @@
 
 #if !defined(UKERNEL)
 
-#if !defined(AFS_LINUX20_ENV)
+#if !defined(AFS_LINUX_ENV)
 # include <net/if.h>
 # if defined(AFS_SUN5_ENV)
 #  include <sys/varargs.h>
@@ -36,7 +36,7 @@
 #ifdef AFS_SGI62_ENV
 #include "h/hashing.h"
 #endif
-#if !defined(AFS_HPUX110_ENV) && !defined(AFS_LINUX20_ENV) && !defined(AFS_DARWIN_ENV)
+#if !defined(AFS_HPUX110_ENV) && !defined(AFS_LINUX_ENV) && !defined(AFS_DARWIN_ENV)
 #include <netinet/in_var.h>
 #endif /* ! AFS_HPUX110_ENV */
 #endif /* !defined(UKERNEL) */
@@ -55,11 +55,11 @@
 #include <sys/fp_io.h>
 #endif
 
-#if defined(AFS_LINUX26_ENV)
+#if defined(AFS_LINUX_ENV)
 # define afs_vprintf(fmt, ap) vprintk(fmt, ap)
 #elif defined(AFS_SGI_ENV)
 # define afs_vprintf(fmt, ap) icmn_err(CE_WARN, fmt, ap)
-#elif (defined(AFS_DARWIN80_ENV) && !defined(AFS_DARWIN90_ENV)) || (defined(AFS_LINUX22_ENV))
+#elif (defined(AFS_DARWIN80_ENV) && !defined(AFS_DARWIN90_ENV)) || (defined(AFS_LINUX_ENV))
 static_inline void
 afs_vprintf(const char *fmt, va_list ap)
 {
@@ -230,14 +230,14 @@ afs_warnall(char *fmt, ...)
 {
     va_list ap;
 
-# ifdef AFS_LINUX20_ENV
+# ifdef AFS_LINUX_ENV
     AFS_STATCNT(afs_warn);
     if ((afs_showflags & GAGCONSOLE) || (afs_showflags & GAGUSER)) {
 	va_start(ap, fmt);
 	afs_vwarn(fmt, ap);
 	va_end(ap);
     }
-# else /* AFS_LINUX20_ENV */
+# else /* AFS_LINUX_ENV */
     AFS_STATCNT(afs_warn);
     if (afs_showflags & GAGCONSOLE) {
 	va_start(ap, fmt);
@@ -251,7 +251,7 @@ afs_warnall(char *fmt, ...)
 	afs_vwarnuser(fmt, ap);
 	va_end(ap);
     }
-# endif /* AFS_LINUX20_ENV */
+# endif /* AFS_LINUX_ENV */
 }
 #endif /* AFS_AIX_ENV */
 
diff --git a/src/afs/afsincludes.h b/src/afs/afsincludes.h
index 3d0286e9d..9841f2f28 100644
--- a/src/afs/afsincludes.h
+++ b/src/afs/afsincludes.h
@@ -23,7 +23,7 @@
 # elif defined(AFS_HPUX_ENV) || defined(AFS_NBSD_ENV)
 #  include "osi_vfs.h"
 # endif
-# if defined(AFS_SGI_ENV) || defined(AFS_LINUX20_ENV)
+# if defined(AFS_SGI_ENV) || defined(AFS_LINUX_ENV)
 #  include "osi_vfs.h"
 # endif
 # include "rx/rx.h"
@@ -31,13 +31,11 @@
 # include "afs/lock.h"
 # include "afs/volerrors.h"
 # include "afs/voldefs.h"
-# ifdef AFS_LINUX20_ENV
+# ifdef AFS_LINUX_ENV
 #  ifdef TRUE
 #   undef TRUE
 #   undef FALSE
 #  endif
-# endif
-# ifdef AFS_LINUX20_ENV
 #  undef __NFDBITS
 #  undef __FDMASK
 # endif
@@ -54,7 +52,7 @@
 # include "afs/afs_stats.h"
 # include "afs/afs_prototypes.h"
 # include "afs/discon.h"
-# if defined(AFS_LINUX20_ENV) || defined(AFS_DARWIN_ENV) || defined(AFS_FBSD_ENV)
+# if defined(AFS_LINUX_ENV) || defined(AFS_DARWIN_ENV) || defined(AFS_FBSD_ENV)
 #  include "osi_machdep.h"
 # endif
 
diff --git a/src/afs/lock.h b/src/afs/lock.h
index 9d7fef485..c6e5193fd 100644
--- a/src/afs/lock.h
+++ b/src/afs/lock.h
@@ -80,7 +80,7 @@ typedef unsigned int afs_lock_tracker_t;
 #  define MyPidxx current_pid()
 #  define MyPidxx2Pid(x) (x)
 # endif
-#elif defined(AFS_LINUX20_ENV)
+#elif defined(AFS_LINUX_ENV)
 typedef struct task_struct * afs_lock_tracker_t;
 # define MyPidxx (current)
 # define MyPidxx2Pid(x) (x? (x)->pid : 0)
@@ -115,7 +115,7 @@ struct afs_lock {
     unsigned short readers_reading;	/* # readers actually with read locks */
     unsigned short num_waiting;	/* probably need this soon */
     unsigned short spare;	/* not used now */
-    osi_timeval_t time_waiting;	/* for statistics gathering */
+    osi_timeval32_t time_waiting;	/* for statistics gathering */
 #if defined(INSTRUMENT_LOCKS)
     /* the following are useful for debugging
      ** the field 'src_indicator' is updated only by ObtainLock() and
diff --git a/src/afs/sysincludes.h b/src/afs/sysincludes.h
index 1f281c5d3..e1312f609 100644
--- a/src/afs/sysincludes.h
+++ b/src/afs/sysincludes.h
@@ -108,7 +108,7 @@
 # include <sys/protosw.h>
 # include <sys/ioctl.h>
 
-#elif defined(AFS_LINUX22_ENV)
+#elif defined(AFS_LINUX_ENV)
 # include <linux/version.h>
 # ifdef HAVE_LINUX_CONFIG_H
 #  include <linux/config.h>
@@ -121,7 +121,7 @@
 # include <linux/net.h>
 # include <linux/kdev_t.h>
 # include <linux/ioctl.h>
-# if defined(AFS_LINUX26_ENV)
+# if defined(AFS_LINUX_ENV)
 #  include <linux/compat.h>
 #  include <linux/backing-dev.h>
 #  include <linux/pagemap.h>
@@ -177,11 +177,9 @@ struct xfs_inode_info {
 # if defined(HAVE_LINUX_EXPORTFS_H)
 #  include <linux/exportfs.h>
 # endif
-# ifdef AFS_LINUX24_ENV
-#  include <linux/pagemap.h>
-# endif
+# include <linux/pagemap.h>
 
-#else /* AFS_LINUX22_ENV */
+#else /* AFS_LINUX_ENV */
 
 # include "h/errno.h"
 # include "h/types.h"
@@ -449,7 +447,7 @@ MALLOC_DECLARE(M_AFS);
 #  include <sys/debug.h>
 # endif
 
-#endif /* AFS_LINUX22_ENV */
+#endif /* AFS_LINUX_ENV */
 
 #endif /* __AFS_SYSINCLUDESH__  so idempotent */
 
diff --git a/src/afsd/afsd.c b/src/afsd/afsd.c
index ffedee56f..3fae4e13a 100644
--- a/src/afsd/afsd.c
+++ b/src/afsd/afsd.c
@@ -306,7 +306,7 @@ int *dir_for_V = NULL;		/* Array: dir of each cache file.
 				 * -2: file exists in top-level
 				 * >=0: file exists in Dxxx
 				 */
-#if !defined(AFS_CACHE_VNODE_PATH) && !defined(AFS_LINUX26_ENV)
+#if !defined(AFS_CACHE_VNODE_PATH) && !defined(AFS_LINUX_ENV)
 AFSD_INO_T *inode_for_V;	/* Array of inodes for desired
 				 * cache files */
 #endif
@@ -563,7 +563,7 @@ ParseCacheInfoFile(void)
     FILE *cachefd;		/*Descriptor for cache info file */
     int parseResult;		/*Result of our fscanf() */
     int tCacheBlocks;
-    char tCacheBaseDir[1024], *tbd, tCacheMountDir[1024], *tmd;
+    char tCacheBaseDir[1025], *tbd, tCacheMountDir[1025], *tmd;
 
     if (afsd_debug)
 	printf("%s: Opening cache info file '%s'...\n", rn, fullpn_CacheInfo);
@@ -1047,7 +1047,7 @@ doSweepAFSCache(int *vFilesFound,
 	     * file's inode, directory, and bump the number of files found
 	     * total and in this directory.
 	     */
-#if !defined(AFS_CACHE_VNODE_PATH) && !defined(AFS_LINUX26_ENV)
+#if !defined(AFS_CACHE_VNODE_PATH) && !defined(AFS_LINUX_ENV)
 	    inode_for_V[vFileNum] = currp->d_ino;
 #endif
 	    dir_for_V[vFileNum] = dirNum;	/* remember this directory */
@@ -1131,7 +1131,7 @@ doSweepAFSCache(int *vFilesFound,
 	    SetNoBackupAttr(fullpn_CellInfoFile);
 	} else if ((strcmp(currp->d_name, ".") == 0)
 		   || (strcmp(currp->d_name, "..") == 0) ||
-#ifdef AFS_LINUX22_ENV
+#ifdef AFS_LINUX_ENV
 		   /* this is the ext3 journal file */
 		   (strcmp(currp->d_name, ".journal") == 0) ||
 #endif
@@ -1182,7 +1182,7 @@ doSweepAFSCache(int *vFilesFound,
 			   vFileNum);
 		else {
 		    struct stat statb;
-#if !defined(AFS_CACHE_VNODE_PATH) && !defined(AFS_LINUX26_ENV)
+#if !defined(AFS_CACHE_VNODE_PATH) && !defined(AFS_LINUX_ENV)
 		    assert(inode_for_V[vFileNum] == (AFSD_INO_T) 0);
 #endif
 		    sprintf(vFilePtr, "D%d/V%d", thisDir, vFileNum);
@@ -1195,7 +1195,7 @@ doSweepAFSCache(int *vFilesFound,
 		    if (CreateCacheFile(fullpn_VFile, &statb))
 			printf("%s: Can't create '%s'\n", rn, fullpn_VFile);
 		    else {
-#if !defined(AFS_CACHE_VNODE_PATH) && !defined(AFS_LINUX26_ENV)
+#if !defined(AFS_CACHE_VNODE_PATH) && !defined(AFS_LINUX_ENV)
 			inode_for_V[vFileNum] = statb.st_ino;
 #endif
 			dir_for_V[vFileNum] = thisDir;
@@ -1289,7 +1289,7 @@ CheckCacheBaseDir(char *dir)
 
     /* might want to check here for anything else goofy, like cache pointed at a non-dedicated directory, etc */
 
-#ifdef AFS_LINUX24_ENV
+#ifdef AFS_LINUX_ENV
     {
 	int res;
 	struct statfs statfsbuf;
@@ -1298,17 +1298,6 @@ CheckCacheBaseDir(char *dir)
 	if (res != 0) {
 	    return "unable to statfs cache base directory";
 	}
-#if !defined(AFS_LINUX26_ENV)
-	if (statfsbuf.f_type == 0x52654973) {	/* REISERFS_SUPER_MAGIC */
-	    return "cannot use reiserfs as cache partition";
-	} else if (statfsbuf.f_type == 0x58465342) {	/* XFS_SUPER_MAGIC */
-	    return "cannot use xfs as cache partition";
-	} else if (statfsbuf.f_type == 0x01021994) {    /* TMPFS_SUPER_MAGIC */
-            return "cannot use tmpfs as cache partition";
-        } else if (statfsbuf.f_type != 0xEF53) {
-            return "must use ext2 or ext3 for cache partition";
-	}
-#endif
     }
 #endif
 
@@ -2255,7 +2244,7 @@ CheckOptions(struct cmd_syndesc *as)
 	 * Cold shutdown is the default
 	 */
 	printf("afsd: Shutting down all afs processes and afs state\n");
-	code = afsd_syscall(AFSOP_SHUTDOWN, 1);
+	code = afsd_syscall(AFSOP_SHUTDOWN, 1);		/* always AFS_COLD */
 	if (code) {
 	    printf("afsd: AFS still mounted; Not shutting down\n");
 	    exit(1);
@@ -2549,7 +2538,7 @@ afsd_run(void)
 		   cacheStatEntries);
     }
 
-#if !defined(AFS_CACHE_VNODE_PATH) && !defined(AFS_LINUX26_ENV)
+#if !defined(AFS_CACHE_VNODE_PATH) && !defined(AFS_LINUX_ENV)
     /*
      * Create and zero the inode table for the desired cache files.
      */
@@ -2944,7 +2933,7 @@ afsd_run(void)
 		}
 		/* fall through to setup-by-inode */
 	    }
-#if defined(AFS_SGI62_ENV) || !(defined(AFS_LINUX26_ENV) || defined(AFS_CACHE_VNODE_PATH))
+#if defined(AFS_SGI62_ENV) || !(defined(AFS_LINUX_ENV) || defined(AFS_CACHE_VNODE_PATH))
 	    afsd_syscall(AFSOP_CACHEINODE, inode_for_V[currVFile]);
 #else
 	    printf
diff --git a/src/afsd/afsd_kernel.c b/src/afsd/afsd_kernel.c
index 28e764676..08a3c1a05 100644
--- a/src/afsd/afsd_kernel.c
+++ b/src/afsd/afsd_kernel.c
@@ -9,6 +9,7 @@
 
 #include <afsconfig.h>
 #include <afs/param.h>
+#include <afs/opr.h>
 
 #include <roken.h>
 
@@ -31,7 +32,7 @@
 #include <sys/file.h>
 #include <sys/wait.h>
 
-#if defined(AFS_LINUX20_ENV)
+#if defined(AFS_LINUX_ENV)
 #include <sys/resource.h>
 #endif
 
@@ -77,8 +78,6 @@
 #include <afs/afs_args.h>
 #include <afs/cellconfig.h>
 #include <afs/afssyscalls.h>
-#include <afs/afsutil.h>
-
 #ifdef AFS_DARWIN_ENV
 #ifdef AFS_DARWIN80_ENV
 #include <sys/xattr.h>
@@ -112,7 +111,7 @@ kern_return_t DiskArbDiskAppearedWithMountpointPing_auto(char *, unsigned int,
 # define SET_AFSD_RTPRI() SET_RTPRI(68)
 # define SET_RX_RTPRI()   SET_RTPRI(199)
 #else
-# ifdef AFS_LINUX20_ENV
+# ifdef AFS_LINUX_ENV
 #  define SET_AFSD_RTPRI()
 #  define SET_RX_RTPRI() do { \
     if (setpriority(PRIO_PROCESS, 0, -10) < 0) \
@@ -136,7 +135,7 @@ afsd_set_afsd_rtpri(void)
     SET_AFSD_RTPRI();
 }
 
-#if defined(AFS_LINUX20_ENV)
+#if defined(AFS_LINUX_ENV)
 int
 os_syscall(struct afsd_syscall_args *args)
 {
@@ -276,7 +275,7 @@ afsd_call_syscall(struct afsd_syscall_args *args)
     if (afsd_debug) {
         const char *syscall_str;
 #if defined(AFS_SYSCALL)
-        syscall_str = AFS_STRINGIZE(AFS_SYSCALL);
+	syscall_str = opr_stringize(AFS_SYSCALL);
 #else
         syscall_str = "[AFS_SYSCALL]";
 #endif
@@ -391,9 +390,9 @@ vmountdata(struct vmount * vmtp, char *obj, char *stub, char *host,
 static int
 HandleMTab(char *cacheMountDir)
 {
-#if (defined (AFS_HPUX_ENV) || defined(AFS_SGI_ENV) || defined(AFS_LINUX20_ENV))
+#if (defined (AFS_HPUX_ENV) || defined(AFS_SGI_ENV) || defined(AFS_LINUX_ENV))
     FILE *tfilep;
-#if defined(AFS_SGI_ENV) || defined(AFS_LINUX20_ENV)
+#if defined(AFS_SGI_ENV) || defined(AFS_LINUX_ENV)
     struct mntent tmntent;
     char *dir;
     int i;
@@ -507,7 +506,7 @@ afsd_mount_afs(const char *rn, const char *cacheMountDir)
     mountFlags = MS_FSS;
     if ((mount(MOUNT_AFS, cacheMountDir, mountFlags, (caddr_t) MOUNT_AFS))
 	< 0) {
-#elif defined(AFS_LINUX20_ENV)
+#elif defined(AFS_LINUX_ENV)
     if ((mount("AFS", cacheMountDir, MOUNT_AFS, 0, NULL)) < 0) {
 #elif defined(AFS_NBSD50_ENV)
     if ((mount(MOUNT_AFS, cacheMountDir, mountFlags, NULL, 0)) < 0) {
diff --git a/src/aklog/klog.c b/src/aklog/klog.c
index edf16e0b5..3f778478d 100644
--- a/src/aklog/klog.c
+++ b/src/aklog/klog.c
@@ -127,8 +127,9 @@ main(int argc, char *argv[])
     cmd_AddParm(ts, "-pipe", CMD_FLAG, CMD_OPTIONAL,
 		"read password from stdin");
     cmd_AddParm(ts, "-silent", CMD_FLAG, CMD_OPTIONAL, "silent operation");
+    /* Note: -lifetime is not implemented in this version of klog. */
     cmd_AddParm(ts, "-lifetime", CMD_SINGLE, CMD_OPTIONAL,
-		"ticket lifetime in hh[:mm[:ss]]");
+		"ignored (for compatibility with the krb4-based klog)");
     cmd_AddParm(ts, "-setpag", CMD_FLAG, CMD_OPTIONAL,
 		"Create a new setpag before authenticating");
     cmd_AddParm(ts, "-tmp", CMD_FLAG, CMD_OPTIONAL,
@@ -246,12 +247,12 @@ k5_to_k4_name(krb5_context k5context,
 	    i = get_princ_len(k5context, k5princ, 1);
 	    if (i > MAXKTCNAMELEN-1) i = MAXKTCNAMELEN-1;
 	    memcpy(ktcprinc->instance, get_princ_str(k5context, k5princ, 1), i);
-	    /* fall through */
+	    AFS_FALLTHROUGH;
 	case 1:
 	    i = get_princ_len(k5context, k5princ, 0);
 	    if (i > MAXKTCNAMELEN-1) i = MAXKTCNAMELEN-1;
 	    memcpy(ktcprinc->name, get_princ_str(k5context, k5princ, 0), i);
-	    /* fall through */
+	    AFS_FALLTHROUGH;
 	case 0:
 	    break;
 	}
@@ -361,7 +362,6 @@ CommandProc(struct cmd_syndesc *as, void *arock)
     int authtype;
 #endif
     krb5_data enc_part[1];
-    time_t lifetime;		/* requested ticket lifetime */
     krb5_prompter_fct pf = NULL;
     char *pass = 0;
     void *pa = 0;
@@ -513,36 +513,6 @@ CommandProc(struct cmd_syndesc *as, void *arock)
 	pass = passwd;
     }
 
-    if (as->parms[aLIFETIME].items) {
-	char *life = as->parms[aLIFETIME].items->data;
-	char *sp;		/* string ptr to rest of life */
-	lifetime = 3600 * strtol(life, &sp, 0);	/* hours */
-	if (sp == life) {
-	  bad_lifetime:
-	    if (!Silent)
-		fprintf(stderr, "%s: translating '%s' to lifetime failed\n",
-			rn, life);
-	    return 1;
-	}
-	if (*sp == ':') {
-	    life = sp + 1;	/* skip the colon */
-	    lifetime += 60 * strtol(life, &sp, 0);	/* minutes */
-	    if (sp == life)
-		goto bad_lifetime;
-	    if (*sp == ':') {
-		life = sp + 1;
-		lifetime += strtol(life, &sp, 0);	/* seconds */
-		if (sp == life)
-		    goto bad_lifetime;
-		if (*sp)
-		    goto bad_lifetime;
-	    } else if (*sp)
-		goto bad_lifetime;
-	} else if (*sp)
-	    goto bad_lifetime;
-    } else
-	lifetime = 0;
-
     /* Get the password if it wasn't provided. */
     if (!pass) {
 	if (Pipe) {
diff --git a/src/auth/Makefile.in b/src/auth/Makefile.in
index 8dec8a6c0..d1720194c 100644
--- a/src/auth/Makefile.in
+++ b/src/auth/Makefile.in
@@ -177,8 +177,9 @@ dest: libauth.a libauth.krb.a auth.h cellconfig.h
 #
 # Misc. targets
 #
+.PHONY: test
 test:
-	cd test; $(MAKE)
+	cd test && $(MAKE)
 
 clean:
 	$(LT_CLEAN)
diff --git a/src/auth/cellconfig.c b/src/auth/cellconfig.c
index 20547aab1..2226e8357 100644
--- a/src/auth/cellconfig.c
+++ b/src/auth/cellconfig.c
@@ -1325,9 +1325,14 @@ afsconf_GetAfsdbInfo(char *acellName, char *aservice,
 }
 #endif /* windows */
 
-int
-afsconf_GetCellInfo(struct afsconf_dir *adir, char *acellName, char *aservice,
-		    struct afsconf_cell *acellInfo)
+/* flags for _GetCellInfo */
+#define AFSCONF_GETCELL_EMPTYOK (0x1) /** it's okay to return 'empty' cells
+					* (that is, cells without any
+					* dbservers) */
+
+static int
+_GetCellInfo(struct afsconf_dir *adir, char *acellName, char *aservice,
+	     struct afsconf_cell *acellInfo, afs_uint32 flags)
 {
     struct afsconf_entry *tce;
     struct afsconf_aliasentry *tcae;
@@ -1338,6 +1343,11 @@ afsconf_GetCellInfo(struct afsconf_dir *adir, char *acellName, char *aservice,
     int cnLen;
     int ambig;
     char tbuffer[64];
+    int emptyok = 0;
+
+    if ((flags & AFSCONF_GETCELL_EMPTYOK)) {
+	emptyok = 1;
+    }
 
     LOCK_GLOBAL_MUTEX;
     if (adir)
@@ -1387,7 +1397,7 @@ afsconf_GetCellInfo(struct afsconf_dir *adir, char *acellName, char *aservice,
 	    bestce = tce;
 	}
     }
-    if (!ambig && bestce && bestce->cellInfo.numServers) {
+    if (!ambig && bestce && (bestce->cellInfo.numServers || emptyok)) {
 	*acellInfo = bestce->cellInfo;	/* structure assignment */
 	if (aservice) {
 	    tservice = afsconf_FindService(aservice);
@@ -1459,7 +1469,9 @@ afsconf_GetCellInfo(struct afsconf_dir *adir, char *acellName, char *aservice,
                 strcpy(acellInfo->hostName[i], hostName[i]);
             }
             acellInfo->numServers = numServers;
-            acellInfo->flags |= AFSCONF_CELL_FLAG_DNS_QUERIED;
+	    if (numServers) {
+		acellInfo->flags |= AFSCONF_CELL_FLAG_DNS_QUERIED;
+	    }
         }
 	UNLOCK_GLOBAL_MUTEX;
 	return 0;
@@ -1469,6 +1481,63 @@ afsconf_GetCellInfo(struct afsconf_dir *adir, char *acellName, char *aservice,
     }
 }
 
+/**
+ * Get info about a cell.
+ *
+ * @param[in] adir	afsconf object.
+ * @param[in] acellName	name of the cell to get. a cell name abbreviation can
+ *			be given if it's unambiguous (e.g. "cell" can be given
+ *			for "cell.example.com" if no other cells begin with
+ *			"cell").
+ * @param[in] aservice	name of the service in the cell, as accepted by
+ *			afsconf_FindService. if NULL is given: for local
+ *			lookups, no port information will be returned; for DNS
+ *			lookups, we'll default to "afs3-vlserver".
+ * @param[out] acellInfo    info for the requested cell and service
+ *
+ * @return afsconf error codes
+ */
+int
+afsconf_GetCellInfo(struct afsconf_dir *adir, char *acellName, char *aservice,
+		    struct afsconf_cell *acellInfo)
+{
+    return _GetCellInfo(adir, acellName, aservice, acellInfo, 0);
+}
+
+/**
+ * Get a cell's name.
+ *
+ * This is similar to afsconf_GetCellInfo, but doesn't actually retrieve the
+ * info of the specified cell (beyond it's name). This can be useful to verify
+ * that a cell name is valid, or to canonicalize a possibly-abbreviated cell
+ * name. Unlike afsconf_GetCellInfo, this call can avoid DNS lookups if the
+ * cell name is specified in the local config, but the cell's servers are not.
+ *
+ * @param[in] adir	afsconf object.
+ * @param[in] acellName	name of the cell to get. a cell name abbreviation can
+ *			be given if it's unambiguous (see afsconf_GetCellInfo).
+ * @param[out] buf	on success, the cell's name is written to this buffer.
+ * @param[in] buf_size	size of 'buf'.
+ *
+ * @return afsconf error codes
+ * @retval AFSCONF_FAILURE  buf_size is too small to fit the cell's name.
+ */
+int
+afsconf_GetCellName(struct afsconf_dir *adir, char *acellName, char *buf,
+		    size_t buf_size)
+{
+    int code;
+    struct afsconf_cell info;
+    code = _GetCellInfo(adir, acellName, NULL, &info, AFSCONF_GETCELL_EMPTYOK);
+    if (code) {
+	return code;
+    }
+    if (strlcpy(buf, info.name, buf_size) >= buf_size) {
+	return AFSCONF_FAILURE;
+    }
+    return 0;
+}
+
 /**
  * Get the current localcell name.
  *
diff --git a/src/auth/cellconfig.p.h b/src/auth/cellconfig.p.h
index 3b91e01bf..4aed0311d 100644
--- a/src/auth/cellconfig.p.h
+++ b/src/auth/cellconfig.p.h
@@ -123,6 +123,8 @@ extern int afsconf_GetAfsdbInfo(char *acellName, char *aservice,
 extern int afsconf_GetCellInfo(struct afsconf_dir *adir, char *acellName,
 			       char *aservice,
 			       struct afsconf_cell *acellInfo);
+extern int afsconf_GetCellName(struct afsconf_dir *adir, char *acellName,
+			       char *buf, size_t buf_size);
 extern int afsconf_GetLocalCell(struct afsconf_dir *adir,
 				char *aname, afs_int32 alen);
 extern int afsconf_Close(struct afsconf_dir *adir);
@@ -168,6 +170,7 @@ extern void afsconf_typedKey_values(struct afsconf_typedKey *key,
 				  int *minorType,
 				  struct rx_opaque **keyMaterial);
 
+extern int afsconf_CountKeys(struct afsconf_dir *);
 extern int afsconf_GetAllKeys(struct afsconf_dir *,
 			      struct afsconf_typedKeyList **);
 extern int afsconf_GetKeysByType(struct afsconf_dir *dir,
diff --git a/src/auth/keys.c b/src/auth/keys.c
index 54ad95503..ad36c494f 100644
--- a/src/auth/keys.c
+++ b/src/auth/keys.c
@@ -821,6 +821,39 @@ out:
     return code;
 }
 
+int
+_afsconf_CountKeys(struct afsconf_dir *dir)
+{
+    int count = 0;
+    struct opr_queue *typeCursor;
+    struct keyTypeList *typeEntry;
+    struct opr_queue *kvnoCursor;
+    struct kvnoList *kvnoEntry;
+    struct opr_queue *subCursor;
+
+    for (opr_queue_Scan(&dir->keyList, typeCursor)) {
+	typeEntry = opr_queue_Entry(typeCursor, struct keyTypeList, link);
+	for (opr_queue_Scan(&typeEntry->kvnoList, kvnoCursor)) {
+	    kvnoEntry = opr_queue_Entry(kvnoCursor, struct kvnoList, link);
+	    for (opr_queue_Scan(&kvnoEntry->subTypeList, subCursor))
+		count++;
+	}
+    }
+    return count;
+}
+
+int
+afsconf_CountKeys(struct afsconf_dir *dir)
+{
+    int count = 0;
+
+    LOCK_GLOBAL_MUTEX;
+    count = _afsconf_CountKeys(dir);
+    UNLOCK_GLOBAL_MUTEX;
+
+    return count;
+}
+
 int
 afsconf_GetAllKeys(struct afsconf_dir *dir, struct afsconf_typedKeyList **keys)
 {
@@ -840,16 +873,8 @@ afsconf_GetAllKeys(struct afsconf_dir *dir, struct afsconf_typedKeyList **keys)
     if (code)
 	goto out;
 
-    count = 0;
     /* First, work out how many keys we have in total */
-    for (opr_queue_Scan(&dir->keyList, typeCursor)) {
-	typeEntry = opr_queue_Entry(typeCursor, struct keyTypeList, link);
-	for (opr_queue_Scan(&typeEntry->kvnoList, kvnoCursor)) {
-	    kvnoEntry = opr_queue_Entry(kvnoCursor, struct kvnoList, link);
-	    for (opr_queue_Scan(&kvnoEntry->subTypeList, subCursor))
-		count++;
-	}
-    }
+    count = _afsconf_CountKeys(dir);
 
     /* Allocate space for all of these */
     retval = malloc(sizeof(struct afsconf_typedKeyList));
diff --git a/src/auth/ktc.c b/src/auth/ktc.c
index c04bc863b..84879ef5e 100644
--- a/src/auth/ktc.c
+++ b/src/auth/ktc.c
@@ -50,7 +50,7 @@
 #include <afs/sys_prototypes.h>
 #endif
 
-#if defined(AFS_LINUX26_ENV)
+#if defined(AFS_LINUX_ENV)
 #include <sys/syscall.h>
 #if defined(SYS_keyctl)
 /* Open code this value to avoid a dependency on keyutils */
@@ -297,7 +297,7 @@ SetToken(struct ktc_principal *aserver, struct ktc_token *atoken,
 #endif /* NO_AFS_CLIENT */
     if (code)
 	return KTC_PIOCTLFAIL;
-#if defined(AFS_LINUX26_ENV) && defined(SYS_keyctl)
+#if defined(AFS_LINUX_ENV) && defined(SYS_keyctl)
     else
         /*
          * If we're using keyring based PAGs and the SESSION_TO_PARENT keyctl
@@ -372,7 +372,7 @@ ktc_SetTokenEx(struct ktc_setTokenData *token) {
 
     if (code)
 	return KTC_PIOCTLFAIL;
-#if defined(AFS_LINUX26_ENV) && defined(SYS_keyctl)
+#if defined(AFS_LINUX_ENV) && defined(SYS_keyctl)
     else
 	/*
 	 * If we're using keyring based PAGs and the SESSION_TO_PARENT keyctl
diff --git a/src/auth/liboafs_auth.la.sym b/src/auth/liboafs_auth.la.sym
index 5497f994a..fcd0b9997 100644
--- a/src/auth/liboafs_auth.la.sym
+++ b/src/auth/liboafs_auth.la.sym
@@ -8,10 +8,12 @@ afsconf_ClientAuth
 afsconf_ClientAuthSecure
 afsconf_ClientAuthToken
 afsconf_Close
+afsconf_CountKeys
 afsconf_DeleteKey
 afsconf_GetAfsdbInfo
 afsconf_GetAllKeys
 afsconf_GetCellInfo
+afsconf_GetCellName
 afsconf_GetExtendedCellInfo
 afsconf_GetKey
 afsconf_GetLatestKey
diff --git a/src/bozo/Makefile.in b/src/bozo/Makefile.in
index 6a7b54499..a8916cc26 100644
--- a/src/bozo/Makefile.in
+++ b/src/bozo/Makefile.in
@@ -163,8 +163,9 @@ clean:
 		bosint.cs.c bosint.ss.c bosint.xdr.c bosint.h \
 		core boserr.c bnode.h AFS_component_version_number.c
 
+.PHONY: test
 test:
-	cd test; $(MAKE)
+	cd test && $(MAKE)
 
 include ../config/Makefile.version
 
diff --git a/src/bozo/bnode.c b/src/bozo/bnode.c
index 9dab6d0e6..b97fea586 100644
--- a/src/bozo/bnode.c
+++ b/src/bozo/bnode.c
@@ -774,7 +774,7 @@ hdl_notifier(struct bnode_proc *tp)
 	setsid();
 #elif defined(AFS_DARWIN90_ENV)
 	setpgid(0, 0);
-#elif defined(AFS_LINUX20_ENV) || defined(AFS_AIX_ENV)
+#elif defined(AFS_LINUX_ENV) || defined(AFS_AIX_ENV)
 	setpgrp();
 #else
 	setpgrp(0, 0);
diff --git a/src/bozo/bosserver.c b/src/bozo/bosserver.c
index 8bba0e723..42b0fb4ee 100644
--- a/src/bozo/bosserver.c
+++ b/src/bozo/bosserver.c
@@ -1149,6 +1149,12 @@ main(int argc, char **argv, char **envp)
     /* opened the cell databse */
     bozo_confdir = tdir;
 
+    if (afsconf_CountKeys(bozo_confdir) == 0) {
+	bozo_Log("WARNING: No encryption keys found! "
+		 "All authenticated accesses will fail. "
+		 "Run akeyconvert or asetkey to import encryption keys.\n");
+    }
+
     code = bnode_Init();
     if (code) {
 	printf("bosserver: could not init bnode package, code %d\n", code);
diff --git a/src/bucoord/main.c b/src/bucoord/main.c
index a453cc9dd..972ac2d3a 100644
--- a/src/bucoord/main.c
+++ b/src/bucoord/main.c
@@ -343,7 +343,7 @@ struct Lock dispatchLock;	/* lock on the Dispatch call */
 
 afs_int32
 doDispatch(afs_int32 targc,
-	   char *targv[MAXV],
+	   char *targv[],
 	   afs_int32 dispatchCount) /* to prevent infinite recursion */
 {
     char *sargv[MAXV];
diff --git a/src/budb/server.c b/src/budb/server.c
index 3a8091845..8190ef9c1 100644
--- a/src/budb/server.c
+++ b/src/budb/server.c
@@ -467,6 +467,12 @@ main(int argc, char **argv)
 	ERROR(BUDB_NOCELLS);
     }
 
+    if (afsconf_CountKeys(BU_conf) == 0) {
+	LogError(0, "WARNING: No encryption keys found! "
+		    "All authenticated accesses will fail. "
+		    "Run akeyconvert or asetkey to import encryption keys.\n");
+    }
+
     code = afsconf_GetLocalCell(BU_conf, lcell, sizeof(lcell));
     if (code) {
 	LogError(0, "** Can't determine local cell name!\n");
diff --git a/src/butc/afsxbsa.c b/src/butc/afsxbsa.c
index aee6b48e4..d8ec545d1 100644
--- a/src/butc/afsxbsa.c
+++ b/src/butc/afsxbsa.c
@@ -17,7 +17,7 @@
 
 #include <ctype.h>
 
-#if defined(AFS_AIX_ENV) || defined(AFS_SUN5_ENV) || defined(AFS_LINUX26_ENV)
+#if defined(AFS_AIX_ENV) || defined(AFS_SUN5_ENV) || defined(AFS_LINUX_ENV)
 #include <dlfcn.h>
 #endif
 
@@ -630,9 +630,9 @@ void * dynlib = NULL ;
 #endif
 #if defined(AFS_AIX_ENV)
         dynlib = dlopen("/usr/lib/libApiDS.a(dsmapish.o)", RTLD_NOW | RTLD_LOCAL | RTLD_MEMBER);
-#elif defined (AFS_AMD64_LINUX26_ENV)
+#elif defined (AFS_AMD64_LINUX_ENV)
 	dynlib = dlopen("/usr/lib64/libApiTSM64.so", RTLD_NOW | RTLD_LOCAL);
-#elif defined(AFS_SUN5_ENV) || defined(AFS_LINUX26_ENV)
+#elif defined(AFS_SUN5_ENV) || defined(AFS_LINUX_ENV)
         dynlib = dlopen("/usr/lib/libApiDS.so", RTLD_NOW | RTLD_LOCAL);
 #else
         dynlib = NULL;
@@ -646,7 +646,7 @@ void * dynlib = NULL ;
 #ifdef DEBUG_BUTC
     	printf("dsm_MountLibrary : SUCCESS to Open the libApiDS shared library. \n");
 #endif
-#if defined(AFS_AIX_ENV) || defined(AFS_SUN5_ENV) || defined(AFS_LINUX26_ENV)
+#if defined(AFS_AIX_ENV) || defined(AFS_SUN5_ENV) || defined(AFS_LINUX_ENV)
 	AFSdsmBeginQuery = (dsInt16_t (*)( dsUint32_t dsmHandle, dsmQueryType queryType, dsmQueryBuff *queryBuffer)) dlsym((void *)dynlib, "dsmBeginQuery");
 	AFSdsmGetNextQObj = (dsInt16_t (*)( dsUint32_t dsmHandle, DataBlk *dataBlkPtr))dlsym((void *)dynlib, "dsmGetNextQObj") ;
 	AFSdsmEndQuery = (dsInt16_t (*)( dsUint32_t dsmHandle))dlsym((void *)dynlib, "dsmEndQuery");
diff --git a/src/butc/butc_xbsa.c b/src/butc/butc_xbsa.c
index f2da6a64a..f45f61015 100644
--- a/src/butc/butc_xbsa.c
+++ b/src/butc/butc_xbsa.c
@@ -229,7 +229,7 @@ xbsa_MountLibrary(struct butx_transactionInfo *info, afs_int32 serverType)
     XBSAQueryApiVersion(&(info->apiVersion));
 #endif
 #else
-#if defined(AFS_AIX_ENV) || defined(AFS_SUN5_ENV) || defined(AFS_LINUX26_ENV)
+#if defined(AFS_AIX_ENV) || defined(AFS_SUN5_ENV) || defined(AFS_LINUX_ENV)
     XBSAInit                    = BSAInit;
     XBSABeginTxn                = BSABeginTxn;
     XBSAEndTxn                  = BSAEndTxn;
diff --git a/src/butc/dump.c b/src/butc/dump.c
index 62d09e5c8..3750ef721 100644
--- a/src/butc/dump.c
+++ b/src/butc/dump.c
@@ -868,8 +868,7 @@ dumpPass(struct dumpRock * dparamsPtr, int passNumber)
 		    dparamsPtr->volumesFailed++;
 		    continue;
 		}
-		/* Fall into RWVOL case */
-
+		AFS_FALLTHROUGH;
 	    case RWVOL:
 		for (e = 0; e < vldbEntry.nServers; e++) {	/* Find the RW volume */
 		    if (vldbEntry.serverFlags[e] & VLSF_RWVOL)
diff --git a/src/butc/tcmain.c b/src/butc/tcmain.c
index 14d1aaf13..24406fe8f 100644
--- a/src/butc/tcmain.c
+++ b/src/butc/tcmain.c
@@ -997,6 +997,12 @@ WorkerBee(struct cmd_syndesc *as, void *arock)
 	exit(1);
     }
 
+    if (afsconf_CountKeys(butc_confdir) == 0) {
+	TLog(0, "WARNING: No encryption keys found! "
+		"All authenticated accesses will fail. "
+		"Run akeyconvert or asetkey to import encryption keys.\n");
+    }
+
     /* Start auditing */
     osi_audit_init();
     if (as->parms[9].items) {
diff --git a/src/butm/file_tm.c b/src/butm/file_tm.c
index fd4c8d750..7f063db81 100644
--- a/src/butm/file_tm.c
+++ b/src/butm/file_tm.c
@@ -676,7 +676,7 @@ incPosition(struct butm_tapeInfo *info, usd_handle_t fid, afs_uint32 dataSize)
 
     if (info->posCount >= 2147467264) {	/* 2GB - 16K */
 	info->posCount = 0;
-#if (defined(AFS_SUN_ENV) || defined(AFS_LINUX24_ENV))
+#if (defined(AFS_SUN_ENV) || defined(AFS_LINUX_ENV))
 	if (!isafile) {
 	    afs_int64 off;
 
diff --git a/src/cf/autoheader.m4 b/src/cf/autoheader.m4
index b4be64158..681817ffb 100644
--- a/src/cf/autoheader.m4
+++ b/src/cf/autoheader.m4
@@ -1,3 +1,8 @@
+AC_DEFUN([OPENAFS_AUTOHEADER_TOP],[
+    AH_TOP([
+#ifndef __AFSCONFIG_H
+#define __AFSCONFIG_H 1])
+])
 AC_DEFUN([OPENAFS_AUTOHEADER_BOTTOM],[
     AH_BOTTOM([
 #undef HAVE_RES_SEARCH
@@ -57,5 +62,14 @@ AC_DEFUN([OPENAFS_AUTOHEADER_BOTTOM],[
 #undef ENABLE_REDHAT_BUILDSYS
 #if defined(ENABLE_REDHAT_BUILDSYS) && defined(KERNEL) && defined(REDHAT_FIX)
 # include "redhat-fix.h"
-#endif])
+#endif
+
+/*
+ * AC_HEADER_TIME, which set TIME_WITH_SYS_TIME, has been marked as obsolete
+ * prior to autoconf 2.64 and autoconf 2.70 flags its use with a warning.
+ * However the external roken code still relies on the definition.
+ */
+#define TIME_WITH_SYS_TIME 1
+
+#endif /* __AFSCONFIG_H */])
 ])
diff --git a/src/cf/c-attribute.m4 b/src/cf/c-attribute.m4
index c179d903a..97dbfb35d 100644
--- a/src/cf/c-attribute.m4
+++ b/src/cf/c-attribute.m4
@@ -1,27 +1,22 @@
 dnl
-dnl $Id$
+dnl GCC-style function __attribute__ checks.
 dnl
-
-dnl
-dnl Test for __attribute__
+dnl Define HAVE___ATTRIBUTE__ if and only if we specifically support the
+dnl `format' function attribute. This is done for the imported roken
+dnl headers, which use that symbol to conditionally declare functions with
+dnl printf-like arguments. This is the only use of function attributes in
+dnl roken.  The HAVE___ATTRIBUTE__ symbol is not used in the OpenAFS code.
 dnl
-
 AC_DEFUN([OPENAFS_C_ATTRIBUTE], [
-AC_MSG_CHECKING(for __attribute__)
-AC_CACHE_VAL(ac_cv___attribute__, [
-AC_COMPILE_IFELSE([AC_LANG_SOURCE([[#include <stdlib.h>
-static void foo(void) __attribute__ ((noreturn));
+  AX_GCC_FUNC_ATTRIBUTE([always_inline])
+  AX_GCC_FUNC_ATTRIBUTE([fallthrough])
+  AX_GCC_FUNC_ATTRIBUTE([format])
+  AX_GCC_FUNC_ATTRIBUTE([nonnull])
+  AX_GCC_FUNC_ATTRIBUTE([noreturn])
+  AX_GCC_FUNC_ATTRIBUTE([unused])
 
-static void
-foo(void)
-{
-  exit(1);
-}
-]])],
-[ac_cv___attribute__=yes],
-[ac_cv___attribute__=no])])
-if test "$ac_cv___attribute__" = "yes"; then
-  AC_DEFINE(HAVE___ATTRIBUTE__, 1, [define if your compiler has __attribute__])
-fi
-AC_MSG_RESULT($ac_cv___attribute__)
+  AS_IF([test "$ax_cv_have_func_attribute_format" = "yes"], [
+    AC_DEFINE([HAVE___ATTRIBUTE__], [1],
+      [define if your compiler has __attribute__((format))])
+  ])
 ])
diff --git a/src/cf/headers.m4 b/src/cf/headers.m4
index af4a4ddb8..889373a5e 100644
--- a/src/cf/headers.m4
+++ b/src/cf/headers.m4
@@ -1,6 +1,5 @@
 AC_DEFUN([OPENAFS_HEADER_CHECKS],[
 dnl checks for header files.
-AC_HEADER_STDC
 AC_HEADER_SYS_WAIT
 AC_HEADER_DIRENT
 AC_CHECK_HEADERS([ \
diff --git a/src/cf/lex.m4 b/src/cf/lex.m4
index 938b1082c..fd49089cf 100644
--- a/src/cf/lex.m4
+++ b/src/cf/lex.m4
@@ -1,5 +1,5 @@
 AC_DEFUN([OPENAFS_LEX],[
-AC_PROG_LEX
+AC_PROG_LEX([noyywrap])
 dnl if we are flex, be lex-compatible
 OPENAFS_LEX_IS_FLEX([AC_SUBST([LEX], ["$LEX -l"])])
 ])
diff --git a/src/cf/linux-checks.m4 b/src/cf/linux-checks.m4
index a433aff5c..7501172c9 100644
--- a/src/cf/linux-checks.m4
+++ b/src/cf/linux-checks.m4
@@ -14,12 +14,9 @@ AC_DEFUN([_OPENAFS_LINUX_KBUILD_SETUP],[
 if test "x$enable_debug_kernel" = "xno"; then
     LINUX_GCC_KOPTS="$LINUX_GCC_KOPTS -fomit-frame-pointer"
 fi
-OPENAFS_GCC_SUPPORTS_MARCH
-AC_SUBST(P5PLUS_KOPTS)
-OPENAFS_GCC_NEEDS_NO_STRENGTH_REDUCE
-OPENAFS_GCC_NEEDS_NO_STRICT_ALIASING
-OPENAFS_GCC_SUPPORTS_NO_COMMON
-OPENAFS_GCC_SUPPORTS_PIPE
+AX_APPEND_COMPILE_FLAGS([-fno-strict-aliasing -fno-strength-reduce \
+                         -fno-common -pipe],
+                        [LINUX_GCC_KOPTS],[-Werror])
 AC_SUBST(LINUX_GCC_KOPTS)
 
 dnl Setup the kernel build environment
diff --git a/src/cf/linux-kernel-func.m4 b/src/cf/linux-kernel-func.m4
index 0ca3e4463..cd4afe914 100644
--- a/src/cf/linux-kernel-func.m4
+++ b/src/cf/linux-kernel-func.m4
@@ -178,6 +178,12 @@ AC_CHECK_LINUX_FUNC([ip_sock_set],
                     [#include <net/ip.h>],
                     [ip_sock_set_mtu_discover(NULL, 0);])
 
+dnl Linux 5.17 renamed complete_and_exit to kthread_complete_and_exit
+AC_CHECK_LINUX_FUNC([kthread_complete_and_exit],
+                    [#include <linux/kernel.h>
+                     #include <linux/kthread.h>],
+                    [kthread_complete_and_exit(0, 0);])
+
 dnl Consequences - things which get set as a result of the
 dnl                above tests
 AS_IF([test "x$ac_cv_linux_func_d_alloc_anon" = "xno"],
diff --git a/src/cf/linux-kernel-struct.m4 b/src/cf/linux-kernel-struct.m4
index 003d34ab8..597289bc8 100644
--- a/src/cf/linux-kernel-struct.m4
+++ b/src/cf/linux-kernel-struct.m4
@@ -3,6 +3,10 @@ dnl Check for structure elements
 AC_CHECK_LINUX_STRUCT([address_space], [backing_dev_info], [fs.h])
 AC_CHECK_LINUX_STRUCT([address_space_operations],
                       [write_begin], [fs.h])
+dnl linux 5.18 replaced set_page_dirty with dirty_folio
+AC_CHECK_LINUX_STRUCT([address_space_operations], [dirty_folio], [fs.h])
+dnl linux 5.18 replaced readpages with readahead (introduced in 5.8)
+AC_CHECK_LINUX_STRUCT([address_space_operations], [readahead], [fs.h])
 AC_CHECK_LINUX_STRUCT([backing_dev_info], [name],
                       [backing-dev.h])
 AC_CHECK_LINUX_STRUCT([cred], [session_keyring], [cred.h])
diff --git a/src/cf/linux-test5.m4 b/src/cf/linux-test5.m4
deleted file mode 100644
index 59bdbfc80..000000000
--- a/src/cf/linux-test5.m4
+++ /dev/null
@@ -1,88 +0,0 @@
-dnl These options seem to only be used for the 2.4.x
-dnl Linux kernel build
-AC_DEFUN([OPENAFS_GCC_SUPPORTS_MARCH], [
-  AC_CACHE_CHECK([if $CC accepts -march=pentium],
-    [openafs_cv_gcc_supports_march],
-    [save_CFLAGS="$CFLAGS"
-     CFLAGS="-MARCH=pentium"
-     AC_COMPILE_IFELSE(
-       [AC_LANG_PROGRAM(
-         [[]],
-         [[int x;]])],
-         [openafs_cv_gcc_supports_march=yes],
-         [openafs_cv_gcc_supports_march=no])
-     CFLAGS="$save_CFLAGS"
-    ])
-  AS_IF([test x$openafs_cv_gcc_supports_march = xyes],
-        [P5PLUS_KOPTS="-march=pentium"],
-        [P5PLUS_KOPTS="-m486 -malign-loops=2 -malign-jumps=2 -malign-functions=2"])
-])
-
-AC_DEFUN([OPENAFS_GCC_NEEDS_NO_STRICT_ALIASING], [
-  AC_CACHE_CHECK([if $CC needs -fno-strict-aliasing],
-    [openafs_cv_gcc_needs_no_strict_aliasing],
-    [save_CFLAGS="$CFLAGS"
-     CFLAGS="-fno-strict-aliasing"
-     AC_COMPILE_IFELSE(
-       [AC_LANG_PROGRAM(
-         [[]],
-         [[int x;]])],
-       [openafs_cv_gcc_needs_no_strict_aliasing=yes],
-       [openafs_cv_gcc_needs_no_strict_aliasing=no])
-     CFLAGS="$save_CFLAGS"
-  ])
-  AS_IF([test x$openafs_cv_gcc_needs_no_strict_aliasing = xyes],
-        [LINUX_GCC_KOPTS="$LINUX_GCC_KOPTS -fno-strict-aliasing"])
-])
-
-AC_DEFUN([OPENAFS_GCC_NEEDS_NO_STRENGTH_REDUCE], [
-  AC_CACHE_CHECK([if $CC needs -fno-strength-reduce],
-    [openafs_cv_gcc_needs_no_strength_reduce],
-    [save_CFLAGS="$CFLAGS"
-     CFLAGS="-fno-strength-reduce"
-     AC_COMPILE_IFELSE(
-       [AC_LANG_PROGRAM(
-         [[]],
-         [[int x;]])],
-       [openafs_cv_gcc_needs_no_strength_reduce=yes],
-       [openafs_cv_gcc_needs_no_strength_reduce=no])
-     CFLAGS="$save_CFLAGS"
-  ])
-  AS_IF([test x$openafs_cv_gcc_needs_no_strength_reduce = xyes],
-        [LINUX_GCC_KOPTS="$LINUX_GCC_KOPTS -fno-strength-reduce"])
-])
-
-AC_DEFUN([OPENAFS_GCC_SUPPORTS_NO_COMMON], [
-  AC_CACHE_CHECK([if $CC supports -fno-common],
-    [openafs_cv_gcc_supports_no_common],
-    [save_CFLAGS="$CFLAGS"
-     CFLAGS="-fno-common"
-     AC_COMPILE_IFELSE(
-       [AC_LANG_PROGRAM(
-         [[]],
-         [[int x;]])],
-       [openafs_cv_gcc_supports_no_common=yes],
-       [openafs_cv_gcc_supports_no_common=no])
-
-     CFLAGS="$save_CFLAGS"
-  ])
-  AS_IF([test x$openafs_cv_gcc_supports_no_common = xyes],
-	[LINUX_GCC_KOPTS="$LINUX_GCC_KOPTS -fno-common"])
-])
-
-AC_DEFUN([OPENAFS_GCC_SUPPORTS_PIPE], [
-  AC_CACHE_CHECK([if $CC supports -pipe],
-    [openafs_cv_gcc_supports_pipe],
-    [save_CFLAGS="$CFLAGS"
-     CFLAGS="-pipe"
-     AC_COMPILE_IFELSE(
-       [AC_LANG_PROGRAM(
-         [[]],
-         [[int x;]])],
-       [openafs_cv_gcc_supports_pipe=yes],
-       [openafs_cv_gcc_supports_pipe=no])
-  CFLAGS="$save_CFLAGS"
-  ])
-  AS_IF([test x$openafs_cv_gcc_supports_pipe = xyes],
-	  [LINUX_GCC_KOPTS="$LINUX_GCC_KOPTS -pipe"])
-])
diff --git a/src/cf/osconf.m4 b/src/cf/osconf.m4
index 1e1b08057..173fbb6c2 100644
--- a/src/cf/osconf.m4
+++ b/src/cf/osconf.m4
@@ -665,6 +665,9 @@ CFLAGS_NOERROR=
 CFLAGS_NOSTRICT=-fno-strict-aliasing
 CFLAGS_NOUNUSED=
 CFLAGS_NOOLDSTYLE=
+CFLAGS_NOIMPLICIT_FALLTHROUGH=
+CFLAGS_NOCAST_FUNCTION_TYPE=
+CFLAGS_NODANGLING_POINTER=
 XCFLAGS_NOCHECKING="$XCFLAGS"
 
 if test "x$GCC" = "xyes"; then
@@ -673,10 +676,17 @@ if test "x$GCC" = "xyes"; then
   fi
   if test "x$enable_checking" != "xno"; then
     XCFLAGS="${XCFLAGS} -Wall -Wstrict-prototypes -Wold-style-definition -Werror -fdiagnostics-show-option -Wpointer-arith -fno-common"
+    CFLAGS_WERROR="-Werror"
     if test "x$enable_checking" != "xall"; then
       CFLAGS_NOERROR="-Wno-error"
       CFLAGS_NOUNUSED="-Wno-unused"
       CFLAGS_NOOLDSTYLE="-Wno-old-style-definition"
+      AX_APPEND_COMPILE_FLAGS([-Wno-implicit-fallthrough],
+			      [CFLAGS_NOIMPLICIT_FALLTHROUGH], [-Werror])
+      AX_APPEND_COMPILE_FLAGS([-Wno-cast-function-type],
+			      [CFLAGS_NOCAST_FUNCTION_TYPE], [-Werror])
+      AX_APPEND_COMPILE_FLAGS([-Wno-dangling-pointer],
+			      [CFLAGS_NODANGLING_POINTER], [-Werror])
       AC_DEFINE(IGNORE_SOME_GCC_WARNINGS, 1, [define to disable some gcc warnings in warnings-as-errors mode])
     else
       CFLAGS_NOSTRICT=
@@ -700,6 +710,11 @@ else
   esac
 fi
 
+dnl add additional checks if compilers support the flags
+AS_IF([test "x$enable_checking" != "xno"],
+      [AX_APPEND_COMPILE_FLAGS([-Wimplicit-fallthrough], [XCFLAGS], [-Werror])
+])
+
 dnl horribly cheating, assuming double / is ok.
 case $INSTALL in
   ./* ) 
@@ -753,6 +768,10 @@ AC_SUBST(CFLAGS_NOERROR)
 AC_SUBST(CFLAGS_NOSTRICT)
 AC_SUBST(CFLAGS_NOUNUSED)
 AC_SUBST(CFLAGS_NOOLDSTYLE)
+AC_SUBST(CFLAGS_NOIMPLICIT_FALLTHROUGH)
+AC_SUBST(CFLAGS_NOCAST_FUNCTION_TYPE)
+AC_SUBST(CFLAGS_NODANGLING_POINTER)
+AC_SUBST(CFLAGS_WERROR)
 AC_SUBST(XCFLAGS64)
 AC_SUBST(XLDFLAGS)
 AC_SUBST(XLDFLAGS64)
diff --git a/src/cf/solaris-test1.m4 b/src/cf/solaris-test1.m4
index 89fbdffa4..201445e47 100644
--- a/src/cf/solaris-test1.m4
+++ b/src/cf/solaris-test1.m4
@@ -8,17 +8,6 @@ dnl   BAD TRAP: type=7 (#nm Device not available)
 dnl
 dnl
 AC_DEFUN([SOLARIS_CC_TAKES_XVECTOR_NONE], [
-  AC_CACHE_CHECK([if $CC accepts -xvector=%none],
-    [ac_cv_solaris_cc_takes_xvector_none],
-    [save_CFLAGS="$CFLAGS"
-     CFLAGS="$CFLAGS -xvector=%none"
-     AC_COMPILE_IFELSE(
-       [AC_LANG_PROGRAM([[]], [[int x;]])],
-       [ac_cv_solaris_cc_takes_xvector_none=yes],
-       [ac_cv_solaris_cc_takes_xvector_none=no])
-     CFLAGS="$save_CFLAGS"
-    ])
-
 dnl -xvector=%none first appeared in Studio 11, but has only been
 dnl documented as required for Solaris x86 kernel code since Studio
 dnl 12.3.  Studio 12.3 is when the compiler started making more
@@ -28,11 +17,8 @@ dnl required to prevent these optimizations, it is not sufficient.
 dnl Experiments have shown that -xregs=no%float is also needed to
 dnl 1) eliminate a few optimizations not squelched by -xvector=%none,
 dnl and 2) prevent actual use of floating point types in the kernel
-dnl module.  -xregs=no%float has been present since before Studio 8, so
-dnl it is safe to assume its presence when -xvector=%none is present.
+dnl module.
 dnl
-
-  AS_IF([test "$ac_cv_solaris_cc_takes_xvector_none" = "yes"],
-        [SOLARIS_CC_KOPTS="-xvector=%none -xregs=no%float "])
+  AX_APPEND_COMPILE_FLAGS([-xvector=%none -xregs=no%float], [SOLARIS_CC_KOPTS])
 ])
 
diff --git a/src/cmd/cmd.c b/src/cmd/cmd.c
index ffe49aa74..b8694cb59 100644
--- a/src/cmd/cmd.c
+++ b/src/cmd/cmd.c
@@ -678,7 +678,7 @@ ResetSyntax(struct cmd_syndesc *as)
 	case CMD_SINGLE_OR_FLAG:
 	    if (tp->items == &dummy)
 		break;
-	    /* Deliberately fall through here */
+	    AFS_FALLTHROUGH;
 	case CMD_SINGLE:
 	case CMD_LIST:
 	    /* free whole list in both cases, just for fun */
diff --git a/src/comerr/Makefile.in b/src/comerr/Makefile.in
index b94f1c616..d906feb81 100644
--- a/src/comerr/Makefile.in
+++ b/src/comerr/Makefile.in
@@ -89,8 +89,9 @@ clean:
 		et_lex.lex.c test1.h test1.c test2.h test2.c \
 		eddep makedep core AFS_component_version_number.c
 
+.PHONY: test
 test:
-	cd test; $(MAKE)
+	cd test && $(MAKE)
 
 compile_et.o:  AFS_component_version_number.c
 # specify yacc build product as a dependency so our .c.o rule will apply
diff --git a/src/comerr/error_table.y b/src/comerr/error_table.y
index 05f524bff..6690c6520 100644
--- a/src/comerr/error_table.y
+++ b/src/comerr/error_table.y
@@ -389,6 +389,11 @@ int char_to_1num(char c)
         exit (1);
 }
 
+#if defined(IGNORE_SOME_GCC_WARNINGS) && defined(__clang__) && defined(HAVE_FUNC_ATTRIBUTE_FALLTHROUGH)
+/* flex generates fallthroughs in case blocks that get flagged by clang */
+# pragma GCC diagnostic ignored "-Wimplicit-fallthrough"
+#endif
+
 #ifdef AFS_NT40_ENV
 #include "et_lex.lex_nt.c"
 #else
diff --git a/src/config/afs_args.h b/src/config/afs_args.h
index c01679147..bf6b3ae0a 100644
--- a/src/config/afs_args.h
+++ b/src/config/afs_args.h
@@ -235,7 +235,7 @@ typedef struct cm_initparams_v1 {
 
 /* Defines and structures for the AFS proc replacement layer for the original syscall (AFS_SYSCALL) strategy */
 
-#ifdef AFS_LINUX20_ENV
+#ifdef AFS_LINUX_ENV
 
 #define PROC_FSDIRNAME "openafs"
 #define PROC_SYSCALL_NAME "afs_ioctl"
diff --git a/src/config/afs_sysnames.h b/src/config/afs_sysnames.h
index ae20e3d40..2dd4d29ba 100644
--- a/src/config/afs_sysnames.h
+++ b/src/config/afs_sysnames.h
@@ -248,6 +248,7 @@
 #define SYS_NAME_ID_i386_fbsd_120      2160
 #define SYS_NAME_ID_i386_fbsd_121      2161
 #define SYS_NAME_ID_i386_fbsd_122      2162
+#define SYS_NAME_ID_i386_fbsd_123      2163
 
 #define SYS_NAME_ID_ia64_linux2		2200
 #define SYS_NAME_ID_ia64_linux22	2201
@@ -365,6 +366,7 @@
 #define SYS_NAME_ID_amd64_fbsd_120     3060
 #define SYS_NAME_ID_amd64_fbsd_121     3061
 #define SYS_NAME_ID_amd64_fbsd_122     3062
+#define SYS_NAME_ID_amd64_fbsd_123     3063
 
 #define SYS_NAME_ID_amd64_w2k           3400
 
diff --git a/src/config/param.alpha_linux_26.h b/src/config/param.alpha_linux_26.h
index 62ffd99b0..55ae09f41 100644
--- a/src/config/param.alpha_linux_26.h
+++ b/src/config/param.alpha_linux_26.h
@@ -13,10 +13,7 @@
 #ifndef UKERNEL
 
 /* This section for kernel libafs compiles only */
-#define AFS_ALPHA_LINUX20_ENV	1
-#define AFS_ALPHA_LINUX22_ENV	1
-#define AFS_ALPHA_LINUX24_ENV	1
-#define AFS_ALPHA_LINUX26_ENV	1
+#define AFS_ALPHA_LINUX_ENV	1
 #define __alpha			1
 #define AFS_LINUX_64BIT_KERNEL	1
 #define AFS_64BITPOINTER_ENV	1	/* pointers are 64 bits */
diff --git a/src/config/param.amd64_fbsd_123.h b/src/config/param.amd64_fbsd_123.h
new file mode 100644
index 000000000..938819840
--- /dev/null
+++ b/src/config/param.amd64_fbsd_123.h
@@ -0,0 +1,56 @@
+#ifndef	AFS_PARAM_H
+#define	AFS_PARAM_H
+
+/* Machine / Operating system information */
+#define SYS_NAME	"amd64_fbsd_123"
+#define SYS_NAME_ID	SYS_NAME_ID_amd64_fbsd_123
+
+#define AFS_64BITPOINTER_ENV 1
+
+#ifndef UKERNEL
+/* This section for kernel libafs compiles only */
+
+#define AFS_64BITUSERPOINTER_ENV 1
+
+#define AFS_FBSD101_ENV 1
+#define AFS_FBSD102_ENV 1
+#define AFS_FBSD103_ENV 1
+#define AFS_FBSD104_ENV 1
+#define AFS_FBSD110_ENV 1
+#define AFS_FBSD111_ENV 1
+#define AFS_FBSD120_ENV 1
+#define AFS_FBSD121_ENV 1
+#define AFS_FBSD122_ENV 1
+#define AFS_FBSD123_ENV 1
+
+#define AFS_X86_FBSD101_ENV 1
+#define AFS_X86_FBSD102_ENV 1
+#define AFS_X86_FBSD103_ENV 1
+#define AFS_X86_FBSD104_ENV 1
+#define AFS_X86_FBSD110_ENV 1
+#define AFS_X86_FBSD111_ENV 1
+#define AFS_X86_FBSD120_ENV 1
+#define AFS_X86_FBSD121_ENV 1
+#define AFS_X86_FBSD122_ENV 1
+#define AFS_X86_FBSD123_ENV 1
+
+#else /* !defined(UKERNEL) */
+
+/* This section for user space compiles only */
+
+#define AFS_USR_FBSD101_ENV 1
+#define AFS_USR_FBSD102_ENV 1
+#define AFS_USR_FBSD103_ENV 1
+#define AFS_USR_FBSD104_ENV 1
+#define AFS_USR_FBSD110_ENV 1
+#define AFS_USR_FBSD111_ENV 1
+#define AFS_USR_FBSD120_ENV 1
+#define AFS_USR_FBSD121_ENV 1
+#define AFS_USR_FBSD122_ENV 1
+#define AFS_USR_FBSD123_ENV 1
+
+#endif /* !defined(UKERNEL) */
+
+#define USE_UCONTEXT
+
+#endif /* AFS_PARAM_H */
diff --git a/src/config/param.amd64_linux26.h b/src/config/param.amd64_linux26.h
index c14657aa7..09e5287e1 100644
--- a/src/config/param.amd64_linux26.h
+++ b/src/config/param.amd64_linux26.h
@@ -13,10 +13,7 @@
 #ifndef UKERNEL
 
 /* This section for kernel libafs compiles only */
-#define AFS_AMD64_LINUX20_ENV	1
-#define AFS_AMD64_LINUX22_ENV	1
-#define AFS_AMD64_LINUX24_ENV	1
-#define AFS_AMD64_LINUX26_ENV	1
+#define AFS_AMD64_LINUX_ENV	1
 #define AFS_LINUX_64BIT_KERNEL	1
 #define AFS_64BITPOINTER_ENV	1	/* pointers are 64 bits */
 #define AFS_64BITUSERPOINTER_ENV	1
diff --git a/src/config/param.arm64_linux26.h b/src/config/param.arm64_linux26.h
index 02e867a33..fa5b39f11 100644
--- a/src/config/param.arm64_linux26.h
+++ b/src/config/param.arm64_linux26.h
@@ -13,7 +13,7 @@
 #ifndef UKERNEL
 
 /* This section for kernel libafs compiles only */
-#define AFS_ARM64_LINUX26_ENV	1
+#define AFS_ARM64_LINUX_ENV	1
 #define AFS_LINUX_64BIT_KERNEL	1
 #define AFS_64BITPOINTER_ENV	1	/* pointers are 64 bits */
 #define AFS_64BITUSERPOINTER_ENV	1
diff --git a/src/config/param.arm_darwin_100.h b/src/config/param.arm_darwin_100.h
index 2344be0b8..2783416b4 100644
--- a/src/config/param.arm_darwin_100.h
+++ b/src/config/param.arm_darwin_100.h
@@ -133,7 +133,6 @@ struct rt_addrinfo {
 #define AFS_UIOSYS      UIO_SYSSPACE
 #define AFS_UIOUSER     UIO_USERSPACE
 #define AFS_CLBYTES     CLBYTES
-#define osi_GetTime(x)  microtime(x)
 #define AFS_KALLOC(x)   _MALLOC(x, M_TEMP, M_WAITOK)
 #define AFS_KFREE(x,y)  _FREE(x,M_TEMP)
 #define v_count         v_usecount
diff --git a/src/config/param.arm_linux26.h b/src/config/param.arm_linux26.h
index 1339fd0fc..2b3248826 100644
--- a/src/config/param.arm_linux26.h
+++ b/src/config/param.arm_linux26.h
@@ -13,10 +13,7 @@
 #ifndef UKERNEL
 
 /* This section for kernel libafs compiles only */
-#define AFS_ARM_LINUX20_ENV	1
-#define AFS_ARM_LINUX22_ENV	1
-#define AFS_ARM_LINUX24_ENV	1
-#define AFS_ARM_LINUX26_ENV	1
+#define AFS_ARM_LINUX_ENV	1
 
 #else /* !defined(UKERNEL) */
 
diff --git a/src/config/param.generic_fbsd.h b/src/config/param.generic_fbsd.h
index 6d1665761..94ec0683b 100644
--- a/src/config/param.generic_fbsd.h
+++ b/src/config/param.generic_fbsd.h
@@ -68,7 +68,6 @@
 #define	AFS_UIOSYS		UIO_SYSSPACE
 #define	AFS_UIOUSER		UIO_USERSPACE
 #define	AFS_CLBYTES		CLBYTES
-#define	osi_GetTime(x)		microtime(x)
 #define AFS_KALLOC(x)		osi_fbsd_alloc((x), 1)
 #undef AFS_KALLOC_NOSLEEP
 #define	AFS_KALLOC_NOSLEEP(x) 	osi_fbsd_alloc((x), 0)
diff --git a/src/config/param.hp_ux102.h b/src/config/param.hp_ux102.h
index bf83b16bd..93fd121d5 100644
--- a/src/config/param.hp_ux102.h
+++ b/src/config/param.hp_ux102.h
@@ -63,7 +63,6 @@
 #define	AFS_UIOUSER	UIOSEG_USER
 #define	AFS_CLBYTES	CLBYTES
 #define	AFS_MINCHANGE	2
-#define	osi_GetTime(x)	do { struct timeval osi_GetTimeVar; uniqtime(&osi_GetTimeVar); (x)->tv_sec = osi_GetTimeVar.tv_sec; (x)->tv_usec = osi_GetTimeVar.tv_usec; } while(0)
 #define	AFS_KALLOC	kmem_alloc
 #define	AFS_KFREE	kmem_free
 #define	VATTR_NULL	vattr_null
diff --git a/src/config/param.hp_ux110.h b/src/config/param.hp_ux110.h
index 8f0616b0a..ca541f955 100644
--- a/src/config/param.hp_ux110.h
+++ b/src/config/param.hp_ux110.h
@@ -64,7 +64,6 @@
 #define	AFS_UIOUSER	UIOSEG_USER
 #define	AFS_CLBYTES	CLBYTES
 #define	AFS_MINCHANGE	2
-#define	osi_GetTime(x)	do { struct timeval osi_GetTimeVar; uniqtime(&osi_GetTimeVar); (x)->tv_sec = osi_GetTimeVar.tv_sec; (x)->tv_usec = osi_GetTimeVar.tv_usec; } while(0)
 #define	AFS_KALLOC	kmem_alloc
 #define	AFS_KFREE	kmem_free
 #define	VATTR_NULL	vattr_null
diff --git a/src/config/param.hp_ux1123.h b/src/config/param.hp_ux1123.h
index fd5246c01..1ac65ab72 100644
--- a/src/config/param.hp_ux1123.h
+++ b/src/config/param.hp_ux1123.h
@@ -69,7 +69,6 @@
 #define	AFS_UIOUSER	UIOSEG_USER
 #define	AFS_CLBYTES	CLBYTES
 #define	AFS_MINCHANGE	2
-#define	osi_GetTime(x)	do { struct timeval osi_GetTimeVar; uniqtime(&osi_GetTimeVar); (x)->tv_sec = osi_GetTimeVar.tv_sec; (x)->tv_usec = osi_GetTimeVar.tv_usec; } while(0)
 #define	AFS_KALLOC	kmem_alloc
 #define	AFS_KFREE	kmem_free
 #define	VATTR_NULL	vattr_null
diff --git a/src/config/param.hp_ux11i.h b/src/config/param.hp_ux11i.h
index 074db768c..9a76aec1e 100644
--- a/src/config/param.hp_ux11i.h
+++ b/src/config/param.hp_ux11i.h
@@ -68,7 +68,6 @@
 #define	AFS_UIOUSER	UIOSEG_USER
 #define	AFS_CLBYTES	CLBYTES
 #define	AFS_MINCHANGE	2
-#define	osi_GetTime(x)	do { struct timeval osi_GetTimeVar; uniqtime(&osi_GetTimeVar); (x)->tv_sec = osi_GetTimeVar.tv_sec; (x)->tv_usec = osi_GetTimeVar.tv_usec; } while(0)
 #define	AFS_KALLOC	kmem_alloc
 #define	AFS_KFREE	kmem_free
 #define	VATTR_NULL	vattr_null
diff --git a/src/config/param.i386_fbsd_123.h b/src/config/param.i386_fbsd_123.h
new file mode 100644
index 000000000..be51d6d63
--- /dev/null
+++ b/src/config/param.i386_fbsd_123.h
@@ -0,0 +1,52 @@
+#ifndef	AFS_PARAM_H
+#define	AFS_PARAM_H
+
+/* Machine / Operating system information */
+#define SYS_NAME	"i386_fbsd_123"
+#define SYS_NAME_ID	SYS_NAME_ID_i386_fbsd_123
+
+#define AFS_FAKEOPEN_ENV 1	/* call afs_FakeOpen as if !AFS_VM_RDWR */
+
+#ifndef UKERNEL
+/* This section for kernel libafs compiles only */
+
+#define AFS_FBSD101_ENV 1
+#define AFS_FBSD102_ENV 1
+#define AFS_FBSD103_ENV 1
+#define AFS_FBSD104_ENV 1
+#define AFS_FBSD110_ENV 1
+#define AFS_FBSD111_ENV 1
+#define AFS_FBSD120_ENV 1
+#define AFS_FBSD121_ENV 1
+#define AFS_FBSD122_ENV 1
+#define AFS_FBSD123_ENV 1
+
+#define AFS_X86_FBSD101_ENV 1
+#define AFS_X86_FBSD102_ENV 1
+#define AFS_X86_FBSD103_ENV 1
+#define AFS_X86_FBSD104_ENV 1
+#define AFS_X86_FBSD110_ENV 1
+#define AFS_X86_FBSD111_ENV 1
+#define AFS_X86_FBSD120_ENV 1
+#define AFS_X86_FBSD121_ENV 1
+#define AFS_X86_FBSD122_ENV 1
+#define AFS_X86_FBSD123_ENV 1
+
+#else /* !defined(UKERNEL) */
+
+/* This section for user space compiles only */
+
+#define AFS_USR_FBSD101_ENV 1
+#define AFS_USR_FBSD102_ENV 1
+#define AFS_USR_FBSD103_ENV 1
+#define AFS_USR_FBSD104_ENV 1
+#define AFS_USR_FBSD110_ENV 1
+#define AFS_USR_FBSD111_ENV 1
+#define AFS_USR_FBSD120_ENV 1
+#define AFS_USR_FBSD121_ENV 1
+#define AFS_USR_FBSD122_ENV 1
+#define AFS_USR_FBSD123_ENV 1
+
+#endif /* !defined(UKERNEL) */
+
+#endif /* AFS_PARAM_H */
diff --git a/src/config/param.i386_linux26.h b/src/config/param.i386_linux26.h
index 35ff06698..48ad0b936 100644
--- a/src/config/param.i386_linux26.h
+++ b/src/config/param.i386_linux26.h
@@ -13,10 +13,7 @@
 #ifndef UKERNEL
 
 /* This section for kernel libafs compiles only */
-#define AFS_I386_LINUX20_ENV	1
-#define AFS_I386_LINUX22_ENV	1
-#define AFS_I386_LINUX24_ENV	1
-#define AFS_I386_LINUX26_ENV	1
+#define AFS_I386_LINUX_ENV	1
 
 #else /* !defined(UKERNEL) */
 
diff --git a/src/config/param.i386_umlinux26.h b/src/config/param.i386_umlinux26.h
index 8b70ae607..090c35542 100644
--- a/src/config/param.i386_umlinux26.h
+++ b/src/config/param.i386_umlinux26.h
@@ -13,10 +13,7 @@
 #ifndef UKERNEL
 
 /* This section for kernel libafs compiles only */
-#define AFS_I386_LINUX20_ENV	1
-#define AFS_I386_LINUX22_ENV	1
-#define AFS_I386_LINUX24_ENV	1
-#define AFS_I386_LINUX26_ENV	1
+#define AFS_I386_LINUX_ENV	1
 
 #else /* !defined(UKERNEL) */
 
diff --git a/src/config/param.ia64_hpux1122.h b/src/config/param.ia64_hpux1122.h
index 82435e831..d659b4931 100644
--- a/src/config/param.ia64_hpux1122.h
+++ b/src/config/param.ia64_hpux1122.h
@@ -68,7 +68,6 @@
 #define	AFS_UIOUSER	UIOSEG_USER
 #define	AFS_CLBYTES	CLBYTES
 #define	AFS_MINCHANGE	2
-#define	osi_GetTime(x)	do { struct timeval osi_GetTimeVar; uniqtime(&osi_GetTimeVar); (x)->tv_sec = osi_GetTimeVar.tv_sec; (x)->tv_usec = osi_GetTimeVar.tv_usec; } while(0)
 #define	AFS_KALLOC	kmem_alloc
 #define	AFS_KFREE	kmem_free
 #define	VATTR_NULL	vattr_null
diff --git a/src/config/param.ia64_hpux1123.h b/src/config/param.ia64_hpux1123.h
index 00b513fe7..5931bc80a 100644
--- a/src/config/param.ia64_hpux1123.h
+++ b/src/config/param.ia64_hpux1123.h
@@ -69,7 +69,6 @@
 #define	AFS_UIOUSER	UIOSEG_USER
 #define	AFS_CLBYTES	CLBYTES
 #define	AFS_MINCHANGE	2
-#define	osi_GetTime(x)	do { struct timeval osi_GetTimeVar; uniqtime(&osi_GetTimeVar); (x)->tv_sec = osi_GetTimeVar.tv_sec; (x)->tv_usec = osi_GetTimeVar.tv_usec; } while(0)
 #define	AFS_KALLOC	kmem_alloc
 #define	AFS_KFREE	kmem_free
 #define	VATTR_NULL	vattr_null
diff --git a/src/config/param.ia64_linux26.h b/src/config/param.ia64_linux26.h
index 04e3fd77e..402af6a11 100644
--- a/src/config/param.ia64_linux26.h
+++ b/src/config/param.ia64_linux26.h
@@ -13,10 +13,7 @@
 #ifndef UKERNEL
 
 /* This section for kernel libafs compiles only */
-#define AFS_IA64_LINUX20_ENV	1
-#define AFS_IA64_LINUX22_ENV	1
-#define AFS_IA64_LINUX24_ENV	1
-#define AFS_IA64_LINUX26_ENV	1
+#define AFS_IA64_LINUX_ENV	1
 #define AFS_LINUX_64BIT_KERNEL	1
 #define AFS_64BITPOINTER_ENV	1	/* pointers are 64 bits. */
 #define AFS_64BITUSERPOINTER_ENV	1
diff --git a/src/config/param.linux26.h b/src/config/param.linux26.h
index 2054d8963..05686f057 100644
--- a/src/config/param.linux26.h
+++ b/src/config/param.linux26.h
@@ -15,10 +15,7 @@
 /* This section for kernel libafs compiles only */
 #include <linux/version.h>
 
-#define AFS_LINUX20_ENV		1
-#define AFS_LINUX22_ENV		1
-#define AFS_LINUX24_ENV		1
-#define AFS_LINUX26_ENV		1
+#define AFS_LINUX_ENV		1
 
 #define AFS_MOUNT_AFS		"afs"	/* The name of the filesystem type */
 #define AFS_64BIT_IOPS_ENV	1
@@ -64,10 +61,8 @@
 #else /* !defined(UKERNEL) */
 
 /* This section for user space compiles only */
-#define AFS_USR_LINUX20_ENV	1
-#define AFS_USR_LINUX22_ENV	1
-#define AFS_USR_LINUX24_ENV	1
-#define AFS_USR_LINUX26_ENV	1
+
+#define AFS_USR_LINUX_ENV	1
 
 #define AFS_ENV			1
 #define AFS_64BIT_CLIENT	1
diff --git a/src/config/param.nbsd15.h b/src/config/param.nbsd15.h
index 905a1c107..9714ee609 100644
--- a/src/config/param.nbsd15.h
+++ b/src/config/param.nbsd15.h
@@ -67,7 +67,6 @@
 #define	AFS_UIOSYS	UIO_SYSSPACE
 #define	AFS_UIOUSER	UIO_USERSPACE
 #define	AFS_CLBYTES	CLBYTES
-#define	osi_GetTime(x)	microtime(x)
 #define	AFS_KALLOC(x)	kalloc(x)
 #define	AFS_KFREE(x,y)	kfree(x,y)
 #define	v_count		v_usecount
diff --git a/src/config/param.nbsd16.h b/src/config/param.nbsd16.h
index bb88fe200..6694be28a 100644
--- a/src/config/param.nbsd16.h
+++ b/src/config/param.nbsd16.h
@@ -68,7 +68,6 @@
 #define	AFS_UIOSYS	UIO_SYSSPACE
 #define	AFS_UIOUSER	UIO_USERSPACE
 #define	AFS_CLBYTES	CLBYTES
-#define	osi_GetTime(x)	microtime(x)
 #define	AFS_KALLOC(x)	kalloc(x)
 #define	AFS_KFREE(x,y)	kfree(x,y)
 #define	v_count		v_usecount
diff --git a/src/config/param.nbsd20.h b/src/config/param.nbsd20.h
index 07e741567..c294b77b2 100644
--- a/src/config/param.nbsd20.h
+++ b/src/config/param.nbsd20.h
@@ -74,7 +74,6 @@
 #define	AFS_UIOSYS	UIO_SYSSPACE
 #define	AFS_UIOUSER	UIO_USERSPACE
 #define	AFS_CLBYTES	CLBYTES
-#define	osi_GetTime(x)	microtime(x)
 #define	AFS_KALLOC(x)	kalloc(x)
 #define	AFS_KFREE(x,y)	kfree(x,y)
 #define	v_count		v_usecount
diff --git a/src/config/param.nbsd21.h b/src/config/param.nbsd21.h
index bb63588df..7de8d329a 100644
--- a/src/config/param.nbsd21.h
+++ b/src/config/param.nbsd21.h
@@ -74,7 +74,6 @@
 #define	AFS_UIOSYS	UIO_SYSSPACE
 #define	AFS_UIOUSER	UIO_USERSPACE
 #define	AFS_CLBYTES	CLBYTES
-#define	osi_GetTime(x)	microtime(x)
 #define	AFS_KALLOC(x)	kalloc(x)
 #define	AFS_KFREE(x,y)	kfree(x,y)
 #define	v_count		v_usecount
diff --git a/src/config/param.nbsd30.h b/src/config/param.nbsd30.h
index 95a1c0246..2c67a8ff9 100644
--- a/src/config/param.nbsd30.h
+++ b/src/config/param.nbsd30.h
@@ -70,7 +70,6 @@
 #define	AFS_UIOSYS	UIO_SYSSPACE
 #define	AFS_UIOUSER	UIO_USERSPACE
 #define	AFS_CLBYTES	CLBYTES
-#define	osi_GetTime(x)	microtime(x)
 #define	AFS_KALLOC(x)	kalloc(x)
 #define	AFS_KFREE(x,y)	kfree(x,y)
 #define	v_count		v_usecount
diff --git a/src/config/param.nbsd40.h b/src/config/param.nbsd40.h
index adb4ae6e6..076160707 100644
--- a/src/config/param.nbsd40.h
+++ b/src/config/param.nbsd40.h
@@ -72,7 +72,6 @@
 #define	AFS_UIOSYS	UIO_SYSSPACE
 #define	AFS_UIOUSER	UIO_USERSPACE
 #define	AFS_CLBYTES	CLBYTES
-#define	osi_GetTime(x)	microtime(x)
 #define	AFS_KALLOC(x)	kalloc(x)
 #define	AFS_KFREE(x,y)	kfree(x,y)
 #define	v_count		v_usecount
diff --git a/src/config/param.nbsd50.h b/src/config/param.nbsd50.h
index e8c1f0766..0be55a184 100644
--- a/src/config/param.nbsd50.h
+++ b/src/config/param.nbsd50.h
@@ -70,7 +70,6 @@
 #define	AFS_UIOSYS	UIO_SYSSPACE
 #define	AFS_UIOUSER	UIO_USERSPACE
 #define	AFS_CLBYTES	CLBYTES
-#define	osi_GetTime(x)	microtime(x)
 #define	AFS_KALLOC(x)	kalloc(x)
 #define	AFS_KFREE(x,y)	kfree(x,y)
 #define	v_count		v_usecount
diff --git a/src/config/param.nbsd60.h b/src/config/param.nbsd60.h
index 29519c82d..f6a1aef6e 100644
--- a/src/config/param.nbsd60.h
+++ b/src/config/param.nbsd60.h
@@ -71,7 +71,6 @@
 #define	AFS_UIOSYS	UIO_SYSSPACE
 #define	AFS_UIOUSER	UIO_USERSPACE
 #define	AFS_CLBYTES	CLBYTES
-#define	osi_GetTime(x)	microtime(x)
 #define	AFS_KALLOC(x)	kalloc(x)
 #define	AFS_KFREE(x,y)	kfree(x,y)
 #define	v_count		v_usecount
diff --git a/src/config/param.nbsd70.h b/src/config/param.nbsd70.h
index 4395bab05..ac5b98d39 100644
--- a/src/config/param.nbsd70.h
+++ b/src/config/param.nbsd70.h
@@ -72,7 +72,6 @@
 #define	AFS_UIOSYS	UIO_SYSSPACE
 #define	AFS_UIOUSER	UIO_USERSPACE
 #define	AFS_CLBYTES	CLBYTES
-#define	osi_GetTime(x)	microtime(x)
 #define	AFS_KALLOC(x)	kalloc(x)
 #define	AFS_KFREE(x,y)	kfree(x,y)
 #define	v_count		v_usecount
diff --git a/src/config/param.ppc64_linux26.h b/src/config/param.ppc64_linux26.h
index 3c833868c..3ac7d3d20 100644
--- a/src/config/param.ppc64_linux26.h
+++ b/src/config/param.ppc64_linux26.h
@@ -12,10 +12,7 @@
 
 #ifndef UKERNEL
 /* This section for kernel space compiles only */
-#define AFS_PPC64_LINUX20_ENV	1
-#define AFS_PPC64_LINUX22_ENV	1
-#define AFS_PPC64_LINUX24_ENV	1
-#define AFS_PPC64_LINUX26_ENV	1
+#define AFS_PPC64_LINUX_ENV	1
 #define AFS_LINUX_64BIT_KERNEL	1
 #define AFS_64BITPOINTER_ENV	1     /* pointers are 64 bits */
 #define AFS_64BITUSERPOINTER_ENV	1
diff --git a/src/config/param.ppc64le_linux26.h b/src/config/param.ppc64le_linux26.h
index 9c8b8224d..ca3aba85f 100644
--- a/src/config/param.ppc64le_linux26.h
+++ b/src/config/param.ppc64le_linux26.h
@@ -12,10 +12,7 @@
 
 #ifndef UKERNEL
 /* This section for kernel space compiles only */
-#define AFS_PPC64_LINUX20_ENV	1
-#define AFS_PPC64_LINUX22_ENV	1
-#define AFS_PPC64_LINUX24_ENV	1
-#define AFS_PPC64_LINUX26_ENV	1
+#define AFS_PPC64_LINUX_ENV	1
 #define AFS_LINUX_64BIT_KERNEL	1
 #define AFS_64BITPOINTER_ENV	1     /* pointers are 64 bits */
 #define AFS_64BITUSERPOINTER_ENV	1
diff --git a/src/config/param.ppc_darwin_70.h b/src/config/param.ppc_darwin_70.h
index e72b317f0..7a71a32c5 100644
--- a/src/config/param.ppc_darwin_70.h
+++ b/src/config/param.ppc_darwin_70.h
@@ -50,7 +50,6 @@
 #define AFS_UIOSYS      UIO_SYSSPACE
 #define AFS_UIOUSER     UIO_USERSPACE
 #define AFS_CLBYTES     CLBYTES
-#define osi_GetTime(x)  microtime(x)
 #define AFS_KALLOC(x)   kalloc(x)
 #define AFS_KFREE(x,y)  kfree(x,y)
 #define v_count         v_usecount
diff --git a/src/config/param.ppc_darwin_80.h b/src/config/param.ppc_darwin_80.h
index 874353010..7b4a4d1f9 100644
--- a/src/config/param.ppc_darwin_80.h
+++ b/src/config/param.ppc_darwin_80.h
@@ -75,7 +75,6 @@
 #define AFS_UIOSYS      UIO_SYSSPACE
 #define AFS_UIOUSER     UIO_USERSPACE
 #define AFS_CLBYTES     CLBYTES
-#define osi_GetTime(x)  microtime(x)
 #define AFS_KALLOC(x)   _MALLOC(x, M_TEMP, M_WAITOK)
 #define AFS_KFREE(x,y)  _FREE(x,M_TEMP)
 #define v_count         v_usecount
diff --git a/src/config/param.ppc_darwin_90.h b/src/config/param.ppc_darwin_90.h
index 01e3ad135..bce4212c2 100644
--- a/src/config/param.ppc_darwin_90.h
+++ b/src/config/param.ppc_darwin_90.h
@@ -80,7 +80,6 @@
 #define AFS_UIOSYS      UIO_SYSSPACE
 #define AFS_UIOUSER     UIO_USERSPACE
 #define AFS_CLBYTES     CLBYTES
-#define osi_GetTime(x)  microtime(x)
 #define AFS_KALLOC(x)   _MALLOC(x, M_TEMP, M_WAITOK)
 #define AFS_KFREE(x,y)  _FREE(x,M_TEMP)
 #define v_count         v_usecount
diff --git a/src/config/param.ppc_linux26.h b/src/config/param.ppc_linux26.h
index fd6ee4521..60fcb2843 100644
--- a/src/config/param.ppc_linux26.h
+++ b/src/config/param.ppc_linux26.h
@@ -13,10 +13,7 @@
 #ifndef UKERNEL
 
 /* This section for kernel libafs compiles only */
-#define AFS_PPC_LINUX20_ENV	1
-#define AFS_PPC_LINUX22_ENV	1
-#define AFS_PPC_LINUX24_ENV	1
-#define AFS_PPC_LINUX26_ENV	1
+#define AFS_PPC_LINUX_ENV	1
 
 #else /* !defined(UKERNEL) */
 
diff --git a/src/config/param.rs_aix42.h b/src/config/param.rs_aix42.h
index b993bb5eb..dc38566aa 100644
--- a/src/config/param.rs_aix42.h
+++ b/src/config/param.rs_aix42.h
@@ -68,7 +68,6 @@
 #define	AFS_UIOUSER	UIO_USERSPACE
 #define	AFS_CLBYTES	CLBYTES
 #define	AFS_MINCHANGE	2
-#define osi_GetTime(x)          do {curtime(x); (x)->tv_usec = (x)->tv_usec/1000;} while (0)
 #define	osi_GTime(x)	time	/* something for the silly time(0)?? */
 #define	AFS_KALLOC	kmem_alloc
 #define	AFS_KFREE	kmem_free
diff --git a/src/config/param.rs_aix51.h b/src/config/param.rs_aix51.h
index 6e265010e..08304c9eb 100644
--- a/src/config/param.rs_aix51.h
+++ b/src/config/param.rs_aix51.h
@@ -69,7 +69,6 @@
 #define	AFS_UIOUSER	UIO_USERSPACE
 #define	AFS_CLBYTES	CLBYTES
 #define	AFS_MINCHANGE	2
-#define osi_GetTime(x)          do {curtime(x); (x)->tv_usec = (x)->tv_usec/1000;} while (0)
 #define	osi_GTime(x)	time	/* something for the silly time(0)?? */
 #define	AFS_KALLOC	kmem_alloc
 #define	AFS_KFREE	kmem_free
diff --git a/src/config/param.rs_aix52.h b/src/config/param.rs_aix52.h
index cd9f29d78..4a6487973 100644
--- a/src/config/param.rs_aix52.h
+++ b/src/config/param.rs_aix52.h
@@ -70,7 +70,6 @@
 #define	AFS_UIOUSER	UIO_USERSPACE
 #define	AFS_CLBYTES	CLBYTES
 #define	AFS_MINCHANGE	2
-#define osi_GetTime(x)          do {curtime(x); (x)->tv_usec = (x)->tv_usec/1000;} while (0)
 #define	osi_GTime(x)	time	/* something for the silly time(0)?? */
 #define	AFS_KALLOC	kmem_alloc
 #define	AFS_KFREE	kmem_free
diff --git a/src/config/param.rs_aix53.h b/src/config/param.rs_aix53.h
index 8cec48395..382af535e 100644
--- a/src/config/param.rs_aix53.h
+++ b/src/config/param.rs_aix53.h
@@ -71,7 +71,6 @@
 #define	AFS_UIOUSER	UIO_USERSPACE
 #define	AFS_CLBYTES	CLBYTES
 #define	AFS_MINCHANGE	2
-#define osi_GetTime(x)          do {curtime(x); (x)->tv_usec = (x)->tv_usec/1000;} while (0)
 #define	osi_GTime(x)	time	/* something for the silly time(0)?? */
 #define	AFS_KALLOC	kmem_alloc
 #define	AFS_KFREE	kmem_free
diff --git a/src/config/param.rs_aix61.h b/src/config/param.rs_aix61.h
index 85fbdc8ba..868fe9f3d 100644
--- a/src/config/param.rs_aix61.h
+++ b/src/config/param.rs_aix61.h
@@ -72,7 +72,6 @@
 #define	AFS_UIOUSER	UIO_USERSPACE
 #define	AFS_CLBYTES	CLBYTES
 #define	AFS_MINCHANGE	2
-#define osi_GetTime(x)          do {curtime(x); (x)->tv_usec = (x)->tv_usec/1000;} while (0)
 #define	osi_GTime(x)	time	/* something for the silly time(0)?? */
 #define	AFS_KALLOC	kmem_alloc
 #define	AFS_KFREE	kmem_free
diff --git a/src/config/param.s390_linux26.h b/src/config/param.s390_linux26.h
index 6757c4cd1..cd2ba4da1 100644
--- a/src/config/param.s390_linux26.h
+++ b/src/config/param.s390_linux26.h
@@ -13,10 +13,7 @@
 #ifndef UKERNEL
 
 /* This section for kernel libafs compiles only */
-#define AFS_S390_LINUX20_ENV	1
-#define AFS_S390_LINUX22_ENV	1
-#define AFS_S390_LINUX24_ENV	1
-#define AFS_S390_LINUX26_ENV	1
+#define AFS_S390_LINUX_ENV	1
 
 #else /* !defined(UKERNEL) */
 
diff --git a/src/config/param.s390x_linux26.h b/src/config/param.s390x_linux26.h
index 1606c230c..cc65dbd95 100644
--- a/src/config/param.s390x_linux26.h
+++ b/src/config/param.s390x_linux26.h
@@ -13,14 +13,8 @@
 #ifndef UKERNEL
 
 /* This section for kernel libafs compiles only */
-#define AFS_S390_LINUX20_ENV	1
-#define AFS_S390_LINUX22_ENV	1
-#define AFS_S390_LINUX24_ENV	1
-#define AFS_S390_LINUX26_ENV	1
-#define AFS_S390X_LINUX20_ENV	1
-#define AFS_S390X_LINUX22_ENV	1
-#define AFS_S390X_LINUX24_ENV	1
-#define AFS_S390X_LINUX26_ENV	1
+#define AFS_S390_LINUX_ENV	1
+#define AFS_S390X_LINUX_ENV	1
 
 #define AFS_64BITPOINTER_ENV	1
 #define AFS_64BITUSERPOINTER_ENV	1
@@ -30,10 +24,7 @@
 
 /* This section for user space compiles only */
 #define UKERNEL			1	/* user space kernel */
-#define AFS_S390X_LINUX20_ENV	1
-#define AFS_S390X_LINUX22_ENV	1
-#define AFS_S390X_LINUX24_ENV	1
-#define AFS_S390X_LINUX26_ENV	1
+#define AFS_S390X_LINUX_ENV	1
 
 #define AFS_64BITPOINTER_ENV	1
 #define AFS_64BITUSERPOINTER_ENV	1
diff --git a/src/config/param.sgi_65.h b/src/config/param.sgi_65.h
index 35961964b..bd40c4bd4 100644
--- a/src/config/param.sgi_65.h
+++ b/src/config/param.sgi_65.h
@@ -91,11 +91,6 @@
 #define	AFS_UIOUSER	UIO_USERSPACE
 #define	AFS_CLBYTES	MCLBYTES
 #define	AFS_MINCHANGE	2
-#ifdef _K64U64
-#define	osi_GetTime(x)	irix5_microtime((struct __irix5_timeval*)(x))
-#else
-#define	osi_GetTime(x)	microtime(x)
-#endif
 #define	AFS_KALLOC(n)	kmem_alloc(n, KM_SLEEP)
 #define	AFS_KALLOC_NOSLEEP(n)	kmem_alloc(n, KM_NOSLEEP)
 #define	AFS_KFREE	kmem_free
diff --git a/src/config/param.sparc64_linux26.h b/src/config/param.sparc64_linux26.h
index c51b66d07..9e90cbaa6 100644
--- a/src/config/param.sparc64_linux26.h
+++ b/src/config/param.sparc64_linux26.h
@@ -12,10 +12,7 @@
 
 #ifndef UKERNEL
 /* This section for kernel libafs compiles only */
-#define AFS_SPARC64_LINUX20_ENV	1
-#define AFS_SPARC64_LINUX22_ENV	1
-#define AFS_SPARC64_LINUX24_ENV	1
-#define AFS_SPARC64_LINUX26_ENV	1
+#define AFS_SPARC64_LINUX_ENV	1
 #define AFS_LINUX_64BIT_KERNEL	1
 #define AFS_64BITPOINTER_ENV	1	/* pointers are 64 bits. */
 #define AFS_32BIT_USR_ENV	1	/* user level processes are 32bit */
diff --git a/src/config/param.sparc_linux26.h b/src/config/param.sparc_linux26.h
index 349907e6d..82dd98dfe 100644
--- a/src/config/param.sparc_linux26.h
+++ b/src/config/param.sparc_linux26.h
@@ -12,9 +12,7 @@
 
 #ifndef UKERNEL
 /* This section for kernel libafs compiles only */
-#define AFS_SPARC_LINUX20_ENV	1
-#define AFS_SPARC_LINUX22_ENV	1
-#define AFS_SPARC_LINUX24_ENV	1
+#define AFS_SPARC_LINUX_ENV	1
 
 #if defined(__KERNEL__) && !defined(KDUMP_KERNEL)
 #if defined(AFS_SMP) && defined(CONFIG_MODVERSIONS)
diff --git a/src/config/param.sun4x_510.h b/src/config/param.sun4x_510.h
index 6a5e06113..803ea2a51 100644
--- a/src/config/param.sun4x_510.h
+++ b/src/config/param.sun4x_510.h
@@ -74,7 +74,6 @@
 #define	AFS_UIOUSER		UIO_USERSPACE
 #define	AFS_CLBYTES		MCLBYTES
 #define	AFS_MINCHANGE		2
-#define	osi_GetTime(x)		uniqtime32(x)
 
 /**
   * These defines are for the 64 bit Solaris 7 port
diff --git a/src/config/param.sun4x_511.h b/src/config/param.sun4x_511.h
index 256e89e7a..a6891bb9a 100644
--- a/src/config/param.sun4x_511.h
+++ b/src/config/param.sun4x_511.h
@@ -77,7 +77,6 @@
 #define	AFS_UIOUSER		UIO_USERSPACE
 #define	AFS_CLBYTES		MCLBYTES
 #define	AFS_MINCHANGE		2
-#define	osi_GetTime(x)		uniqtime32(x)
 
 /**
   * These defines are for the 64 bit Solaris 7 port
diff --git a/src/config/param.sun4x_58.h b/src/config/param.sun4x_58.h
index 4de40e7e1..df290549c 100644
--- a/src/config/param.sun4x_58.h
+++ b/src/config/param.sun4x_58.h
@@ -70,7 +70,6 @@
 #define	AFS_UIOUSER	UIO_USERSPACE
 #define	AFS_CLBYTES	MCLBYTES
 #define	AFS_MINCHANGE	2
-#define	osi_GetTime(x)	uniqtime32(x)
 
 /**
   * These defines are for the 64 bit Solaris 7 port
diff --git a/src/config/param.sun4x_59.h b/src/config/param.sun4x_59.h
index ad50f364b..6ee6d6b1c 100644
--- a/src/config/param.sun4x_59.h
+++ b/src/config/param.sun4x_59.h
@@ -71,7 +71,6 @@
 #define	AFS_UIOUSER	UIO_USERSPACE
 #define	AFS_CLBYTES	MCLBYTES
 #define	AFS_MINCHANGE	2
-#define	osi_GetTime(x)	uniqtime32(x)
 
 /**
   * These defines are for the 64 bit Solaris 7 port
diff --git a/src/config/param.sunx86_510.h b/src/config/param.sunx86_510.h
index e0ce3871f..371e5eec3 100644
--- a/src/config/param.sunx86_510.h
+++ b/src/config/param.sunx86_510.h
@@ -84,7 +84,6 @@
 #define	AFS_UIOUSER		UIO_USERSPACE
 #define	AFS_CLBYTES		MCLBYTES
 #define	AFS_MINCHANGE		2
-#define	osi_GetTime(x)		uniqtime32(x)
 
 /**
   * These defines are for the 64 bit Solaris 7 port
diff --git a/src/config/param.sunx86_511.h b/src/config/param.sunx86_511.h
index 1ac462ead..b20c0d0ee 100644
--- a/src/config/param.sunx86_511.h
+++ b/src/config/param.sunx86_511.h
@@ -87,7 +87,6 @@
 #define	AFS_UIOUSER		UIO_USERSPACE
 #define	AFS_CLBYTES		MCLBYTES
 #define	AFS_MINCHANGE		2
-#define	osi_GetTime(x)		uniqtime32(x)
 
 /**
   * These defines are for the 64 bit Solaris 7 port
diff --git a/src/config/param.sunx86_58.h b/src/config/param.sunx86_58.h
index 9f9ffec73..e9969d35e 100644
--- a/src/config/param.sunx86_58.h
+++ b/src/config/param.sunx86_58.h
@@ -81,7 +81,6 @@
 #define	AFS_UIOUSER	UIO_USERSPACE
 #define	AFS_CLBYTES	MCLBYTES
 #define	AFS_MINCHANGE	2
-#define	osi_GetTime(x)	uniqtime32(x)
 
 #define	AFS_KALLOC(n)	kmem_alloc(n, KM_SLEEP)
 #define AFS_KALLOC_NOSLEEP(n)   kmem_alloc(n, KM_NOSLEEP)
diff --git a/src/config/param.sunx86_59.h b/src/config/param.sunx86_59.h
index 4875e3c50..0c072f707 100644
--- a/src/config/param.sunx86_59.h
+++ b/src/config/param.sunx86_59.h
@@ -82,7 +82,6 @@
 #define	AFS_UIOUSER	UIO_USERSPACE
 #define	AFS_CLBYTES	MCLBYTES
 #define	AFS_MINCHANGE	2
-#define	osi_GetTime(x)	uniqtime32(x)
 
 #define	AFS_KALLOC(n)	kmem_alloc(n, KM_SLEEP)
 #define AFS_KALLOC_NOSLEEP(n)   kmem_alloc(n, KM_NOSLEEP)
diff --git a/src/config/param.x86_darwin_100.h b/src/config/param.x86_darwin_100.h
index 9d8de1041..554eb24a8 100644
--- a/src/config/param.x86_darwin_100.h
+++ b/src/config/param.x86_darwin_100.h
@@ -113,7 +113,6 @@
 #define AFS_UIOSYS      UIO_SYSSPACE
 #define AFS_UIOUSER     UIO_USERSPACE
 #define AFS_CLBYTES     CLBYTES
-#define osi_GetTime(x)  microtime(x)
 #define AFS_KALLOC(x)   _MALLOC(x, M_TEMP, M_WAITOK)
 #define AFS_KFREE(x,y)  _FREE(x,M_TEMP)
 #define v_count         v_usecount
diff --git a/src/config/param.x86_darwin_110.h b/src/config/param.x86_darwin_110.h
index eae598370..ca893b9e9 100644
--- a/src/config/param.x86_darwin_110.h
+++ b/src/config/param.x86_darwin_110.h
@@ -116,7 +116,6 @@
 #define AFS_UIOSYS      UIO_SYSSPACE
 #define AFS_UIOUSER     UIO_USERSPACE
 #define AFS_CLBYTES     CLBYTES
-#define osi_GetTime(x)  microtime(x)
 #define AFS_KALLOC(x)   _MALLOC(x, M_TEMP, M_WAITOK)
 #define AFS_KFREE(x,y)  _FREE(x,M_TEMP)
 #define v_count         v_usecount
diff --git a/src/config/param.x86_darwin_120.h b/src/config/param.x86_darwin_120.h
index da6f48a77..a6c881a9e 100644
--- a/src/config/param.x86_darwin_120.h
+++ b/src/config/param.x86_darwin_120.h
@@ -119,7 +119,6 @@
 #define AFS_UIOSYS      UIO_SYSSPACE
 #define AFS_UIOUSER     UIO_USERSPACE
 #define AFS_CLBYTES     CLBYTES
-#define osi_GetTime(x)  microtime(x)
 #define AFS_KALLOC(x)   _MALLOC(x, M_TEMP, M_WAITOK)
 #define AFS_KFREE(x,y)  _FREE(x,M_TEMP)
 #define v_count         v_usecount
diff --git a/src/config/param.x86_darwin_130.h b/src/config/param.x86_darwin_130.h
index a29a9380c..7571e05fe 100644
--- a/src/config/param.x86_darwin_130.h
+++ b/src/config/param.x86_darwin_130.h
@@ -122,7 +122,6 @@
 #define AFS_UIOSYS      UIO_SYSSPACE
 #define AFS_UIOUSER     UIO_USERSPACE
 #define AFS_CLBYTES     CLBYTES
-#define osi_GetTime(x)  microtime(x)
 #define AFS_KALLOC(x)   _MALLOC(x, M_TEMP, M_WAITOK)
 #define AFS_KFREE(x,y)  _FREE(x,M_TEMP)
 #define v_count         v_usecount
diff --git a/src/config/param.x86_darwin_140.h b/src/config/param.x86_darwin_140.h
index 83e009f5d..989e39b2e 100644
--- a/src/config/param.x86_darwin_140.h
+++ b/src/config/param.x86_darwin_140.h
@@ -125,7 +125,6 @@
 #define AFS_UIOSYS      UIO_SYSSPACE
 #define AFS_UIOUSER     UIO_USERSPACE
 #define AFS_CLBYTES     CLBYTES
-#define osi_GetTime(x)  microtime(x)
 #define AFS_KALLOC(x)   _MALLOC(x, M_TEMP, M_WAITOK)
 #define AFS_KFREE(x,y)  _FREE(x,M_TEMP)
 #define v_count         v_usecount
diff --git a/src/config/param.x86_darwin_150.h b/src/config/param.x86_darwin_150.h
index 6c0df1185..666c1de7f 100644
--- a/src/config/param.x86_darwin_150.h
+++ b/src/config/param.x86_darwin_150.h
@@ -128,7 +128,6 @@
 #define AFS_UIOSYS      UIO_SYSSPACE
 #define AFS_UIOUSER     UIO_USERSPACE
 #define AFS_CLBYTES     CLBYTES
-#define osi_GetTime(x)  microtime(x)
 #define AFS_KALLOC(x)   _MALLOC(x, M_TEMP, M_WAITOK)
 #define AFS_KFREE(x,y)  _FREE(x,M_TEMP)
 #define v_count         v_usecount
diff --git a/src/config/param.x86_darwin_160.h b/src/config/param.x86_darwin_160.h
index 064875297..f2d786a53 100644
--- a/src/config/param.x86_darwin_160.h
+++ b/src/config/param.x86_darwin_160.h
@@ -131,7 +131,6 @@
 #define AFS_UIOSYS      UIO_SYSSPACE
 #define AFS_UIOUSER     UIO_USERSPACE
 #define AFS_CLBYTES     CLBYTES
-#define osi_GetTime(x)  microtime(x)
 #define AFS_KALLOC(x)   _MALLOC(x, M_TEMP, M_WAITOK)
 #define AFS_KFREE(x,y)  _FREE(x,M_TEMP)
 #define v_count         v_usecount
diff --git a/src/config/param.x86_darwin_170.h b/src/config/param.x86_darwin_170.h
index b9be38064..99c8cd78f 100644
--- a/src/config/param.x86_darwin_170.h
+++ b/src/config/param.x86_darwin_170.h
@@ -134,7 +134,6 @@
 #define AFS_UIOSYS      UIO_SYSSPACE
 #define AFS_UIOUSER     UIO_USERSPACE
 #define AFS_CLBYTES     CLBYTES
-#define osi_GetTime(x)  microtime(x)
 #define AFS_KALLOC(x)   _MALLOC(x, M_TEMP, M_WAITOK)
 #define AFS_KFREE(x,y)  _FREE(x,M_TEMP)
 #define v_count         v_usecount
diff --git a/src/config/param.x86_darwin_180.h b/src/config/param.x86_darwin_180.h
index bc671a88c..6b6ac0183 100644
--- a/src/config/param.x86_darwin_180.h
+++ b/src/config/param.x86_darwin_180.h
@@ -137,7 +137,6 @@
 #define AFS_UIOSYS      UIO_SYSSPACE
 #define AFS_UIOUSER     UIO_USERSPACE
 #define AFS_CLBYTES     CLBYTES
-#define osi_GetTime(x)  microtime(x)
 #define AFS_KALLOC(x)   _MALLOC(x, M_TEMP, M_WAITOK)
 #define AFS_KFREE(x,y)  _FREE(x,M_TEMP)
 #define v_count         v_usecount
diff --git a/src/config/param.x86_darwin_190.h b/src/config/param.x86_darwin_190.h
index 82e69dc4c..bd4e302da 100644
--- a/src/config/param.x86_darwin_190.h
+++ b/src/config/param.x86_darwin_190.h
@@ -142,7 +142,6 @@
 #define AFS_UIOSYS      UIO_SYSSPACE
 #define AFS_UIOUSER     UIO_USERSPACE
 #define AFS_CLBYTES     CLBYTES
-#define osi_GetTime(x)  microtime(x)
 #define AFS_KALLOC(x)   _MALLOC(x, M_TEMP, M_WAITOK)
 #define AFS_KFREE(x,y)  _FREE(x,M_TEMP)
 #define v_count         v_usecount
diff --git a/src/config/param.x86_darwin_80.h b/src/config/param.x86_darwin_80.h
index 2a079a7b1..fc70f9836 100644
--- a/src/config/param.x86_darwin_80.h
+++ b/src/config/param.x86_darwin_80.h
@@ -75,7 +75,6 @@
 #define AFS_UIOSYS      UIO_SYSSPACE
 #define AFS_UIOUSER     UIO_USERSPACE
 #define AFS_CLBYTES     CLBYTES
-#define osi_GetTime(x)  microtime(x)
 #define AFS_KALLOC(x)   _MALLOC(x, M_TEMP, M_WAITOK)
 #define AFS_KFREE(x,y)  _FREE(x,M_TEMP)
 #define v_count         v_usecount
diff --git a/src/config/param.x86_darwin_90.h b/src/config/param.x86_darwin_90.h
index 6814c28d2..7f832f99f 100644
--- a/src/config/param.x86_darwin_90.h
+++ b/src/config/param.x86_darwin_90.h
@@ -80,7 +80,6 @@
 #define AFS_UIOSYS      UIO_SYSSPACE
 #define AFS_UIOUSER     UIO_USERSPACE
 #define AFS_CLBYTES     CLBYTES
-#define osi_GetTime(x)  microtime(x)
 #define AFS_KALLOC(x)   _MALLOC(x, M_TEMP, M_WAITOK)
 #define AFS_KFREE(x,y)  _FREE(x,M_TEMP)
 #define v_count         v_usecount
diff --git a/src/config/stds.h b/src/config/stds.h
index a77382374..0b28e4d6e 100644
--- a/src/config/stds.h
+++ b/src/config/stds.h
@@ -250,7 +250,8 @@ typedef struct afsUUID afsUUID;
 #elif defined(AFS_SGI_ENV) || defined(AFS_USR_SGI_ENV)
 #define static_inline static
 #define hdr_static_inline(x) x
-#elif defined(AFS_NBSD_ENV) && !defined(AFS_NBSD50_ENV)
+#elif defined(AFS_NBSD_ENV) && !defined(AFS_NBSD50_ENV) \
+      && defined(HAVE_FUNC_ATTRIBUTE_ALWAYS_INLINE)
 #define static_inline static __inline __attribute__((always_inline))
 #define hdr_static_inline(x) static __inline __attribute__((always_inline)) x
 #else
@@ -274,21 +275,36 @@ hdr_static_inline(unsigned long long) afs_printable_uint64_lu(afs_uint64 d) { re
 #define afs_int_to_pointer(i)      ((void *)  (i))
 #endif
 
-#if defined(__GNUC__) && __GNUC__ > 2
-#define AFS_UNUSED __attribute__((unused))
-#define AFS_ATTRIBUTE_FORMAT(style,x,y) __attribute__((format(style, x, y)))
-#define AFS_NORETURN __attribute__((__noreturn__))
-#define AFS_NONNULL(x) __attribute__((__nonnull__ x))
-#elif defined (__clang__)
-#define AFS_UNUSED __attribute__((unused))
-#define AFS_ATTRIBUTE_FORMAT(style,x,y) __attribute__((format(style, x, y)))
-#define AFS_NORETURN __attribute__((__noreturn__))
-#define AFS_NONNULL(x) __attribute__((__nonnull__ x))
+#ifdef HAVE_FUNC_ATTRIBUTE_UNUSED
+# define AFS_UNUSED __attribute__((unused))
 #else
-#define AFS_UNUSED
-#define AFS_ATTRIBUTE_FORMAT(style,x,y)
-#define AFS_NORETURN
-#define AFS_NONNULL(x)
+# define AFS_UNUSED
+#endif
+
+#ifdef HAVE_FUNC_ATTRIBUTE_FORMAT
+# define AFS_ATTRIBUTE_FORMAT(style,x,y) __attribute__((format(style, x, y)))
+#else
+# define AFS_ATTRIBUTE_FORMAT(style,x,y)
+#endif
+
+#ifdef HAVE_FUNC_ATTRIBUTE_NORETURN
+# define AFS_NORETURN __attribute__((__noreturn__))
+#else
+# define AFS_NORETURN
+#endif
+
+#ifdef HAVE_FUNC_ATTRIBUTE_NONNULL
+# define AFS_NONNULL(x) __attribute__((__nonnull__ x))
+#else
+# define AFS_NONNULL(x)
+#endif
+
+#if defined(AFS_LINUX_ENV) && defined(fallthrough)
+# define AFS_FALLTHROUGH fallthrough
+#elif defined(HAVE_FUNC_ATTRIBUTE_FALLTHROUGH)
+# define AFS_FALLTHROUGH __attribute__((fallthrough))
+#else
+# define AFS_FALLTHROUGH do {} while(0)
 #endif
 
 /*
diff --git a/src/crypto/hcrypto/kernel/config.h b/src/crypto/hcrypto/kernel/config.h
index ef89ed47d..9623fa9e7 100644
--- a/src/crypto/hcrypto/kernel/config.h
+++ b/src/crypto/hcrypto/kernel/config.h
@@ -102,7 +102,7 @@ static_inline int close(int d) {return -1;}
 # undef HAVE_ARC4RANDOM
 #endif
 
-#if !defined(AFS_LINUX26_ENV)
+#if !defined(AFS_LINUX_ENV)
 /*
  * gettimeofday is only used in rand-fortuna.c, not built for Linux.
  * Linux 5.6 removes the native struct timeval, so this stub would not build.
@@ -111,7 +111,7 @@ static_inline int gettimeofday(struct timeval *tp, void *tzp)
     {if (tp == NULL) return -1; tp->tv_sec = osi_Time(); tp->tv_usec = 0; return 0;}
 #endif
 
-#if defined(KERNEL) && (defined(AFS_SUN5_ENV) || defined(AFS_ARM64_LINUX26_ENV))
+#if defined(KERNEL) && (defined(AFS_SUN5_ENV) || defined(AFS_ARM64_LINUX_ENV))
 /*
  * Some functions such as RAND_add take a 'double' as an argument, but floating
  * point code generally cannot be used in kernelspace. We never actually use
diff --git a/src/dir/Makefile.in b/src/dir/Makefile.in
index 978ddc118..2d3f6d7e5 100644
--- a/src/dir/Makefile.in
+++ b/src/dir/Makefile.in
@@ -12,7 +12,8 @@ include @TOP_OBJDIR@/src/config/Makefile.lwp
 
 all: \
 	${TOP_LIBDIR}/libdir.a \
-	depinstall
+	depinstall \
+	test
 
 depinstall: \
 	${TOP_INCDIR}/afs/dir.h
@@ -28,8 +29,9 @@ libdir.a: buffer.o dir.o salvage.o AFS_component_version_number.o
 	$(AR) crv $@ buffer.o dir.o salvage.o  AFS_component_version_number.o
 	$(RANLIB) $@
 
-test:
-	cd test; $(MAKE)
+.PHONY: test
+test: ${TOP_LIBDIR}/libdir.a
+	cd test && $(MAKE) all
 
 buffer.o: buffer.c dir.h
 
diff --git a/src/dir/dir.c b/src/dir/dir.c
index 8aa336d53..765d5f32f 100644
--- a/src/dir/dir.c
+++ b/src/dir/dir.c
@@ -13,7 +13,7 @@
 #ifdef KERNEL
 # if !defined(UKERNEL)
 #  include "h/types.h"
-#  if !defined(AFS_LINUX26_ENV)
+#  if !defined(AFS_LINUX_ENV)
 #   include "h/param.h"
 #  endif
 #  ifdef	AFS_AUX_ENV
@@ -24,10 +24,10 @@
 #   include "h/errno.h"
 #  endif
 #  include "h/time.h"
-#  if defined(AFS_AIX_ENV) || defined(AFS_SGI_ENV) || defined(AFS_SUN5_ENV) || defined(AFS_LINUX20_ENV)
+#  if defined(AFS_AIX_ENV) || defined(AFS_SGI_ENV) || defined(AFS_SUN5_ENV) || defined(AFS_LINUX_ENV)
 #   include "h/errno.h"
 #  else
-#   if !defined(AFS_SUN5_ENV) && !defined(AFS_LINUX20_ENV)
+#   if !defined(AFS_SUN5_ENV) && !defined(AFS_LINUX_ENV)
 #    include "h/kernel.h"
 #   endif
 #  endif
@@ -38,10 +38,10 @@
 #   include "h/user.h"
 #  endif /* AFS_SGI64_ENV */
 #  include "h/uio.h"
-#  if !defined(AFS_SUN5_ENV) && !defined(AFS_LINUX20_ENV) && !defined(AFS_HPUX110_ENV)
+#  if !defined(AFS_SUN5_ENV) && !defined(AFS_LINUX_ENV) && !defined(AFS_HPUX110_ENV)
 #   include "h/mbuf.h"
 #  endif
-#  ifndef AFS_LINUX20_ENV
+#  ifndef AFS_LINUX_ENV
 #   include "netinet/in.h"
 #  endif
 # else /* !defined(UKERNEL) */
@@ -60,7 +60,7 @@ extern int DNew(struct dcache *adc, int page, struct DirBuffer *);
 
 # include "afs/dir.h"
 
-# ifdef AFS_LINUX20_ENV
+# ifdef AFS_LINUX_ENV
 #  include "h/string.h"
 # endif
 
diff --git a/src/dir/test/Makefile.in b/src/dir/test/Makefile.in
index bf47fd185..e205f2369 100644
--- a/src/dir/test/Makefile.in
+++ b/src/dir/test/Makefile.in
@@ -10,7 +10,8 @@ include @TOP_OBJDIR@/src/config/Makefile.config
 include @TOP_OBJDIR@/src/config/Makefile.lwp
 
 
-LIBS = ${srcdir}/lib/libdir.a ${srcdir}/lib/util.a  ${srcdir}/lib/liblwp.a
+LIBS = ${srcdir}/lib/libdir.a ${srcdir}/lib/liblwp.a \
+	   ${srcdir}/lib/libopr.a
 
 OBJS=test-salvage.o physio.o dtest.o
 
diff --git a/src/dir/test/dtest.c b/src/dir/test/dtest.c
index e881c6719..d2d3d3855 100644
--- a/src/dir/test/dtest.c
+++ b/src/dir/test/dtest.c
@@ -14,6 +14,7 @@
 #include <roken.h>
 
 #include <afs/dir.h>
+#include <afs/opr.h>
 
 long fidCounter = 0;
 
@@ -244,9 +245,10 @@ FidCpy(dirhandle *todir, dirhandle *fromdir)
 }
 
 void
-Die(char *msg)
+Die(const char *msg)
 {
     printf("Something died with this message:  %s\n", msg);
+    opr_abort();
 }
 
 void
diff --git a/src/external/autoconf-archive-author b/src/external/autoconf-archive-author
new file mode 100644
index 000000000..1c668c50b
--- /dev/null
+++ b/src/external/autoconf-archive-author
@@ -0,0 +1 @@
+Autoconf Archive Maintainers <autoconf-archive-maintainers@gnu.org>
diff --git a/src/external/autoconf-archive-files b/src/external/autoconf-archive-files
new file mode 100644
index 000000000..42c7c3852
--- /dev/null
+++ b/src/external/autoconf-archive-files
@@ -0,0 +1,5 @@
+m4/ax_append_compile_flags.m4	m4/ax_append_compile_flags.m4
+m4/ax_append_flag.m4		m4/ax_append_flag.m4
+m4/ax_check_compile_flag.m4	m4/ax_check_compile_flag.m4
+m4/ax_gcc_func_attribute.m4	m4/ax_gcc_func_attribute.m4
+m4/ax_require_defined.m4	m4/ax_require_defined.m4
diff --git a/src/external/autoconf-archive-last b/src/external/autoconf-archive-last
new file mode 100644
index 000000000..8bf2750b1
--- /dev/null
+++ b/src/external/autoconf-archive-last
@@ -0,0 +1 @@
+24358c8c5ca679949ef522964d94e4d1cd1f941a
diff --git a/src/external/autoconf-archive/m4/ax_append_compile_flags.m4 b/src/external/autoconf-archive/m4/ax_append_compile_flags.m4
new file mode 100644
index 000000000..9c856356c
--- /dev/null
+++ b/src/external/autoconf-archive/m4/ax_append_compile_flags.m4
@@ -0,0 +1,46 @@
+# ============================================================================
+#  https://www.gnu.org/software/autoconf-archive/ax_append_compile_flags.html
+# ============================================================================
+#
+# SYNOPSIS
+#
+#   AX_APPEND_COMPILE_FLAGS([FLAG1 FLAG2 ...], [FLAGS-VARIABLE], [EXTRA-FLAGS], [INPUT])
+#
+# DESCRIPTION
+#
+#   For every FLAG1, FLAG2 it is checked whether the compiler works with the
+#   flag.  If it does, the flag is added FLAGS-VARIABLE
+#
+#   If FLAGS-VARIABLE is not specified, the current language's flags (e.g.
+#   CFLAGS) is used.  During the check the flag is always added to the
+#   current language's flags.
+#
+#   If EXTRA-FLAGS is defined, it is added to the current language's default
+#   flags (e.g. CFLAGS) when the check is done.  The check is thus made with
+#   the flags: "CFLAGS EXTRA-FLAGS FLAG".  This can for example be used to
+#   force the compiler to issue an error when a bad flag is given.
+#
+#   INPUT gives an alternative input source to AC_COMPILE_IFELSE.
+#
+#   NOTE: This macro depends on the AX_APPEND_FLAG and
+#   AX_CHECK_COMPILE_FLAG. Please keep this macro in sync with
+#   AX_APPEND_LINK_FLAGS.
+#
+# LICENSE
+#
+#   Copyright (c) 2011 Maarten Bosmans <mkbosmans@gmail.com>
+#
+#   Copying and distribution of this file, with or without modification, are
+#   permitted in any medium without royalty provided the copyright notice
+#   and this notice are preserved.  This file is offered as-is, without any
+#   warranty.
+
+#serial 7
+
+AC_DEFUN([AX_APPEND_COMPILE_FLAGS],
+[AX_REQUIRE_DEFINED([AX_CHECK_COMPILE_FLAG])
+AX_REQUIRE_DEFINED([AX_APPEND_FLAG])
+for flag in $1; do
+  AX_CHECK_COMPILE_FLAG([$flag], [AX_APPEND_FLAG([$flag], [$2])], [], [$3], [$4])
+done
+])dnl AX_APPEND_COMPILE_FLAGS
diff --git a/src/external/autoconf-archive/m4/ax_append_flag.m4 b/src/external/autoconf-archive/m4/ax_append_flag.m4
new file mode 100644
index 000000000..dd6d8b614
--- /dev/null
+++ b/src/external/autoconf-archive/m4/ax_append_flag.m4
@@ -0,0 +1,50 @@
+# ===========================================================================
+#      https://www.gnu.org/software/autoconf-archive/ax_append_flag.html
+# ===========================================================================
+#
+# SYNOPSIS
+#
+#   AX_APPEND_FLAG(FLAG, [FLAGS-VARIABLE])
+#
+# DESCRIPTION
+#
+#   FLAG is appended to the FLAGS-VARIABLE shell variable, with a space
+#   added in between.
+#
+#   If FLAGS-VARIABLE is not specified, the current language's flags (e.g.
+#   CFLAGS) is used.  FLAGS-VARIABLE is not changed if it already contains
+#   FLAG.  If FLAGS-VARIABLE is unset in the shell, it is set to exactly
+#   FLAG.
+#
+#   NOTE: Implementation based on AX_CFLAGS_GCC_OPTION.
+#
+# LICENSE
+#
+#   Copyright (c) 2008 Guido U. Draheim <guidod@gmx.de>
+#   Copyright (c) 2011 Maarten Bosmans <mkbosmans@gmail.com>
+#
+#   Copying and distribution of this file, with or without modification, are
+#   permitted in any medium without royalty provided the copyright notice
+#   and this notice are preserved.  This file is offered as-is, without any
+#   warranty.
+
+#serial 8
+
+AC_DEFUN([AX_APPEND_FLAG],
+[dnl
+AC_PREREQ(2.64)dnl for _AC_LANG_PREFIX and AS_VAR_SET_IF
+AS_VAR_PUSHDEF([FLAGS], [m4_default($2,_AC_LANG_PREFIX[FLAGS])])
+AS_VAR_SET_IF(FLAGS,[
+  AS_CASE([" AS_VAR_GET(FLAGS) "],
+    [*" $1 "*], [AC_RUN_LOG([: FLAGS already contains $1])],
+    [
+     AS_VAR_APPEND(FLAGS,[" $1"])
+     AC_RUN_LOG([: FLAGS="$FLAGS"])
+    ])
+  ],
+  [
+  AS_VAR_SET(FLAGS,[$1])
+  AC_RUN_LOG([: FLAGS="$FLAGS"])
+  ])
+AS_VAR_POPDEF([FLAGS])dnl
+])dnl AX_APPEND_FLAG
diff --git a/src/external/autoconf-archive/m4/ax_check_compile_flag.m4 b/src/external/autoconf-archive/m4/ax_check_compile_flag.m4
new file mode 100644
index 000000000..bd753b34d
--- /dev/null
+++ b/src/external/autoconf-archive/m4/ax_check_compile_flag.m4
@@ -0,0 +1,53 @@
+# ===========================================================================
+#  https://www.gnu.org/software/autoconf-archive/ax_check_compile_flag.html
+# ===========================================================================
+#
+# SYNOPSIS
+#
+#   AX_CHECK_COMPILE_FLAG(FLAG, [ACTION-SUCCESS], [ACTION-FAILURE], [EXTRA-FLAGS], [INPUT])
+#
+# DESCRIPTION
+#
+#   Check whether the given FLAG works with the current language's compiler
+#   or gives an error.  (Warnings, however, are ignored)
+#
+#   ACTION-SUCCESS/ACTION-FAILURE are shell commands to execute on
+#   success/failure.
+#
+#   If EXTRA-FLAGS is defined, it is added to the current language's default
+#   flags (e.g. CFLAGS) when the check is done.  The check is thus made with
+#   the flags: "CFLAGS EXTRA-FLAGS FLAG".  This can for example be used to
+#   force the compiler to issue an error when a bad flag is given.
+#
+#   INPUT gives an alternative input source to AC_COMPILE_IFELSE.
+#
+#   NOTE: Implementation based on AX_CFLAGS_GCC_OPTION. Please keep this
+#   macro in sync with AX_CHECK_{PREPROC,LINK}_FLAG.
+#
+# LICENSE
+#
+#   Copyright (c) 2008 Guido U. Draheim <guidod@gmx.de>
+#   Copyright (c) 2011 Maarten Bosmans <mkbosmans@gmail.com>
+#
+#   Copying and distribution of this file, with or without modification, are
+#   permitted in any medium without royalty provided the copyright notice
+#   and this notice are preserved.  This file is offered as-is, without any
+#   warranty.
+
+#serial 6
+
+AC_DEFUN([AX_CHECK_COMPILE_FLAG],
+[AC_PREREQ(2.64)dnl for _AC_LANG_PREFIX and AS_VAR_IF
+AS_VAR_PUSHDEF([CACHEVAR],[ax_cv_check_[]_AC_LANG_ABBREV[]flags_$4_$1])dnl
+AC_CACHE_CHECK([whether _AC_LANG compiler accepts $1], CACHEVAR, [
+  ax_check_save_flags=$[]_AC_LANG_PREFIX[]FLAGS
+  _AC_LANG_PREFIX[]FLAGS="$[]_AC_LANG_PREFIX[]FLAGS $4 $1"
+  AC_COMPILE_IFELSE([m4_default([$5],[AC_LANG_PROGRAM()])],
+    [AS_VAR_SET(CACHEVAR,[yes])],
+    [AS_VAR_SET(CACHEVAR,[no])])
+  _AC_LANG_PREFIX[]FLAGS=$ax_check_save_flags])
+AS_VAR_IF(CACHEVAR,yes,
+  [m4_default([$2], :)],
+  [m4_default([$3], :)])
+AS_VAR_POPDEF([CACHEVAR])dnl
+])dnl AX_CHECK_COMPILE_FLAGS
diff --git a/src/external/autoconf-archive/m4/ax_gcc_func_attribute.m4 b/src/external/autoconf-archive/m4/ax_gcc_func_attribute.m4
new file mode 100644
index 000000000..30bf4c175
--- /dev/null
+++ b/src/external/autoconf-archive/m4/ax_gcc_func_attribute.m4
@@ -0,0 +1,238 @@
+# ===========================================================================
+#  https://www.gnu.org/software/autoconf-archive/ax_gcc_func_attribute.html
+# ===========================================================================
+#
+# SYNOPSIS
+#
+#   AX_GCC_FUNC_ATTRIBUTE(ATTRIBUTE)
+#
+# DESCRIPTION
+#
+#   This macro checks if the compiler supports one of GCC's function
+#   attributes; many other compilers also provide function attributes with
+#   the same syntax. Compiler warnings are used to detect supported
+#   attributes as unsupported ones are ignored by default so quieting
+#   warnings when using this macro will yield false positives.
+#
+#   The ATTRIBUTE parameter holds the name of the attribute to be checked.
+#
+#   If ATTRIBUTE is supported define HAVE_FUNC_ATTRIBUTE_<ATTRIBUTE>.
+#
+#   The macro caches its result in the ax_cv_have_func_attribute_<attribute>
+#   variable.
+#
+#   The macro currently supports the following function attributes:
+#
+#    alias
+#    aligned
+#    alloc_size
+#    always_inline
+#    artificial
+#    cold
+#    const
+#    constructor
+#    constructor_priority for constructor attribute with priority
+#    deprecated
+#    destructor
+#    dllexport
+#    dllimport
+#    error
+#    externally_visible
+#    fallthrough
+#    flatten
+#    format
+#    format_arg
+#    gnu_inline
+#    hot
+#    ifunc
+#    leaf
+#    malloc
+#    noclone
+#    noinline
+#    nonnull
+#    noreturn
+#    nothrow
+#    optimize
+#    pure
+#    sentinel
+#    sentinel_position
+#    unused
+#    used
+#    visibility
+#    warning
+#    warn_unused_result
+#    weak
+#    weakref
+#
+#   Unsupported function attributes will be tested with a prototype
+#   returning an int and not accepting any arguments and the result of the
+#   check might be wrong or meaningless so use with care.
+#
+# LICENSE
+#
+#   Copyright (c) 2013 Gabriele Svelto <gabriele.svelto@gmail.com>
+#
+#   Copying and distribution of this file, with or without modification, are
+#   permitted in any medium without royalty provided the copyright notice
+#   and this notice are preserved.  This file is offered as-is, without any
+#   warranty.
+
+#serial 9 with local fix for fallthrough attribute
+
+AC_DEFUN([AX_GCC_FUNC_ATTRIBUTE], [
+    AS_VAR_PUSHDEF([ac_var], [ax_cv_have_func_attribute_$1])
+
+    AC_CACHE_CHECK([for __attribute__(($1))], [ac_var], [
+        AC_LINK_IFELSE([AC_LANG_PROGRAM([
+            m4_case([$1],
+                [alias], [
+                    int foo( void ) { return 0; }
+                    int bar( void ) __attribute__(($1("foo")));
+                ],
+                [aligned], [
+                    int foo( void ) __attribute__(($1(32)));
+                ],
+                [alloc_size], [
+                    void *foo(int a) __attribute__(($1(1)));
+                ],
+                [always_inline], [
+                    inline __attribute__(($1)) int foo( void ) { return 0; }
+                ],
+                [artificial], [
+                    inline __attribute__(($1)) int foo( void ) { return 0; }
+                ],
+                [cold], [
+                    int foo( void ) __attribute__(($1));
+                ],
+                [const], [
+                    int foo( void ) __attribute__(($1));
+                ],
+                [constructor_priority], [
+                    int foo( void ) __attribute__((__constructor__(65535/2)));
+                ],
+                [constructor], [
+                    int foo( void ) __attribute__(($1));
+                ],
+                [deprecated], [
+                    int foo( void ) __attribute__(($1("")));
+                ],
+                [destructor], [
+                    int foo( void ) __attribute__(($1));
+                ],
+                [dllexport], [
+                    __attribute__(($1)) int foo( void ) { return 0; }
+                ],
+                [dllimport], [
+                    int foo( void ) __attribute__(($1));
+                ],
+                [error], [
+                    int foo( void ) __attribute__(($1("")));
+                ],
+                [externally_visible], [
+                    int foo( void ) __attribute__(($1));
+                ],
+                [fallthrough], [
+                    void foo( int x ) {switch (x) { case 1: __attribute__(($1)); case 2: break ; }};
+                ],
+                [flatten], [
+                    int foo( void ) __attribute__(($1));
+                ],
+                [format], [
+                    int foo(const char *p, ...) __attribute__(($1(printf, 1, 2)));
+                ],
+                [format_arg], [
+                    char *foo(const char *p) __attribute__(($1(1)));
+                ],
+                [gnu_inline], [
+                    inline __attribute__(($1)) int foo( void ) { return 0; }
+                ],
+                [hot], [
+                    int foo( void ) __attribute__(($1));
+                ],
+                [ifunc], [
+                    int my_foo( void ) { return 0; }
+                    static int (*resolve_foo(void))(void) { return my_foo; }
+                    int foo( void ) __attribute__(($1("resolve_foo")));
+                ],
+                [leaf], [
+                    __attribute__(($1)) int foo( void ) { return 0; }
+                ],
+                [malloc], [
+                    void *foo( void ) __attribute__(($1));
+                ],
+                [noclone], [
+                    int foo( void ) __attribute__(($1));
+                ],
+                [noinline], [
+                    __attribute__(($1)) int foo( void ) { return 0; }
+                ],
+                [nonnull], [
+                    int foo(char *p) __attribute__(($1(1)));
+                ],
+                [noreturn], [
+                    void foo( void ) __attribute__(($1));
+                ],
+                [nothrow], [
+                    int foo( void ) __attribute__(($1));
+                ],
+                [optimize], [
+                    __attribute__(($1(3))) int foo( void ) { return 0; }
+                ],
+                [pure], [
+                    int foo( void ) __attribute__(($1));
+                ],
+                [sentinel], [
+                    int foo(void *p, ...) __attribute__(($1));
+                ],
+                [sentinel_position], [
+                    int foo(void *p, ...) __attribute__(($1(1)));
+                ],
+                [returns_nonnull], [
+                    void *foo( void ) __attribute__(($1));
+                ],
+                [unused], [
+                    int foo( void ) __attribute__(($1));
+                ],
+                [used], [
+                    int foo( void ) __attribute__(($1));
+                ],
+                [visibility], [
+                    int foo_def( void ) __attribute__(($1("default")));
+                    int foo_hid( void ) __attribute__(($1("hidden")));
+                    int foo_int( void ) __attribute__(($1("internal")));
+                    int foo_pro( void ) __attribute__(($1("protected")));
+                ],
+                [warning], [
+                    int foo( void ) __attribute__(($1("")));
+                ],
+                [warn_unused_result], [
+                    int foo( void ) __attribute__(($1));
+                ],
+                [weak], [
+                    int foo( void ) __attribute__(($1));
+                ],
+                [weakref], [
+                    static int foo( void ) { return 0; }
+                    static int bar( void ) __attribute__(($1("foo")));
+                ],
+                [
+                 m4_warn([syntax], [Unsupported attribute $1, the test may fail])
+                 int foo( void ) __attribute__(($1));
+                ]
+            )], [])
+            ],
+            dnl GCC doesn't exit with an error if an unknown attribute is
+            dnl provided but only outputs a warning, so accept the attribute
+            dnl only if no warning were issued.
+            [AS_IF([test -s conftest.err],
+                [AS_VAR_SET([ac_var], [no])],
+                [AS_VAR_SET([ac_var], [yes])])],
+            [AS_VAR_SET([ac_var], [no])])
+    ])
+
+    AS_IF([test yes = AS_VAR_GET([ac_var])],
+        [AC_DEFINE_UNQUOTED(AS_TR_CPP(HAVE_FUNC_ATTRIBUTE_$1), 1,
+            [Define to 1 if the system has the `$1' function attribute])], [])
+
+    AS_VAR_POPDEF([ac_var])
+])
diff --git a/src/external/autoconf-archive/m4/ax_require_defined.m4 b/src/external/autoconf-archive/m4/ax_require_defined.m4
new file mode 100644
index 000000000..17c3eab7d
--- /dev/null
+++ b/src/external/autoconf-archive/m4/ax_require_defined.m4
@@ -0,0 +1,37 @@
+# ===========================================================================
+#    https://www.gnu.org/software/autoconf-archive/ax_require_defined.html
+# ===========================================================================
+#
+# SYNOPSIS
+#
+#   AX_REQUIRE_DEFINED(MACRO)
+#
+# DESCRIPTION
+#
+#   AX_REQUIRE_DEFINED is a simple helper for making sure other macros have
+#   been defined and thus are available for use.  This avoids random issues
+#   where a macro isn't expanded.  Instead the configure script emits a
+#   non-fatal:
+#
+#     ./configure: line 1673: AX_CFLAGS_WARN_ALL: command not found
+#
+#   It's like AC_REQUIRE except it doesn't expand the required macro.
+#
+#   Here's an example:
+#
+#     AX_REQUIRE_DEFINED([AX_CHECK_LINK_FLAG])
+#
+# LICENSE
+#
+#   Copyright (c) 2014 Mike Frysinger <vapier@gentoo.org>
+#
+#   Copying and distribution of this file, with or without modification, are
+#   permitted in any medium without royalty provided the copyright notice
+#   and this notice are preserved. This file is offered as-is, without any
+#   warranty.
+
+#serial 2
+
+AC_DEFUN([AX_REQUIRE_DEFINED], [dnl
+  m4_ifndef([$1], [m4_fatal([macro ]$1[ is not defined; is a m4 file missing?])])
+])dnl AX_REQUIRE_DEFINED
diff --git a/src/external/c-tap-harness-last b/src/external/c-tap-harness-last
index 34209570e..3f9f4cbf2 100644
--- a/src/external/c-tap-harness-last
+++ b/src/external/c-tap-harness-last
@@ -1 +1 @@
-d3fc03606efc8e76ff34f04470e6133db25a3982
+abdb66561ffd4d2f238fdb06f448ccf09d80c059
diff --git a/src/external/c-tap-harness/LICENSE b/src/external/c-tap-harness/LICENSE
index 5f9581671..783d17628 100644
--- a/src/external/c-tap-harness/LICENSE
+++ b/src/external/c-tap-harness/LICENSE
@@ -1,138 +1,154 @@
-The C TAP Harness package as a whole is:
+Format: https://www.debian.org/doc/packaging-manuals/copyright-format/1.0/
+Comment: This file documents the copyright statements and licenses for
+ every file in this package in a machine-readable format.  For a less
+ detailed, higher-level overview, see README.
+ .
+ For any copyright year range specified as YYYY-ZZZZ in this file, the
+ range specifies every single year in that closed interval.
+
+Files: *
+Copyright: 2000-2001, 2004, 2006-2020 Russ Allbery <eagle@eyrie.org>
+  2001-2002, 2004-2014
+    The Board of Trustees of the Leland Stanford Junior University
+License: Expat
+
+Files: .clang-format docs/api/bail.3 docs/api/bail.pod
+ docs/api/bcalloc_type.3 docs/api/bcalloc_type.pod docs/api/bmalloc.3
+ docs/api/bmalloc.pod docs/api/breallocarray.3 docs/api/breallocarray.pod
+ docs/api/diag.3 docs/api/diag.pod docs/api/diag_file_add.3
+ docs/api/diag_file_add.pod docs/api/is_int.3 docs/api/is_int.pod
+ docs/api/ok.3 docs/api/ok.pod docs/api/plan.3 docs/api/plan.pod
+ docs/api/skip.3 docs/api/skip.pod docs/api/skip_all.3
+ docs/api/skip_all.pod docs/api/test_cleanup_register.3
+ docs/api/test_cleanup_register.pod docs/api/test_file_path.3
+ docs/api/test_file_path.pod docs/api/test_tmpdir.3
+ docs/api/test_tmpdir.pod docs/runtests.1 docs/runtests.pod
+ docs/writing-tests tests/data/cppcheck.supp
+Copyright: 2009-2020 Russ Allbery <eagle@eyrie.org>
+License: all-permissive
+ Copying and distribution of this file, with or without modification, are
+ permitted in any medium without royalty provided the copyright notice and
+ this notice are preserved.  This file is offered as-is, without any
+ warranty.
+
+Files: Makefile.in
+Copyright: 1994-2020 Free Software Foundation, Inc.
+  2008-2020 Russ Allbery <eagle@eyrie.org>
+License: FSF-unlimited and Expat
+
+Files: aclocal.m4
+Copyright: 1996-2020 Free Software Foundation, Inc.
+License: FSF-unlimited
+
+Files: build-aux/ar-lib build-aux/compile build-aux/depcomp
+ build-aux/missing
+Copyright: 1996-2020 Free Software Foundation, Inc.
+License: GPL-2+ with Autoconf exception or Expat
+
+Files: build-aux/install-sh
+Copyright: 1994 X Consortium
+License: X11
+ Permission is hereby granted, free of charge, to any person obtaining a
+ copy of this software and associated documentation files (the
+ "Software"), to deal in the Software without restriction, including
+ without limitation the rights to use, copy, modify, merge, publish,
+ distribute, sublicense, and/or sell copies of the Software, and to permit
+ persons to whom the Software is furnished to do so, subject to the
+ following conditions:
+ .
+ The above copyright notice and this permission notice shall be included
+ in all copies or substantial portions of the Software.
+ .
+ THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ IN NO EVENT SHALL THE X CONSORTIUM BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ OTHER DEALINGS IN THE SOFTWARE.
+ .
+ Except as contained in this notice, the name of the X Consortium shall
+ not be used in advertising or otherwise to promote the sale, use or other
+ dealings in this Software without prior written authorization from the X
+ Consortium.
+
+Files: configure
+Copyright: 1992-1996, 1998-2012 Free Software Foundation, Inc.
+License: FSF-configure
+ This script is free software; the Free Software Foundation gives unlimited
+ permission to copy, distribute and modify it.
+
+Files: m4/cc-flags.m4
+Copyright: 2006, 2009, 2016 Internet Systems Consortium, Inc.
+  2016-2020 Russ Allbery <eagle@eyrie.org>
+License: ISC
+ Permission to use, copy, modify, and distribute this software for any
+ purpose with or without fee is hereby granted, provided that the above
+ copyright notice and this permission notice appear in all copies.
+ .
+ THE SOFTWARE IS PROVIDED "AS IS" AND ISC DISCLAIMS ALL WARRANTIES WITH
+ REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ MERCHANTABILITY AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR ANY
+ SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+Files: m4/clang.m4
+Copyright: 2015 Russ Allbery <eagle@eyrie.org>
+License: unlimited
+ This file is free software; the authors give unlimited permission to copy
+ and/or distribute it, with or without modifications, as long as this
+ notice is preserved.
+
+License: Expat
+ Permission is hereby granted, free of charge, to any person obtaining a
+ copy of this software and associated documentation files (the
+ "Software"), to deal in the Software without restriction, including
+ without limitation the rights to use, copy, modify, merge, publish,
+ distribute, sublicense, and/or sell copies of the Software, and to permit
+ persons to whom the Software is furnished to do so, subject to the
+ following conditions:
+ .
+ The above copyright notice and this permission notice shall be included
+ in all copies or substantial portions of the Software.
+ .
+ THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT
+ OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR
+ THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+License: FSF-unlimited
+ This file is free software; the Free Software Foundation gives unlimited
+ permission to copy and/or distribute it, with or without modifications, as
+ long as this notice is preserved.
+ .
+ This program is distributed in the hope that it will be useful, but
+ WITHOUT ANY WARRANTY, to the extent permitted by law; without even the
+ implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+
+License: GPL-2+ with Autoconf exception
+ This file is free software; you can redistribute it and/or modify it
+ under the terms of the GNU General Public License as published by the
+ Free Software Foundation; either version 2 of the License, or (at your
+ option) any later version.
+ .
+ This program is distributed in the hope that it will be useful, but
+ WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
+ Public License for more details.
+ .
+ You should have received a copy of the GNU General Public License along
+ with this program.  If not, see <https://www.gnu.org/licenses/>.
+ .
+ As a special exception to the GNU General Public License, if you
+ distribute this file as part of a program that contains a configuration
+ script generated by Autoconf, you may include it under the same
+ distribution terms that you use for the rest of that program.
+Comment: The option described in the license has been accepted and these
+ files are distributed under the same terms as the package as a whole, as
+ described at the top of this file.
 
-  Copyright 2000, 2001, 2004, 2006, 2007, 2008, 2009, 2010, 2011, 2012
-      Russ Allbery <rra@stanford.edu>
-  Copyright 2006, 2007, 2008, 2009, 2011, 2012
-      The Board of Trustees of the Leland Stanford Junior University
-
-and released under the following license:
-
-  Permission is hereby granted, free of charge, to any person obtaining a
-  copy of this software and associated documentation files (the
-  "Software"), to deal in the Software without restriction, including
-  without limitation the rights to use, copy, modify, merge, publish,
-  distribute, sublicense, and/or sell copies of the Software, and to
-  permit persons to whom the Software is furnished to do so, subject to
-  the following conditions:
-
-  The above copyright notice and this permission notice shall be included
-  in all copies or substantial portions of the Software.
-
-  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
-  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
-  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
-  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
-  CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
-  TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
-  SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-
-All individual files without an explicit exception below are released
-under this license.  Some files may have additional copyright holders as
-noted in those files.
-
-Some files in this distribution are individually released under different
-licenses, all of which are compatible with the above general package
-license but which may require preservation of additional notices.  All
-required notices are preserved in this file.  Of the files intended to be
-copied into other packages, only docs/writing-tests has a different
-license notice, and its requirements are met by preserving the license
-section of that document in any derivative works.
-
-Collected copyright notices for the entire package:
-
-  Copyright 2000, 2001, 2004, 2006, 2007, 2008, 2009, 2010, 2011, 2012
-      Russ Allbery <rra@stanford.edu>
-  Copyright 2006, 2007, 2008, 2009, 2011, 2012
-      The Board of Trustees of the Leland Stanford Junior University
-  Copyright 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,
-      2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012
-      Free Software Foundation, Inc.
-  Copyright 1994 X Consortium
-
-The file docs/writing-tests is released under the following license:
-
-  Copying and distribution of this file, with or without modification, are
-  permitted in any medium without royalty provided the copyright notice
-  and this notice are preserved.  This file is offered as-is, without any
-  warranty.
-
-The files Makefile.in and aclocal.m4 are generated by GNU Automake and
-released under the following copyright and license:
-
-  Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
-  2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 Free Software
-  Foundation, Inc.  This file is free software; the Free Software
-  Foundation gives unlimited permission to copy and/or distribute it, with
-  or without modifications, as long as this notice is preserved.
-
-  This program is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY, to the extent permitted by law; without
-  even the implied warranty of MERCHANTABILITY or FITNESS FOR A
-  PARTICULAR PURPOSE.
-
-The file configure is generated by GNU Autoconf and is released under the
-following copyright and license:
-
-  Copyright (C) 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001,
-  2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010 Free Software
-  Foundation, Inc.  This configure script is free software; the Free
-  Software Foundation gives unlimited permission to copy, distribute and
-  modify it.
-
-The files build-aux/compile, build-aux/depcomp, and build-aux/missing are
-taken from GNU Automake and are released under the following copyright and
-license:
-
-  Copyright (C) 1996, 1997, 1999, 2000, 2002, 2003, 2004, 2005, 2006,
-  2007, 2008, 2009, 2010, 2011, 2012 Free Software Foundation, Inc.
-
-  This program is free software; you can redistribute it and/or modify it
-  under the terms of the GNU General Public License as published by the
-  Free Software Foundation; either version 2, or (at your option) any
-  later version.
-
-  This program is distributed in the hope that it will be useful, but
-  WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  General Public License for more details.
-
-  As a special exception to the GNU General Public License, if you
-  distribute this file as part of a program that contains a configuration
-  script generated by Autoconf, you may include it under the same
-  distribution terms that you use for the rest of that program.
-
-For the C TAP Harness distribution, the option described in the last
-paragraph has been accepted and these files are distributed under the same
-terms as the C TAP Harness package as a whole, as described at the top of
-this file.
-
-The file build-aux/install-sh is released under the following copyright
-and license:
-
-  Copyright (C) 1994 X Consortium
-
-  Permission is hereby granted, free of charge, to any person obtaining a
-  copy of this software and associated documentation files (the
-  "Software"), to deal in the Software without restriction, including
-  without limitation the rights to use, copy, modify, merge, publish,
-  distribute, sublicense, and/or sell copies of the Software, and to
-  permit persons to whom the Software is furnished to do so, subject to
-  the following conditions:
-
-  The above copyright notice and this permission notice shall be included
-  in all copies or substantial portions of the Software.
-
-  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
-  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
-  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
-  IN NO EVENT SHALL THE X CONSORTIUM BE LIABLE FOR ANY CLAIM, DAMAGES OR
-  OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
-  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
-  OTHER DEALINGS IN THE SOFTWARE.
-
-  Except as contained in this notice, the name of the X Consortium shall
-  not be used in advertising or otherwise to promote the sale, use or
-  other dealings in this Software without prior written authorization
-  from the X Consortium.
-
-  FSF changes to this file are in the public domain.
diff --git a/src/external/c-tap-harness/NEWS b/src/external/c-tap-harness/NEWS
index be4aba8a0..7e4a61716 100644
--- a/src/external/c-tap-harness/NEWS
+++ b/src/external/c-tap-harness/NEWS
@@ -1,5 +1,275 @@
                     User-Visible C TAP Harness Changes
 
+C TAP Harness 4.7 (2020-05-16)
+
+    Allow the package test suite to be run with C_TAP_VERBOSE without
+    breaking test results via inheritance of that setting.
+
+    Fix warnings with GCC 10.
+
+C TAP Harness 4.6 (2020-01-07)
+
+    Reformat all C source using clang-format 10 and the formatting rules
+    specified in .clang-format.
+
+    Update to rra-c-util 8.1:
+
+    * Drop support for Perl versions prior to Perl 5.8.
+
+C TAP Harness 4.5 (2019-08-31)
+
+    Add new bcalloc_type and breallocarray_type macros that take a type
+    instead of a size as their third argument and cast the return value to
+    a pointer to that type.  These are more friendly to C++ code than
+    C-style allocation functions returning void *.
+
+    The test harness and libtap C library can now alternatively be
+    compiled with a C++ compiler, making it easier to incorporate them
+    into a C++ project.  Thanks to Peter Paris for the initial report.
+
+C TAP Harness 4.4 (2018-12-25)
+
+    Add test_cleanup_register_with_data to the C TAP library.  This is the
+    same as test_cleanup_register except takes a generic pointer, which is
+    then passed to the cleanup function as a third argument.  This should
+    have been the only API from the beginning, but test_cleanup_register
+    is preserved for backward compatibility.  Patch from Marc Dionne.
+
+    Fix error checking for malloc failure in bstrndup function (caught by
+    cppcheck).
+
+    Update to rra-c-util 8.0:
+
+    * Skip tests requiring Test::More if it isn't available.
+    * Check for pre-SPDX license grant strings.
+    * Improved test for obsolete strings in package source files.
+
+C TAP Harness 4.3 (2018-05-06)
+
+    Add support for valgrind and libtool test options in test lists.  Test
+    lists now take a space-separated set of options after the test name.
+    If the valgrind option is present and C_TAP_VALGRIND is set in the
+    environment, the test will be run by passing it as an option to the
+    command given in C_TAP_VALGRIND.  If the libtool option is also set,
+    valgrind will be run via the libtool script set in C_TAP_LIBTOOL,
+    using --mode=execute, so that valgrind will run on the underlying
+    binary and not the libtool shell wrapper.
+
+    On test failures, report the values as left and right instead of
+    wanted and seen.  This idea is stolen from the Rust assert framework.
+    It avoids having to care about the order in which values are passed
+    into the test functions.
+
+    Fix is_string comparisons involving NULL pointers so that the string
+    "(null)" will no longer compare equal to NULL (although the diagnostic
+    output on test failure is still mildly confusing).
+
+    Add new check-cppcheck target that runs cppcheck on all source code,
+    and fix one unnecessary check for NULL that it uncovered.
+
+    Add SPDX-License-Identifier headers to all substantial source files,
+    and add a test to check for them.  This imports more supporting test
+    machinery whose canonical home is in rra-c-util.  If you want to use
+    files in tests/tap/perl, copy them from rra-c-util instead of this
+    package.
+
+    C TAP Harness now imports the Perl test modules from rra-c-util to
+    support some checks, so tests/docs/pod-spelling-t and tests/docs/pod-t
+    have been updated to the versions from rra-c-util.  Projects that were
+    previously copying those tests should be able to continue to use them,
+    but will now need the modules in tests/tap/perl (the canonical version
+    of which are maintained in rra-c-util).
+
+C TAP Harness 4.2 (2017-12-30)
+
+    Add is_blob function to the C test library.  This tests whether two
+    regions of memory are identical, similar to ok(memcmp(...)) but
+    reporting where the regions differ.  Patch from Daniel Collins.
+
+    Avoid zero-length realloc allocations in breallocarray.
+
+    Fix new fall-through warning in GCC 7.
+
+    Switch to the compiler warning Autoconf macros and warning set from
+    rra-c-util with the addition of -ansi -pedantic for GCC and
+    -pedantic-errors for Clang.  Add some casts to fix warnings from
+    -Wconversion, and suppress some spurious warnings from Clang about
+    tests/tap/float.c.
+
+C TAP Harness 4.1 (2016-12-23)
+
+    Add is_bool function to the C test library.  This compares its two
+    arguments only for their truthfulness.  is_bool(true, arg) is the same
+    as ok(arg), but there are times (such as when testing for a false
+    value) where this allows for clearer code or clearer output.
+
+C TAP Harness 4.0 (2016-05-07)
+
+    When building runtests, one must now set the C_TAP_SOURCE and
+    C_TAP_BUILD C preprocessor symbols to the source and build
+    directories, instead of SOURCE and BUILD.  An updated Makefile.am
+    recipe is documented in README.
+
+    runtests now sets C_TAP_SOURCE and C_TAP_BUILD in the environment in
+    addition to SOURCE and BUILD.  All test programs using this harness
+    should switch to the new C_TAP_SOURCE and C_TAP_BUILD environment
+    variables.  SOURCE and BUILD are very generic and may conflict with
+    other programs and uses, and setting them will be removed in a later
+    version.
+
+    The TAP test libraries (C and shell) now use C_TAP_SOURCE and
+    C_TAP_BUILD environment variables instead of SOURCE and BUILD for the
+    test_file_path() and test_tmpdir() functions.  If you were using these
+    libraries with another test harness, you will need to set the new
+    environment variables.
+
+    Fix missing va_end() call in is_double(), which would have caused
+    compilation failures or other problems on some platforms.  Thanks,
+    Julien ÉLIE.
+
+    Rename the script to bootstrap from a Git checkout to bootstrap,
+    matching the emerging consensus in the Autoconf world.
+
+C TAP Harness 3.4 (2015-08-18)
+
+    Fix segfault in runtests when given a test list containing only
+    comments and blank lines.  Thanks, aherbert.
+
+C TAP Harness 3.3 (2015-04-26)
+
+    If runtests is given the -v option, or if the environment variable
+    C_TAP_VERBOSE is set, the complete output of each test program will be
+    shown instead of the summary of total and failing tests.  Based on
+    work by D. Brashear.
+
+    C TAP Harness now compiles cleanly with Clang with -Weverything
+    -Wno-padded -pedantic-errors, and automatically detects Clang and
+    switches warning flags for make warnings.
+
+C TAP Harness 3.2 (2014-12-25)
+
+    The runtests harness now supports ignoring comments and blank lines in
+    the test list specified with -l.  Leading whitespace before the test
+    name is also ignored.
+
+C TAP Harness 3.1 (2014-07-02)
+
+    ok, okv, and all is_* functions now return true if the test succeeds
+    and false if it fails, matching the return status of the corresponding
+    Perl Test::More functions.  This allows more succinct code when the
+    actions of a test program should vary based on the success or failure
+    of previous tests.  Based on a patch by Peter Pöschl.
+
+    diag and sysdiag now always return 1, making it easier to insert calls
+    into compound statements when debugging tests.  Based on a patch by
+    Peter Pöschl.
+
+    Add new breallocarray API that does the same as realloc but takes
+    calloc-style arguments to specify the size and checks internally for
+    integer overflow.  Inspired by the OpenBSD reallocarray function.
+
+    Check for integer overflows on memory allocation.  All the possible
+    issues for this code are rather theoretical, but one may as well
+    strive for correctness.
+
+    Replace all uses of sprintf with a simpler string concatenation
+    function that checks for allocation overflow.  (The standards
+    assumptions for this package don't permit assuming asprintf or a
+    sufficiently non-broken snprintf to simulate asprintf.)
+
+C TAP Harness 3.0 (2014-01-28)
+
+    The test_cleanup_register API has changed in this release.  Cleanup
+    functions must now take two parameters, not one, and are called from
+    all test processes, not just the primary one.  The new second argument
+    indicates whether the cleanup function was called in the primary
+    process (the one in which plan or plan_lazy was called).  External
+    resources, such as files, should generally only be freed when the
+    cleanup function is called in the primary process, but tests may want
+    to free internal resources, like memory, in all processes to ease
+    analysis with tools like valgrind.
+
+    When running test programs from a list, reopen standard input for each
+    program to /dev/null, and be more careful about closing all duplicates
+    of file descriptors left behind after setting up standard output and
+    standard error so that extraneous file descriptors aren't leaked to
+    the child process.
+
+C TAP Harness 2.4 (2013-12-25)
+
+    Add new diag_file_add and diag_file_remove APIs to the basic C TAP
+    library.  These functions manage a list of registered file that
+    contains supplemental diagnostic information.  Each registered file is
+    checked before each output function for any new lines, and any lines
+    are displayed as if they'd been passed to diag().  This can be useful
+    if, for example, the test involves a background daemon whose output
+    can be logged to a disk file.
+
+C TAP Harness 2.3 (2013-11-13)
+
+    Add new test_cleanup_register API to the basic C TAP library.  This
+    registers a C callback function that's called during exit from the
+    test and passed in a boolean argument indicating whether the test
+    succeeded or failed.
+
+    Suppress lazy plans and the summary of tests at the end of a test
+    program if the program aborted with bail or sysbail.
+
+    Add warn_unused_result gcc attributes to the C TAP library functions
+    where ignoring the return value is almost certainly a bug (such as all
+    the malloc functions).
+
+    Add portability for warn_unsed_result attributes to tap/macros.h.
+
+C TAP Harness 2.2 (2013-08-14)
+
+    bail and sysbail now exit with status 255 to match the behavior of
+    BAIL_OUT in Perl's Test::More.
+
+    Document that runtests handling of test cases that bail out differs
+    from the documented behavior of BAIL_OUT in Perl's Test::More and the
+    behavior of prove, and document why.
+
+C TAP Harness 2.1 (2013-03-15)
+
+    When locating test programs, try a suffix (-t, .t, or no suffix) with
+    all bases before moving on to the next suffix.  The behavior in the
+    previous release was not backward-compatible: it would find the
+    unsuffixed helper program in the build directory instead of the actual
+    test in the source directory for some rra-c-util tests when the build
+    directory and the source directory weren't the same.
+
+    Document that TAP version directives in the TAP output are ignored.
+
+C TAP Harness 2.0 (2013-03-14)
+
+    The default behavior of tests/runtests has changed to make it act more
+    like other test drivers.  Now, to provide a file containing a list of
+    tests, use the -l option.  Existing users should add -l to the command
+    line in front of the test list.  Otherwise, the command-line arguments
+    are taken as tests to run, as if they were all listed in a test list
+    file.
+
+    runtests now tries the test name without any extension if the test
+    name with either -t or .t was not found.  It also does not consider a
+    directory to be a valid test when searching for the executable, even
+    if the directory is executable.
+
+    Flush the harness output after each test.  This effectively implements
+    line buffering even when standard output is not a terminal and
+    therefore output isn't flushed after each line of test output.
+
+    When displaying partial status of tests with a deferred plan, show the
+    total number of tests as ? rather than the number of tests seen so
+    far.  This matches the behavior of Perl's prove utility.
+
+    More correctly handle backspacing over the test count in several abort
+    cases when reporting status to a terminal.
+
+    Add GCC annotations to some internal functions in runtests to help
+    clang --analyze better understand code correctness.  Remove a dead
+    store caught by clang --analyze.
+
 C TAP Harness 1.12 (2012-05-11)
 
     Fix additional uses of local in the shell TAP library for portability
@@ -54,7 +324,7 @@ C TAP Harness 1.11 (2012-04-25)
 
     Move the is_double C TAP test function into a separate source file.
     Including this function may require linking with libm on some
-    platforms, which is undesireable if the package otherwise doesn't use
+    platforms, which is undesirable if the package otherwise doesn't use
     math functions.  The new tests/tap/float.c and tests/tap/float.h files
     need only be included in a package that wants to do floating point
     tests.  Users of is_double will now need to include tests/tap/float.h
diff --git a/src/external/c-tap-harness/README b/src/external/c-tap-harness/README
index ddcfc914d..3a6bb55b0 100644
--- a/src/external/c-tap-harness/README
+++ b/src/external/c-tap-harness/README
@@ -1,12 +1,12 @@
-                            C TAP Harness 1.12
+                            C TAP Harness 4.7
                (C harness for running TAP-compliant tests)
+               Maintained by Russ Allbery <eagle@eyrie.org>
 
-                Written by Russ Allbery <rra@stanford.edu>
-
-  Copyright 2000, 2001, 2004, 2006, 2007, 2008, 2009, 2010, 2011, 2012
-  Russ Allbery <rra@stanford.edu>.  This software is distributed under a
-  BSD-style license.  Please see the file LICENSE in the distribution for
-  more information.
+  Copyright 2000-2001, 2004, 2006-2020 Russ Allbery <eagle@eyrie.org>.
+  Copyright 2006-2009, 2011-2013 The Board of Trustees of the Leland
+  Stanford Junior University.  This software is distributed under a
+  BSD-style license.  Please see the section LICENSE below for more
+  information.
 
 BLURB
 
@@ -28,7 +28,7 @@ DESCRIPTION
   merges all the various versions into a single code base that all my
   packages can pull from.
 
-  C TAP Harness provides a full TAP specification (apart from a few
+  C TAP Harness provides a full TAP specification driver (apart from a few
   possible edge cases) and has additional special features for supporting
   builds outside the source directory.  It's mostly useful for packages
   using Autoconf and Automake and because it doesn't assume or require
@@ -44,7 +44,11 @@ DESCRIPTION
 
   Also included in this package are C and shell libraries that provide
   utility functions for writing test scripts that use TAP to report
-  exists.
+  results.  The C library also provides a variety of utility functions
+  useful for test programs running as part of an Automake-built package:
+  finding test data files, creating temporary files, reporting output from
+  external programs running in the background, and similar common
+  problems.
 
 REQUIREMENTS
 
@@ -55,50 +59,68 @@ REQUIREMENTS
   Bourne-compatible shell.  Outside of the test suite, C TAP Harness has
   no other prerequisites or requirements.
 
-  To run the test suite, you will need Perl plus the Perl modules
-  Test::More and Test::Pod.  Test::More comes with Perl 5.8 and later.
-  Test::Pod is available from CPAN and currently must be installed
-  separately, but the POD tests will be skipped without interfering with
-  the rest of the tests if it's not installed.
-
-  To check spelling in the POD documentation, Pod::Spell (available from
-  CPAN) and either aspell or ispell with the american dictionary are also
-  required.  The user's path is searched for aspell or ispell and aspell
-  is preferred.  Spelling tests are disabled by default since spelling
-  dictionaries differ too much between systems.  To enable those tests,
-  set RRA_MAINTAINER_TESTS to a true value.
+  C TAP Harness can also be built with a C++ compiler and should be
+  similarly portable to any recent C++ compiler, although it is only
+  tested with g++.
 
   To bootstrap from a Git checkout, or if you change the Automake files
   and need to regenerate Makefile.in, you will need Automake 1.11 or
   later.  For bootstrap or if you change configure.ac or any of the m4
   files it includes and need to regenerate configure or config.h.in, you
-  will need Autoconf 2.64 or later.  Perl is also required to generate the
-  manual page from a fresh Git checkout.
+  will need Autoconf 2.64 or later.  Perl is also required to generate
+  manual pages from a fresh Git checkout.
 
-BUILDING AND TESTING
+BUILDING
 
-  You can build C TAP Harness and run its internal test suite with:
+  You can build C TAP Harness with the standard commands:
 
       ./configure
       make
-      make check
 
-  While there is a configure script, it exists just to drive the build
-  system and do some path substitution and isn't doing portability
-  probes.  Pass --enable-silent-rules to configure for a quieter build
-  (similar to the Linux kernel).
+  If you are building from a Git clone, first run ./bootstrap in the
+  source directory to generate the build files.  Building outside of the
+  source directory is also supported, if you wish, by creating an empty
+  directory and then running configure with the correct relative path.
+
+  Pass --enable-silent-rules to configure for a quieter build (similar to
+  the Linux kernel).  Use make warnings instead of make to build with full
+  compiler warnings (requires either GCC or Clang and may require a
+  relatively current version of the compiler).
+
+  Installing C TAP Harness is not normally done.  Instead, see the section
+  on using the harness below.
+
+TESTING
 
-  Use make warnings instead of make to build with full GCC compiler
-  warnings (requires a relatively current version of GCC).
+  C TAP Harness comes with a comprehensive test suite, which you can run
+  after building with:
+
+      make check
 
   If a test fails, you can run a single test with verbose output via:
 
-      ./runtests -b `pwd`/tests -s `pwd`/tests -o <name-of-test>
+      tests/runtests -b $(pwd)/tests -s $(pwd)/tests -o <name-of-test>
 
   Do this instead of running the test program directly since it will
   ensure that necessary environment variables are set up.  You may need to
-  change the -s option if you build with a separate build directory from
-  the source directory.
+  change the -s option argument if you build with a separate build
+  directory from the source directory.
+
+  To run the test suite, you will need Perl 5.8 or later.  The following
+  additional Perl modules will be used by the test suite if present:
+
+  * Test::Pod
+  * Test::Spelling
+
+  All are available on CPAN.  Those tests will be skipped if the modules
+  are not available.
+
+  To enable tests that don't detect functionality problems but are used to
+  sanity-check the release, set the environment variable RELEASE_TESTING
+  to a true value.  To enable tests that may be sensitive to the local
+  environment or that produce a lot of false positives without uncovering
+  many problems, set the environment variable AUTHOR_TESTING to a true
+  value.
 
 USING THE HARNESS
 
@@ -123,8 +145,8 @@ USING THE HARNESS
     library:
 
         check_PROGRAMS = tests/runtests
-        tests_runtests_CPPFLAGS = -DSOURCE='"$(abs_top_srcdir)/tests"' \
-                -DBUILD='"$(abs_top_builddir)/tests"'
+        tests_runtests_CPPFLAGS = -DC_TAP_SOURCE='"$(abs_top_srcdir)/tests"' \
+                -DC_TAP_BUILD='"$(abs_top_builddir)/tests"'
         check_LIBRARIES = tests/tap/libtap.a
         tests_tap_libtap_a_CPPFLAGS = -I$(abs_top_srcdir)/tests
         tests_tap_libtap_a_SOURCES = tests/tap/basic.c tests/tap/basic.h \
@@ -132,8 +154,8 @@ USING THE HARNESS
 
     Omit float.c and float.h from the last line if your package doesn't
     need the is_double function.  Building the build and source
-    directories into runtests will let tests/runtests -o <test> to work
-    for users without requiring that they set any other variables, even if
+    directories into runtests will let tests/runtests -o <test> work for
+    users without requiring that they set any other variables, even if
     they're doing an out-of-source build.
 
     Add additional source files and headers that should go into the TAP
@@ -142,16 +164,18 @@ USING THE HARNESS
   * Add code to Makefile.am to run the test suite:
 
         check-local: $(check_PROGRAMS)
-              cd tests && ./runtests $(abs_top_srcdir)/tests/TESTS
+              cd tests && ./runtests -l $(abs_top_srcdir)/tests/TESTS
+
+    See the Makefile.am in this package for an example.
+
+  * List the test programs in the tests/TESTS file.  This should have the
+    name of the test executable with the trailing "-t" or ".t" (you can
+    use either extension as you prefer) omitted.
 
-    See the Makefile.am in this package for an example (although note that
-    it keeps runtests in an unusual location).
+    Test programs must be executable.
 
-  * List the test programs in the TESTS file.  This should have the name
-    of the test executable with the trailing "-t" or ".t" (you can use
-    either extension as you prefer) omitted.  For any test programs that
-    need to be compiled, add build rules for them in Makefile.am, simliar
-    to:
+    For any test programs that need to be compiled, add build rules for
+    them in Makefile.am, similar to:
 
         tests_libtap_c_basic_LDADD = tests/tap/libtap.a
 
@@ -173,7 +197,7 @@ USING THE HARNESS
     the tap subdirectory of your tests directory and add it to EXTRA_DIST.
     Shell programs should start with:
 
-        . "${SOURCE}/tap/libtap.sh"
+        . "${C_TAP_SOURCE}/tap/libtap.sh"
 
     and can then use the functions defined in the library.
 
@@ -186,43 +210,93 @@ USING THE HARNESS
 
   If you have data files that your test cases use, conventionally they go
   into tests/data.  You can then find the data directory relative to the
-  SOURCE environment variable (set by runtests) in your test program.  If
-  you have data that's compiled or generated by Autoconf, it will be
-  relative to the BUILD environment variable.  Don't forget to add test
-  data to EXTRA_DIST as necessary.
+  C_TAP_SOURCE environment variable (set by runtests) in your test
+  program.  If you have data that's compiled or generated by Autoconf, it
+  will be relative to the BUILD environment variable.  Don't forget to add
+  test data to EXTRA_DIST as necessary.
 
   For more TAP library add-ons, generally ones that rely on additional
   portability code not shipped in this package or with narrower uses, see
-  the rra-c-util package:
+  the rra-c-util package [1].  There are several additional TAP library
+  add-ons in the tests/tap directory in that package.  It's also an
+  example of how to use this test harness in another package.
 
-      http://www.eyrie.org/~eagle/software/rra-c-util/
+  [1] https://www.eyrie.org/~eagle/software/rra-c-util/
 
-  There are several additional TAP library add-ons in the tests/tap
-  directory in that package.  It's also an example of how to use this test
-  harness in another package.
-
-HOMEPAGE AND SOURCE REPOSITORY
+SUPPORT
 
   The C TAP Harness web page at:
 
-      http://www.eyrie.org/~eagle/software/c-tap-harness/
+      https://www.eyrie.org/~eagle/software/c-tap-harness/
 
   will always have the current version of this package, the current
   documentation, and pointers to any additional resources.
 
-  C TAP Harness is maintained using Git.  You can access the current
-  source by cloning the repository at:
+  For bug tracking, use the issue tracker on GitHub:
 
-      git://git.eyrie.org/devel/c-tap-harness.git
+      https://github.com/rra/c-tap-harness/issues
 
-  or view the repository via the web at:
+  However, please be aware that I tend to be extremely busy and work
+  projects often take priority.  I'll save your report and get to it as
+  soon as I can, but it may take me a couple of months.
 
-      http://git.eyrie.org/?p=devel/c-tap-harness.git
+SOURCE REPOSITORY
 
-  C TAP Harness is also available via github at:
+  C TAP Harness is maintained using Git.  You can access the current
+  source on GitHub at:
+
+      https://github.com/rra/c-tap-harness
+
+  or by cloning the repository at:
 
-      http://github.com/rra/c-tap-harness
+      https://git.eyrie.org/git/devel/c-tap-harness.git
+
+  or view the repository via the web at:
 
-  and the github wiki and issue tracker are available on an experimental
-  basis.  If you like using the github facilities, try filing issues or
-  adding supplemental documentation there.
+      https://git.eyrie.org/?p=devel/c-tap-harness.git
+
+  The eyrie.org repository is the canonical one, maintained by the author,
+  but using GitHub is probably more convenient for most purposes.  Pull
+  requests are gratefully reviewed and normally accepted.
+
+LICENSE
+
+  The C TAP Harness package as a whole is covered by the following
+  copyright statement and license:
+
+    Copyright 2000-2001, 2004, 2006-2020 Russ Allbery <eagle@eyrie.org>
+    Copyright 2006-2009, 2011-2013
+        The Board of Trustees of the Leland Stanford Junior University
+
+    Permission is hereby granted, free of charge, to any person obtaining
+    a copy of this software and associated documentation files (the
+    "Software"), to deal in the Software without restriction, including
+    without limitation the rights to use, copy, modify, merge, publish,
+    distribute, sublicense, and/or sell copies of the Software, and to
+    permit persons to whom the Software is furnished to do so, subject to
+    the following conditions:
+
+    The above copyright notice and this permission notice shall be
+    included in all copies or substantial portions of the Software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+    IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+    CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+    TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+    SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+  Some files in this distribution are individually released under
+  different licenses, all of which are compatible with the above general
+  package license but which may require preservation of additional
+  notices.  All required notices, and detailed information about the
+  licensing of each file, are recorded in the LICENSE file.
+
+  Files covered by a license with an assigned SPDX License Identifier
+  include SPDX-License-Identifier tags to enable automated processing of
+  license information.  See https://spdx.org/licenses/ for more
+  information.
+
+  For any copyright range specified by files in this package as YYYY-ZZZZ,
+  the range specifies every single year in that closed interval.
diff --git a/src/external/c-tap-harness/tests/runtests.c b/src/external/c-tap-harness/tests/runtests.c
index 424987568..1050120c7 100644
--- a/src/external/c-tap-harness/tests/runtests.c
+++ b/src/external/c-tap-harness/tests/runtests.c
@@ -1,17 +1,53 @@
 /*
  * Run a set of tests, reporting results.
  *
+ * Test suite driver that runs a set of tests implementing a subset of the
+ * Test Anything Protocol (TAP) and reports the results.
+ *
+ * Any bug reports, bug fixes, and improvements are very much welcome and
+ * should be sent to the e-mail address below.  This program is part of C TAP
+ * Harness <https://www.eyrie.org/~eagle/software/c-tap-harness/>.
+ *
+ * Copyright 2000-2001, 2004, 2006-2019 Russ Allbery <eagle@eyrie.org>
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * SPDX-License-Identifier: MIT
+ */
+
+/*
  * Usage:
  *
- *      runtests [-b <build-dir>] [-s <source-dir>] <test-list>
- *      runtests -o [-b <build-dir>] [-s <source-dir>] <test>
+ *      runtests [-hv] [-b <build-dir>] [-s <source-dir>] -l <test-list>
+ *      runtests [-hv] [-b <build-dir>] [-s <source-dir>] <test> [<test> ...]
+ *      runtests -o [-h] [-b <build-dir>] [-s <source-dir>] <test>
  *
  * In the first case, expects a list of executables located in the given file,
- * one line per executable.  For each one, runs it as part of a test suite,
- * reporting results.  Test output should start with a line containing the
- * number of tests (numbered from 1 to this number), optionally preceded by
- * "1..", although that line may be given anywhere in the output.  Each
- * additional line should be in the following format:
+ * one line per executable, possibly followed by a space-separated list of
+ * options.  For each one, runs it as part of a test suite, reporting results.
+ * In the second case, use the same infrastructure, but run only the tests
+ * listed on the command line.
+ *
+ * Test output should start with a line containing the number of tests
+ * (numbered from 1 to this number), optionally preceded by "1..", although
+ * that line may be given anywhere in the output.  Each additional line should
+ * be in the following format:
  *
  *      ok <number>
  *      not ok <number>
@@ -44,49 +80,30 @@
  * output.  This is intended for use with failing tests so that the person
  * running the test suite can get more details about what failed.
  *
- * If built with the C preprocessor symbols SOURCE and BUILD defined, C TAP
- * Harness will export those values in the environment so that tests can find
- * the source and build directory and will look for tests under both
- * directories.  These paths can also be set with the -b and -s command-line
- * options, which will override anything set at build time.
+ * If built with the C preprocessor symbols C_TAP_SOURCE and C_TAP_BUILD
+ * defined, C TAP Harness will export those values in the environment so that
+ * tests can find the source and build directory and will look for tests under
+ * both directories.  These paths can also be set with the -b and -s
+ * command-line options, which will override anything set at build time.
  *
- * Any bug reports, bug fixes, and improvements are very much welcome and
- * should be sent to the e-mail address below.  This program is part of C TAP
- * Harness <http://www.eyrie.org/~eagle/software/c-tap-harness/>.
- *
- * Copyright 2000, 2001, 2004, 2006, 2007, 2008, 2009, 2010, 2011
- *     Russ Allbery <rra@stanford.edu>
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
- * DEALINGS IN THE SOFTWARE.
-*/
+ * If the -v option is given, or the C_TAP_VERBOSE environment variable is set,
+ * display the full output of each test as it runs rather than showing a
+ * summary of the results of each test.
+ */
 
 /* Required for fdopen(), getopt(), and putenv(). */
 #if defined(__STRICT_ANSI__) || defined(PEDANTIC)
-# ifndef _XOPEN_SOURCE
-#  define _XOPEN_SOURCE 500
-# endif
+#    ifndef _XOPEN_SOURCE
+#        define _XOPEN_SOURCE 500
+#    endif
 #endif
 
 #include <ctype.h>
 #include <errno.h>
 #include <fcntl.h>
+#include <limits.h>
 #include <stdarg.h>
+#include <stddef.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
@@ -101,63 +118,81 @@
 /* sys/time.h must be included before sys/resource.h on some platforms. */
 #include <sys/resource.h>
 
-/* AIX doesn't have WCOREDUMP. */
+/* AIX 6.1 (and possibly later) doesn't have WCOREDUMP. */
 #ifndef WCOREDUMP
-# define WCOREDUMP(status)      ((unsigned)(status) & 0x80)
+#    define WCOREDUMP(status) ((unsigned) (status) &0x80)
+#endif
+
+/*
+ * POSIX requires that these be defined in <unistd.h>, but they're not always
+ * available.  If one of them has been defined, all the rest almost certainly
+ * have.
+ */
+#ifndef STDIN_FILENO
+#    define STDIN_FILENO  0
+#    define STDOUT_FILENO 1
+#    define STDERR_FILENO 2
 #endif
 
+/*
+ * Used for iterating through arrays.  Returns the number of elements in the
+ * array (useful for a < upper bound in a for loop).
+ */
+#define ARRAY_SIZE(array) (sizeof(array) / sizeof((array)[0]))
+
 /*
  * The source and build versions of the tests directory.  This is used to set
- * the SOURCE and BUILD environment variables and find test programs, if set.
- * Normally, this should be set as part of the build process to the test
- * subdirectories of $(abs_top_srcdir) and $(abs_top_builddir) respectively.
+ * the C_TAP_SOURCE and C_TAP_BUILD environment variables (and the SOURCE and
+ * BUILD environment variables set for backward compatibility) and find test
+ * programs, if set.  Normally, this should be set as part of the build
+ * process to the test subdirectories of $(abs_top_srcdir) and
+ * $(abs_top_builddir) respectively.
  */
-#ifndef SOURCE
-# define SOURCE NULL
+#ifndef C_TAP_SOURCE
+#    define C_TAP_SOURCE NULL
 #endif
-#ifndef BUILD
-# define BUILD NULL
+#ifndef C_TAP_BUILD
+#    define C_TAP_BUILD NULL
 #endif
 
 /* Test status codes. */
-enum test_status {
-    TEST_FAIL,
-    TEST_PASS,
-    TEST_SKIP,
-    TEST_INVALID
-};
+enum test_status { TEST_FAIL, TEST_PASS, TEST_SKIP, TEST_INVALID };
+
+/* Really, just a boolean, but this is more self-documenting. */
+enum test_verbose { CONCISE = 0, VERBOSE = 1 };
 
 /* Indicates the state of our plan. */
 enum plan_status {
-    PLAN_INIT,                  /* Nothing seen yet. */
-    PLAN_FIRST,                 /* Plan seen before any tests. */
-    PLAN_PENDING,               /* Test seen and no plan yet. */
-    PLAN_FINAL                  /* Plan seen after some tests. */
+    PLAN_INIT,    /* Nothing seen yet. */
+    PLAN_FIRST,   /* Plan seen before any tests. */
+    PLAN_PENDING, /* Test seen and no plan yet. */
+    PLAN_FINAL    /* Plan seen after some tests. */
 };
 
 /* Error exit statuses for test processes. */
-#define CHILDERR_DUP    100     /* Couldn't redirect stderr or stdout. */
-#define CHILDERR_EXEC   101     /* Couldn't exec child process. */
-#define CHILDERR_STDERR 102     /* Couldn't open stderr file. */
+#define CHILDERR_DUP    100 /* Couldn't redirect stderr or stdout. */
+#define CHILDERR_EXEC   101 /* Couldn't exec child process. */
+#define CHILDERR_STDIN  102 /* Couldn't open stdin file. */
+#define CHILDERR_STDERR 103 /* Couldn't open stderr file. */
 
 /* Structure to hold data for a set of tests. */
 struct testset {
-    char *file;                 /* The file name of the test. */
-    char *path;                 /* The path to the test program. */
-    enum plan_status plan;      /* The status of our plan. */
-    unsigned long count;        /* Expected count of tests. */
-    unsigned long current;      /* The last seen test number. */
-    unsigned int length;        /* The length of the last status message. */
-    unsigned long passed;       /* Count of passing tests. */
-    unsigned long failed;       /* Count of failing lists. */
-    unsigned long skipped;      /* Count of skipped tests (passed). */
-    unsigned long allocated;    /* The size of the results table. */
-    enum test_status *results;  /* Table of results by test number. */
-    unsigned int aborted;       /* Whether the set as aborted. */
-    int reported;               /* Whether the results were reported. */
-    int status;                 /* The exit status of the test. */
-    unsigned int all_skipped;   /* Whether all tests were skipped. */
-    char *reason;               /* Why all tests were skipped. */
+    char *file;                /* The file name of the test. */
+    char **command;            /* The argv vector to run the command. */
+    enum plan_status plan;     /* The status of our plan. */
+    unsigned long count;       /* Expected count of tests. */
+    unsigned long current;     /* The last seen test number. */
+    unsigned int length;       /* The length of the last status message. */
+    unsigned long passed;      /* Count of passing tests. */
+    unsigned long failed;      /* Count of failing lists. */
+    unsigned long skipped;     /* Count of skipped tests (passed). */
+    unsigned long allocated;   /* The size of the results table. */
+    enum test_status *results; /* Table of results by test number. */
+    unsigned int aborted;      /* Whether the set was aborted. */
+    unsigned int reported;     /* Whether the results were reported. */
+    int status;                /* The exit status of the test. */
+    unsigned int all_skipped;  /* Whether all tests were skipped. */
+    char *reason;              /* Why all tests were skipped. */
 };
 
 /* Structure to hold a linked list of test sets. */
@@ -167,21 +202,27 @@ struct testlist {
 };
 
 /*
- * Usage message.  Should be used as a printf format with two arguments: the
- * path to runtests, given twice.
+ * Usage message.  Should be used as a printf format with four arguments: the
+ * path to runtests, given three times, and the usage_description.  This is
+ * split into variables to satisfy the pedantic ISO C90 limit on strings.
  */
 static const char usage_message[] = "\
-Usage: %s [-b <build-dir>] [-s <source-dir>] <test-list>\n\
-       %s -o [-b <build-dir>] [-s <source-dir>] <test>\n\
+Usage: %s [-hv] [-b <build-dir>] [-s <source-dir>] <test> ...\n\
+       %s [-hv] [-b <build-dir>] [-s <source-dir>] -l <test-list>\n\
+       %s -o [-h] [-b <build-dir>] [-s <source-dir>] <test>\n\
 \n\
 Options:\n\
     -b <build-dir>      Set the build directory to <build-dir>\n\
+%s";
+static const char usage_extra[] = "\
+    -l <list>           Take the list of tests to run from <test-list>\n\
     -o                  Run a single test rather than a list of tests\n\
     -s <source-dir>     Set the source directory to <source-dir>\n\
+    -v                  Show the full output of each test\n\
 \n\
-runtests normally runs each test listed in a file whose path is given as\n\
-its command-line argument.  With the -o option, it instead runs a single\n\
-test and shows its complete output.\n";
+runtests normally runs each test listed on the command line.  With the -l\n\
+option, it instead runs every test listed in a file.  With the -o option,\n\
+it instead runs a single test and shows its complete output.\n";
 
 /*
  * Header used for test output.  %s is replaced by the file name of the list
@@ -197,9 +238,83 @@ Failed Set                 Fail/Total (%) Skip Stat  Failing Tests\n\
 -------------------------- -------------- ---- ----  ------------------------";
 
 /* Include the file name and line number in malloc failures. */
-#define xmalloc(size)     x_malloc((size), __FILE__, __LINE__)
-#define xrealloc(p, size) x_realloc((p), (size), __FILE__, __LINE__)
+#define xcalloc(n, type) \
+    ((type *) x_calloc((n), sizeof(type), __FILE__, __LINE__))
+#define xmalloc(size)     ((char *) x_malloc((size), __FILE__, __LINE__))
 #define xstrdup(p)        x_strdup((p), __FILE__, __LINE__)
+#define xstrndup(p, size) x_strndup((p), (size), __FILE__, __LINE__)
+#define xreallocarray(p, n, type) \
+    ((type *) x_reallocarray((p), (n), sizeof(type), __FILE__, __LINE__))
+
+/*
+ * __attribute__ is available in gcc 2.5 and later, but only with gcc 2.7
+ * could you use the __format__ form of the attributes, which is what we use
+ * (to avoid confusion with other macros).
+ */
+#ifndef __attribute__
+#    if __GNUC__ < 2 || (__GNUC__ == 2 && __GNUC_MINOR__ < 7)
+#        define __attribute__(spec) /* empty */
+#    endif
+#endif
+
+/*
+ * We use __alloc_size__, but it was only available in fairly recent versions
+ * of GCC.  Suppress warnings about the unknown attribute if GCC is too old.
+ * We know that we're GCC at this point, so we can use the GCC variadic macro
+ * extension, which will still work with versions of GCC too old to have C99
+ * variadic macro support.
+ */
+#if !defined(__attribute__) && !defined(__alloc_size__)
+#    if defined(__GNUC__) && !defined(__clang__)
+#        if __GNUC__ < 4 || (__GNUC__ == 4 && __GNUC_MINOR__ < 3)
+#            define __alloc_size__(spec, args...) /* empty */
+#        endif
+#    endif
+#endif
+
+/*
+ * LLVM and Clang pretend to be GCC but don't support all of the __attribute__
+ * settings that GCC does.  For them, suppress warnings about unknown
+ * attributes on declarations.  This unfortunately will affect the entire
+ * compilation context, but there's no push and pop available.
+ */
+#if !defined(__attribute__) && (defined(__llvm__) || defined(__clang__))
+#    pragma GCC diagnostic ignored "-Wattributes"
+#endif
+
+/* Declare internal functions that benefit from compiler attributes. */
+static void die(const char *, ...)
+    __attribute__((__nonnull__, __noreturn__, __format__(printf, 1, 2)));
+static void sysdie(const char *, ...)
+    __attribute__((__nonnull__, __noreturn__, __format__(printf, 1, 2)));
+static void *x_calloc(size_t, size_t, const char *, int)
+    __attribute__((__alloc_size__(1, 2), __malloc__, __nonnull__));
+static void *x_malloc(size_t, const char *, int)
+    __attribute__((__alloc_size__(1), __malloc__, __nonnull__));
+static void *x_reallocarray(void *, size_t, size_t, const char *, int)
+    __attribute__((__alloc_size__(2, 3), __malloc__, __nonnull__(4)));
+static char *x_strdup(const char *, const char *, int)
+    __attribute__((__malloc__, __nonnull__));
+static char *x_strndup(const char *, size_t, const char *, int)
+    __attribute__((__malloc__, __nonnull__));
+
+
+/*
+ * Report a fatal error and exit.
+ */
+static void
+die(const char *format, ...)
+{
+    va_list args;
+
+    fflush(stdout);
+    fprintf(stderr, "runtests: ");
+    va_start(args, format);
+    vfprintf(stderr, format, args);
+    va_end(args);
+    fprintf(stderr, "\n");
+    exit(1);
+}
 
 
 /*
@@ -222,6 +337,24 @@ sysdie(const char *format, ...)
 }
 
 
+/*
+ * Allocate zeroed memory, reporting a fatal error and exiting on failure.
+ */
+static void *
+x_calloc(size_t n, size_t size, const char *file, int line)
+{
+    void *p;
+
+    n = (n > 0) ? n : 1;
+    size = (size > 0) ? size : 1;
+    p = calloc(n, size);
+    if (p == NULL)
+        sysdie("failed to calloc %lu bytes at %s line %d",
+               (unsigned long) size, file, line);
+    return p;
+}
+
+
 /*
  * Allocate memory, reporting a fatal error and exiting on failure.
  */
@@ -240,14 +373,29 @@ x_malloc(size_t size, const char *file, int line)
 
 /*
  * Reallocate memory, reporting a fatal error and exiting on failure.
+ *
+ * We should technically use SIZE_MAX here for the overflow check, but
+ * SIZE_MAX is C99 and we're only assuming C89 + SUSv3, which does not
+ * guarantee that it exists.  They do guarantee that UINT_MAX exists, and we
+ * can assume that UINT_MAX <= SIZE_MAX.  And we should not be allocating
+ * anything anywhere near that large.
+ *
+ * (In theory, C89 and C99 permit size_t to be smaller than unsigned int, but
+ * I disbelieve in the existence of such systems and they will have to cope
+ * without overflow checks.)
  */
 static void *
-x_realloc(void *p, size_t size, const char *file, int line)
+x_reallocarray(void *p, size_t n, size_t size, const char *file, int line)
 {
-    p = realloc(p, size);
+    n = (n > 0) ? n : 1;
+    size = (size > 0) ? size : 1;
+
+    if (n > 0 && UINT_MAX / n <= size)
+        sysdie("realloc too large at %s line %d", file, line);
+    p = realloc(p, n * size);
     if (p == NULL)
         sysdie("failed to realloc %lu bytes at %s line %d",
-               (unsigned long) size, file, line);
+               (unsigned long) (n * size), file, line);
     return p;
 }
 
@@ -262,15 +410,93 @@ x_strdup(const char *s, const char *file, int line)
     size_t len;
 
     len = strlen(s) + 1;
-    p = malloc(len);
+    p = (char *) malloc(len);
     if (p == NULL)
-        sysdie("failed to strdup %lu bytes at %s line %d",
-               (unsigned long) len, file, line);
+        sysdie("failed to strdup %lu bytes at %s line %d", (unsigned long) len,
+               file, line);
     memcpy(p, s, len);
     return p;
 }
 
 
+/*
+ * Copy the first n characters of a string, reporting a fatal error and
+ * existing on failure.
+ *
+ * Avoid using the system strndup function since it may not exist (on Mac OS
+ * X, for example), and there's no need to introduce another portability
+ * requirement.
+ */
+char *
+x_strndup(const char *s, size_t size, const char *file, int line)
+{
+    const char *p;
+    size_t len;
+    char *copy;
+
+    /* Don't assume that the source string is nul-terminated. */
+    for (p = s; (size_t)(p - s) < size && *p != '\0'; p++)
+        ;
+    len = (size_t)(p - s);
+    copy = (char *) malloc(len + 1);
+    if (copy == NULL)
+        sysdie("failed to strndup %lu bytes at %s line %d",
+               (unsigned long) len, file, line);
+    memcpy(copy, s, len);
+    copy[len] = '\0';
+    return copy;
+}
+
+
+/*
+ * Form a new string by concatenating multiple strings.  The arguments must be
+ * terminated by (const char *) 0.
+ *
+ * This function only exists because we can't assume asprintf.  We can't
+ * simulate asprintf with snprintf because we're only assuming SUSv3, which
+ * does not require that snprintf with a NULL buffer return the required
+ * length.  When those constraints are relaxed, this should be ripped out and
+ * replaced with asprintf or a more trivial replacement with snprintf.
+ */
+static char *
+concat(const char *first, ...)
+{
+    va_list args;
+    char *result;
+    const char *string;
+    size_t offset;
+    size_t length = 0;
+
+    /*
+     * Find the total memory required.  Ensure we don't overflow length.  We
+     * aren't guaranteed to have SIZE_MAX, so use UINT_MAX as an acceptable
+     * substitute (see the x_nrealloc comments).
+     */
+    va_start(args, first);
+    for (string = first; string != NULL; string = va_arg(args, const char *)) {
+        if (length >= UINT_MAX - strlen(string)) {
+            errno = EINVAL;
+            sysdie("strings too long in concat");
+        }
+        length += strlen(string);
+    }
+    va_end(args);
+    length++;
+
+    /* Create the string. */
+    result = xmalloc(length);
+    va_start(args, first);
+    offset = 0;
+    for (string = first; string != NULL; string = va_arg(args, const char *)) {
+        memcpy(result + offset, string, strlen(string));
+        offset += strlen(string);
+    }
+    va_end(args);
+    result[offset] = '\0';
+    return result;
+}
+
+
 /*
  * Given a struct timeval, return the number of seconds it represents as a
  * double.  Use difftime() to convert a time_t to a double.
@@ -278,7 +504,7 @@ x_strdup(const char *s, const char *file, int line)
 static double
 tv_seconds(const struct timeval *tv)
 {
-    return difftime(tv->tv_sec, 0) + tv->tv_usec * 1e-6;
+    return difftime(tv->tv_sec, 0) + (double) tv->tv_usec * 1e-6;
 }
 
 
@@ -309,7 +535,20 @@ tv_sum(const struct timeval *tv1, const struct timeval *tv2)
 static const char *
 skip_whitespace(const char *p)
 {
-    while (isspace((unsigned char)(*p)))
+    while (isspace((unsigned char) (*p)))
+        p++;
+    return p;
+}
+
+
+/*
+ * Given a pointer to a string, skip any non-whitespace characters and return
+ * a pointer to the first whitespace character, or to the end of the string.
+ */
+static const char *
+skip_non_whitespace(const char *p)
+{
+    while (*p != '\0' && !isspace((unsigned char) (*p)))
         p++;
     return p;
 }
@@ -321,38 +560,65 @@ skip_whitespace(const char *p)
  * argument.  Returns the PID of the new process.  Errors are fatal.
  */
 static pid_t
-test_start(const char *path, int *fd)
+test_start(char *const *command, int *fd)
 {
-    int fds[2], errfd;
+    int fds[2], infd, errfd;
     pid_t child;
 
+    /* Create a pipe used to capture the output from the test program. */
     if (pipe(fds) == -1) {
         puts("ABORTED");
         fflush(stdout);
         sysdie("can't create pipe");
     }
+
+    /* Fork a child process, massage the file descriptors, and exec. */
     child = fork();
-    if (child == (pid_t) -1) {
+    switch (child) {
+    case -1:
         puts("ABORTED");
         fflush(stdout);
         sysdie("can't fork");
-    } else if (child == 0) {
-        /* In child.  Set up our stdout and stderr. */
+
+    /* In the child.  Set up our standard output. */
+    case 0:
+        close(fds[0]);
+        close(STDOUT_FILENO);
+        if (dup2(fds[1], STDOUT_FILENO) < 0)
+            _exit(CHILDERR_DUP);
+        close(fds[1]);
+
+        /* Point standard input at /dev/null. */
+        close(STDIN_FILENO);
+        infd = open("/dev/null", O_RDONLY);
+        if (infd < 0)
+            _exit(CHILDERR_STDIN);
+        if (infd != STDIN_FILENO) {
+            if (dup2(infd, STDIN_FILENO) < 0)
+                _exit(CHILDERR_DUP);
+            close(infd);
+        }
+
+        /* Point standard error at /dev/null. */
+        close(STDERR_FILENO);
         errfd = open("/dev/null", O_WRONLY);
         if (errfd < 0)
             _exit(CHILDERR_STDERR);
-        if (dup2(errfd, 2) == -1)
-            _exit(CHILDERR_DUP);
-        close(fds[0]);
-        if (dup2(fds[1], 1) == -1)
-            _exit(CHILDERR_DUP);
+        if (errfd != STDERR_FILENO) {
+            if (dup2(errfd, STDERR_FILENO) < 0)
+                _exit(CHILDERR_DUP);
+            close(errfd);
+        }
 
         /* Now, exec our process. */
-        if (execl(path, path, (char *) 0) == -1)
+        if (execv(command[0], command) == -1)
             _exit(CHILDERR_EXEC);
-    } else {
-        /* In parent.  Close the extra file descriptor. */
+        break;
+
+    /* In parent.  Close the extra file descriptor. */
+    default:
         close(fds[1]);
+        break;
     }
     *fd = fds[0];
     return child;
@@ -379,6 +645,55 @@ test_backspace(struct testset *ts)
 }
 
 
+/*
+ * Allocate or resize the array of test results to be large enough to contain
+ * the test number in.
+ */
+static void
+resize_results(struct testset *ts, unsigned long n)
+{
+    unsigned long i;
+    size_t s;
+
+    /* If there's already enough space, return quickly. */
+    if (n <= ts->allocated)
+        return;
+
+    /*
+     * If no space has been allocated, do the initial allocation.  Otherwise,
+     * resize.  Start with 32 test cases and then add 1024 with each resize to
+     * try to reduce the number of reallocations.
+     */
+    if (ts->allocated == 0) {
+        s = (n > 32) ? n : 32;
+        ts->results = xcalloc(s, enum test_status);
+    } else {
+        s = (n > ts->allocated + 1024) ? n : ts->allocated + 1024;
+        ts->results = xreallocarray(ts->results, s, enum test_status);
+    }
+
+    /* Set the results for the newly-allocated test array. */
+    for (i = ts->allocated; i < s; i++)
+        ts->results[i] = TEST_INVALID;
+    ts->allocated = s;
+}
+
+
+/*
+ * Report an invalid test number and set the appropriate flags.  Pulled into a
+ * separate function since we do this in several places.
+ */
+static void
+invalid_test_number(struct testset *ts, long n, enum test_verbose verbose)
+{
+    if (!verbose)
+        test_backspace(ts);
+    printf("ABORTED (invalid test number %ld)\n", n);
+    ts->aborted = 1;
+    ts->reported = 1;
+}
+
+
 /*
  * Read the plan line of test output, which should contain the range of test
  * numbers.  We may initialize the testset structure here if we haven't yet
@@ -386,9 +701,8 @@ test_backspace(struct testset *ts)
  * continue, false otherwise.
  */
 static int
-test_plan(const char *line, struct testset *ts)
+test_plan(const char *line, struct testset *ts, enum test_verbose verbose)
 {
-    unsigned long i;
     long n;
 
     /*
@@ -401,12 +715,14 @@ test_plan(const char *line, struct testset *ts)
         line += 3;
 
     /*
-     * Get the count, check it for validity, and initialize the struct.  If we
-     * have something of the form "1..0 # skip foo", the whole file was
+     * Get the count and check it for validity.
+     *
+     * If we have something of the form "1..0 # skip foo", the whole file was
      * skipped; record that.  If we do skip the whole file, zero out all of
-     * our statistics, since they're no longer relevant.  strtol is called
-     * with a second argument to advance the line pointer past the count to
-     * make it simpler to detect the # skip case.
+     * our statistics, since they're no longer relevant.
+     *
+     * strtol is called with a second argument to advance the line pointer
+     * past the count to make it simpler to detect the # skip case.
      */
     n = strtol(line, (char **) &line, 10);
     if (n == 0) {
@@ -435,29 +751,27 @@ test_plan(const char *line, struct testset *ts)
         ts->reported = 1;
         return 0;
     }
-    if (ts->plan == PLAN_INIT && ts->allocated == 0) {
-        ts->count = n;
-        ts->allocated = n;
+
+    /*
+     * If we are doing lazy planning, check the plan against the largest test
+     * number that we saw and fail now if we saw a check outside the plan
+     * range.
+     */
+    if (ts->plan == PLAN_PENDING && (unsigned long) n < ts->count) {
+        invalid_test_number(ts, (long) ts->count, verbose);
+        return 0;
+    }
+
+    /*
+     * Otherwise, allocated or resize the results if needed and update count,
+     * and then record that we've seen a plan.
+     */
+    resize_results(ts, (unsigned long) n);
+    ts->count = (unsigned long) n;
+    if (ts->plan == PLAN_INIT)
         ts->plan = PLAN_FIRST;
-        ts->results = xmalloc(ts->count * sizeof(enum test_status));
-        for (i = 0; i < ts->count; i++)
-            ts->results[i] = TEST_INVALID;
-    } else if (ts->plan == PLAN_PENDING) {
-        if ((unsigned long) n < ts->count) {
-            printf("ABORTED (invalid test number %lu)\n", ts->count);
-            ts->aborted = 1;
-            ts->reported = 1;
-            return 0;
-        }
-        ts->count = n;
-        if ((unsigned long) n > ts->allocated) {
-            ts->results = xrealloc(ts->results, n * sizeof(enum test_status));
-            for (i = ts->allocated; i < ts->count; i++)
-                ts->results[i] = TEST_INVALID;
-            ts->allocated = n;
-        }
+    else if (ts->plan == PLAN_PENDING)
         ts->plan = PLAN_FINAL;
-    }
     return 1;
 }
 
@@ -469,13 +783,13 @@ test_plan(const char *line, struct testset *ts)
  * reported status.
  */
 static void
-test_checkline(const char *line, struct testset *ts)
+test_checkline(const char *line, struct testset *ts, enum test_verbose verbose)
 {
     enum test_status status = TEST_PASS;
     const char *bail;
     char *end;
     long number;
-    unsigned long i, current;
+    unsigned long current;
     int outlen;
 
     /* Before anything, check for a test abort. */
@@ -488,7 +802,8 @@ test_checkline(const char *line, struct testset *ts)
             length = strlen(bail);
             if (bail[length - 1] == '\n')
                 length--;
-            test_backspace(ts);
+            if (!verbose)
+                test_backspace(ts);
             printf("ABORTED (%.*s)\n", (int) length, bail);
             ts->reported = 1;
         }
@@ -508,14 +823,16 @@ test_checkline(const char *line, struct testset *ts)
         return;
 
     /* If we haven't yet seen a plan, look for one. */
-    if (ts->plan == PLAN_INIT && isdigit((unsigned char)(*line))) {
-        if (!test_plan(line, ts))
+    if (ts->plan == PLAN_INIT && isdigit((unsigned char) (*line))) {
+        if (!test_plan(line, ts, verbose))
             return;
     } else if (strncmp(line, "1..", 3) == 0) {
         if (ts->plan == PLAN_PENDING) {
-            if (!test_plan(line, ts))
+            if (!test_plan(line, ts, verbose))
                 return;
         } else {
+            if (!verbose)
+                test_backspace(ts);
             puts("ABORTED (multiple plans)");
             ts->aborted = 1;
             ts->reported = 1;
@@ -534,39 +851,30 @@ test_checkline(const char *line, struct testset *ts)
     errno = 0;
     number = strtol(line, &end, 10);
     if (errno != 0 || end == line)
-        number = ts->current + 1;
-    current = number;
-    if (number <= 0 || (current > ts->count && ts->plan == PLAN_FIRST)) {
-        test_backspace(ts);
-        printf("ABORTED (invalid test number %lu)\n", current);
-        ts->aborted = 1;
-        ts->reported = 1;
+        current = ts->current + 1;
+    else if (number <= 0) {
+        invalid_test_number(ts, number, verbose);
+        return;
+    } else
+        current = (unsigned long) number;
+    if (current > ts->count && ts->plan == PLAN_FIRST) {
+        invalid_test_number(ts, (long) current, verbose);
         return;
     }
 
     /* We have a valid test result.  Tweak the results array if needed. */
     if (ts->plan == PLAN_INIT || ts->plan == PLAN_PENDING) {
         ts->plan = PLAN_PENDING;
+        resize_results(ts, current);
         if (current > ts->count)
             ts->count = current;
-        if (current > ts->allocated) {
-            unsigned long n;
-
-            n = (ts->allocated == 0) ? 32 : ts->allocated * 2;
-            if (n < current)
-                n = current;
-            ts->results = xrealloc(ts->results, n * sizeof(enum test_status));
-            for (i = ts->allocated; i < n; i++)
-                ts->results[i] = TEST_INVALID;
-            ts->allocated = n;
-        }
     }
 
     /*
      * Handle directives.  We should probably do something more interesting
      * with unexpected passes of todo tests.
      */
-    while (isdigit((unsigned char)(*line)))
+    while (isdigit((unsigned char) (*line)))
         line++;
     line = skip_whitespace(line);
     if (*line == '#') {
@@ -579,7 +887,8 @@ test_checkline(const char *line, struct testset *ts)
 
     /* Make sure that the test number is in range and not a duplicate. */
     if (ts->results[current - 1] != TEST_INVALID) {
-        test_backspace(ts);
+        if (!verbose)
+            test_backspace(ts);
         printf("ABORTED (duplicate test number %lu)\n", current);
         ts->aborted = 1;
         ts->reported = 1;
@@ -588,17 +897,27 @@ test_checkline(const char *line, struct testset *ts)
 
     /* Good results.  Increment our various counters. */
     switch (status) {
-        case TEST_PASS: ts->passed++;   break;
-        case TEST_FAIL: ts->failed++;   break;
-        case TEST_SKIP: ts->skipped++;  break;
-        case TEST_INVALID:              break;
+    case TEST_PASS:
+        ts->passed++;
+        break;
+    case TEST_FAIL:
+        ts->failed++;
+        break;
+    case TEST_SKIP:
+        ts->skipped++;
+        break;
+    case TEST_INVALID:
+        break;
     }
     ts->current = current;
     ts->results[current - 1] = status;
-    test_backspace(ts);
-    if (isatty(STDOUT_FILENO)) {
-        outlen = printf("%lu/%lu", current, ts->count);
-        ts->length = (outlen >= 0) ? outlen : 0;
+    if (!verbose && isatty(STDOUT_FILENO)) {
+        test_backspace(ts);
+        if (ts->plan == PLAN_PENDING)
+            outlen = printf("%lu/?", current);
+        else
+            outlen = printf("%lu/%lu", current, ts->count);
+        ts->length = (outlen >= 0) ? (unsigned int) outlen : 0;
         fflush(stdout);
     }
 }
@@ -614,7 +933,7 @@ test_checkline(const char *line, struct testset *ts)
  * disable this).
  */
 static unsigned int
-test_print_range(unsigned long first, unsigned long last, unsigned int chars,
+test_print_range(unsigned long first, unsigned long last, unsigned long chars,
                  unsigned int limit)
 {
     unsigned int needed = 0;
@@ -754,6 +1073,7 @@ test_analyze(struct testset *ts)
             if (!ts->reported)
                 puts("ABORTED (execution failed -- not found?)");
             break;
+        case CHILDERR_STDIN:
         case CHILDERR_STDERR:
             if (!ts->reported)
                 puts("ABORTED (can't open /dev/null)");
@@ -783,7 +1103,7 @@ test_analyze(struct testset *ts)
  * false otherwise.
  */
 static int
-test_run(struct testset *ts)
+test_run(struct testset *ts, enum test_verbose verbose)
 {
     pid_t testpid, child;
     int outfd, status;
@@ -792,7 +1112,7 @@ test_run(struct testset *ts)
     char buffer[BUFSIZ];
 
     /* Run the test program. */
-    testpid = test_start(ts->path, &outfd);
+    testpid = test_start(ts->command, &outfd);
     output = fdopen(outfd, "r");
     if (!output) {
         puts("ABORTED");
@@ -800,12 +1120,19 @@ test_run(struct testset *ts)
         sysdie("fdopen failed");
     }
 
-    /* Pass each line of output to test_checkline(). */
-    while (!ts->aborted && fgets(buffer, sizeof(buffer), output))
-        test_checkline(buffer, ts);
+    /*
+     * Pass each line of output to test_checkline(), and print the line if
+     * verbosity is requested.
+     */
+    while (!ts->aborted && fgets(buffer, sizeof(buffer), output)) {
+        if (verbose)
+            printf("%s", buffer);
+        test_checkline(buffer, ts, verbose);
+    }
     if (ferror(output) || ts->plan == PLAN_INIT)
         ts->aborted = 1;
-    test_backspace(ts);
+    if (!verbose)
+        test_backspace(ts);
 
     /*
      * Consume the rest of the test output, close the output descriptor,
@@ -813,7 +1140,8 @@ test_run(struct testset *ts)
      * for eventual output.
      */
     while (fgets(buffer, sizeof(buffer), output))
-        ;
+        if (verbose)
+            printf("%s", buffer);
     fclose(output);
     child = waitpid(testpid, &ts->status, 0);
     if (child == (pid_t) -1) {
@@ -846,6 +1174,7 @@ test_fail_summary(const struct testlist *fails)
     struct testset *ts;
     unsigned int chars;
     unsigned long i, first, last, total;
+    double failed;
 
     puts(header);
 
@@ -854,8 +1183,9 @@ test_fail_summary(const struct testlist *fails)
     for (; fails; fails = fails->next) {
         ts = fails->ts;
         total = ts->count - ts->skipped;
+        failed = (double) ts->failed;
         printf("%-26.26s %4lu/%-4lu %3.0f%% %4lu ", ts->file, ts->failed,
-               total, total ? (ts->failed * 100.0) / total : 0,
+               total, total ? (failed * 100.0) / (double) total : 0,
                ts->skipped);
         if (WIFEXITED(ts->status))
             printf("%4d  ", WEXITSTATUS(ts->status));
@@ -883,109 +1213,325 @@ test_fail_summary(const struct testlist *fails)
         if (first != 0)
             test_print_range(first, last, chars, 19);
         putchar('\n');
-        free(ts->file);
-        free(ts->path);
-        free(ts->results);
-        if (ts->reason != NULL)
-            free(ts->reason);
-        free(ts);
     }
 }
 
 
+/*
+ * Check whether a given file path is a valid test.  Currently, this checks
+ * whether it is executable and is a regular file.  Returns true or false.
+ */
+static int
+is_valid_test(const char *path)
+{
+    struct stat st;
+
+    if (access(path, X_OK) < 0)
+        return 0;
+    if (stat(path, &st) < 0)
+        return 0;
+    if (!S_ISREG(st.st_mode))
+        return 0;
+    return 1;
+}
+
+
 /*
  * Given the name of a test, a pointer to the testset struct, and the source
  * and build directories, find the test.  We try first relative to the current
  * directory, then in the build directory (if not NULL), then in the source
  * directory.  In each of those directories, we first try a "-t" extension and
- * then a ".t" extension.  When we find an executable program, we fill in the
- * path member of the testset struct.  If none of those paths are executable,
- * just fill in the name of the test with "-t" appended.
+ * then a ".t" extension.  When we find an executable program, we return the
+ * path to that program.  If none of those paths are executable, just fill in
+ * the name of the test as is.
  *
  * The caller is responsible for freeing the path member of the testset
  * struct.
  */
-static void
-find_test(const char *name, struct testset *ts, const char *source,
-          const char *build)
+static char *
+find_test(const char *name, const char *source, const char *build)
 {
-    char *path;
-    const char *bases[4];
-    unsigned int i;
+    char *path = NULL;
+    const char *bases[3], *suffix, *base;
+    unsigned int i, j;
+    const char *suffixes[3] = {"-t", ".t", ""};
 
+    /* Possible base directories. */
     bases[0] = ".";
     bases[1] = build;
     bases[2] = source;
-    bases[3] = NULL;
 
-    for (i = 0; i < 3; i++) {
-        if (bases[i] == NULL)
+    /* Try each suffix with each base. */
+    for (i = 0; i < ARRAY_SIZE(suffixes); i++) {
+        suffix = suffixes[i];
+        for (j = 0; j < ARRAY_SIZE(bases); j++) {
+            base = bases[j];
+            if (base == NULL)
+                continue;
+            path = concat(base, "/", name, suffix, (const char *) 0);
+            if (is_valid_test(path))
+                return path;
+            free(path);
+            path = NULL;
+        }
+    }
+    if (path == NULL)
+        path = xstrdup(name);
+    return path;
+}
+
+
+/*
+ * Parse a single line of a test list and store the test name and command to
+ * execute it in the given testset struct.
+ *
+ * Normally, each line is just the name of the test, which is located in the
+ * test directory and turned into a command to run.  However, each line may
+ * have whitespace-separated options, which change the command that's run.
+ * Current supported options are:
+ *
+ * valgrind
+ *     Run the test under valgrind if C_TAP_VALGRIND is set.  The contents
+ *     of that environment variable are taken as the valgrind command (with
+ *     options) to run.  The command is parsed with a simple split on
+ *     whitespace and no quoting is supported.
+ *
+ * libtool
+ *     If running under valgrind, use libtool to invoke valgrind.  This avoids
+ *     running valgrind on the wrapper shell script generated by libtool.  If
+ *     set, C_TAP_LIBTOOL must be set to the full path to the libtool program
+ *     to use to run valgrind and thus the test.  Ignored if the test isn't
+ *     being run under valgrind.
+ */
+static void
+parse_test_list_line(const char *line, struct testset *ts, const char *source,
+                     const char *build)
+{
+    const char *p, *end, *option, *libtool;
+    const char *valgrind = NULL;
+    unsigned int use_libtool = 0;
+    unsigned int use_valgrind = 0;
+    size_t len, i;
+
+    /* Determine the name of the test. */
+    p = skip_non_whitespace(line);
+    ts->file = xstrndup(line, p - line);
+
+    /* Check if any test options are set. */
+    p = skip_whitespace(p);
+    while (*p != '\0') {
+        end = skip_non_whitespace(p);
+        if (strncmp(p, "libtool", end - p) == 0) {
+            use_libtool = 1;
+        } else if (strncmp(p, "valgrind", end - p) == 0) {
+            valgrind = getenv("C_TAP_VALGRIND");
+            use_valgrind = (valgrind != NULL);
+        } else {
+            option = xstrndup(p, end - p);
+            die("unknown test list option %s", option);
+        }
+        p = skip_whitespace(end);
+    }
+
+    /* Construct the argv to run the test.  First, find the length. */
+    len = 1;
+    if (use_valgrind && valgrind != NULL) {
+        p = skip_whitespace(valgrind);
+        while (*p != '\0') {
+            len++;
+            p = skip_whitespace(skip_non_whitespace(p));
+        }
+        if (use_libtool)
+            len += 2;
+    }
+
+    /* Now, build the command. */
+    ts->command = xcalloc(len + 1, char *);
+    i = 0;
+    if (use_valgrind && valgrind != NULL) {
+        if (use_libtool) {
+            libtool = getenv("C_TAP_LIBTOOL");
+            if (libtool == NULL)
+                die("valgrind with libtool requested, but C_TAP_LIBTOOL is not"
+                    " set");
+            ts->command[i++] = xstrdup(libtool);
+            ts->command[i++] = xstrdup("--mode=execute");
+        }
+        p = skip_whitespace(valgrind);
+        while (*p != '\0') {
+            end = skip_non_whitespace(p);
+            ts->command[i++] = xstrndup(p, end - p);
+            p = skip_whitespace(end);
+        }
+    }
+    if (i != len - 1)
+        die("internal error while constructing command line");
+    ts->command[i++] = find_test(ts->file, source, build);
+    ts->command[i] = NULL;
+}
+
+
+/*
+ * Read a list of tests from a file, returning the list of tests as a struct
+ * testlist, or NULL if there were no tests (such as a file containing only
+ * comments).  Reports an error to standard error and exits if the list of
+ * tests cannot be read.
+ */
+static struct testlist *
+read_test_list(const char *filename, const char *source, const char *build)
+{
+    FILE *file;
+    unsigned int line;
+    size_t length;
+    char buffer[BUFSIZ];
+    const char *start;
+    struct testlist *listhead, *current;
+
+    /* Create the initial container list that will hold our results. */
+    listhead = xcalloc(1, struct testlist);
+    current = NULL;
+
+    /*
+     * Open our file of tests to run and read it line by line, creating a new
+     * struct testlist and struct testset for each line.
+     */
+    file = fopen(filename, "r");
+    if (file == NULL)
+        sysdie("can't open %s", filename);
+    line = 0;
+    while (fgets(buffer, sizeof(buffer), file)) {
+        line++;
+        length = strlen(buffer) - 1;
+        if (buffer[length] != '\n') {
+            fprintf(stderr, "%s:%u: line too long\n", filename, line);
+            exit(1);
+        }
+        buffer[length] = '\0';
+
+        /* Skip comments, leading spaces, and blank lines. */
+        start = skip_whitespace(buffer);
+        if (strlen(start) == 0)
             continue;
-        path = xmalloc(strlen(bases[i]) + strlen(name) + 4);
-        sprintf(path, "%s/%s-t", bases[i], name);
-        if (access(path, X_OK) != 0)
-            path[strlen(path) - 2] = '.';
-        if (access(path, X_OK) == 0)
-            break;
-        free(path);
-        path = NULL;
+        if (start[0] == '#')
+            continue;
+
+        /* Allocate the new testset structure. */
+        if (current == NULL)
+            current = listhead;
+        else {
+            current->next = xcalloc(1, struct testlist);
+            current = current->next;
+        }
+        current->ts = xcalloc(1, struct testset);
+        current->ts->plan = PLAN_INIT;
+
+        /* Parse the line and store the results in the testset struct. */
+        parse_test_list_line(start, current->ts, source, build);
     }
-    if (path == NULL) {
-        path = xmalloc(strlen(name) + 3);
-        sprintf(path, "%s-t", name);
+    fclose(file);
+
+    /* If there were no tests, current is still NULL. */
+    if (current == NULL) {
+        free(listhead);
+        return NULL;
     }
-    ts->path = path;
+
+    /* Return the results. */
+    return listhead;
 }
 
 
 /*
- * Run a batch of tests from a given file listing each test on a line by
- * itself.  Takes two additional parameters: the root of the source directory
- * and the root of the build directory.  Test programs will be first searched
- * for in the current directory, then the build directory, then the source
- * directory.  The file must be rewindable.  Returns true iff all tests
- * passed.
+ * Build a list of tests from command line arguments.  Takes the argv and argc
+ * representing the command line arguments and returns a newly allocated test
+ * list, or NULL if there were no tests.  The caller is responsible for
+ * freeing.
+ */
+static struct testlist *
+build_test_list(char *argv[], int argc, const char *source, const char *build)
+{
+    int i;
+    struct testlist *listhead, *current;
+
+    /* Create the initial container list that will hold our results. */
+    listhead = xcalloc(1, struct testlist);
+    current = NULL;
+
+    /* Walk the list of arguments and create test sets for them. */
+    for (i = 0; i < argc; i++) {
+        if (current == NULL)
+            current = listhead;
+        else {
+            current->next = xcalloc(1, struct testlist);
+            current = current->next;
+        }
+        current->ts = xcalloc(1, struct testset);
+        current->ts->plan = PLAN_INIT;
+        current->ts->file = xstrdup(argv[i]);
+        current->ts->command = xcalloc(2, char *);
+        current->ts->command[0] = find_test(current->ts->file, source, build);
+        current->ts->command[1] = NULL;
+    }
+
+    /* If there were no tests, current is still NULL. */
+    if (current == NULL) {
+        free(listhead);
+        return NULL;
+    }
+
+    /* Return the results. */
+    return listhead;
+}
+
+
+/* Free a struct testset. */
+static void
+free_testset(struct testset *ts)
+{
+    size_t i;
+
+    free(ts->file);
+    for (i = 0; ts->command[i] != NULL; i++)
+        free(ts->command[i]);
+    free(ts->command);
+    free(ts->results);
+    free(ts->reason);
+    free(ts);
+}
+
+
+/*
+ * Run a batch of tests.  Takes two additional parameters: the root of the
+ * source directory and the root of the build directory.  Test programs will
+ * be first searched for in the current directory, then the build directory,
+ * then the source directory.  Returns true iff all tests passed, and always
+ * frees the test list that's passed in.
  */
 static int
-test_batch(const char *testlist, const char *source, const char *build)
+test_batch(struct testlist *tests, enum test_verbose verbose)
 {
-    FILE *tests;
-    unsigned int length, i;
-    unsigned int longest = 0;
-    char buffer[BUFSIZ];
-    unsigned int line;
-    struct testset ts, *tmp;
+    size_t length, i;
+    size_t longest = 0;
+    unsigned int count = 0;
+    struct testset *ts;
     struct timeval start, end;
     struct rusage stats;
     struct testlist *failhead = NULL;
     struct testlist *failtail = NULL;
-    struct testlist *next;
+    struct testlist *current, *next;
+    int succeeded;
     unsigned long total = 0;
     unsigned long passed = 0;
     unsigned long skipped = 0;
     unsigned long failed = 0;
     unsigned long aborted = 0;
 
-    /*
-     * Open our file of tests to run and scan it, checking for lines that
-     * are too long and searching for the longest line.
-     */
-    tests = fopen(testlist, "r");
-    if (!tests)
-        sysdie("can't open %s", testlist);
-    line = 0;
-    while (fgets(buffer, sizeof(buffer), tests)) {
-        line++;
-        length = strlen(buffer) - 1;
-        if (buffer[length] != '\n') {
-            fprintf(stderr, "%s:%u: line too long\n", testlist, line);
-            exit(1);
-        }
+    /* Walk the list of tests to find the longest name. */
+    for (current = tests; current != NULL; current = current->next) {
+        length = strlen(current->ts->file);
         if (length > longest)
             longest = length;
     }
-    if (fseek(tests, 0, SEEK_SET) == -1)
-        sysdie("can't rewind %s", testlist);
 
     /*
      * Add two to longest and round up to the nearest tab stop.  This is how
@@ -998,64 +1544,54 @@ test_batch(const char *testlist, const char *source, const char *build)
     /* Start the wall clock timer. */
     gettimeofday(&start, NULL);
 
-    /*
-     * Now, plow through our tests again, running each one.  Check line
-     * length again out of paranoia.
-     */
-    line = 0;
-    while (fgets(buffer, sizeof(buffer), tests)) {
-        line++;
-        length = strlen(buffer) - 1;
-        if (buffer[length] != '\n') {
-            fprintf(stderr, "%s:%u: line too long\n", testlist, line);
-            exit(1);
-        }
-        buffer[length] = '\0';
-        fputs(buffer, stdout);
-        for (i = length; i < longest; i++)
-            putchar('.');
+    /* Now, plow through our tests again, running each one. */
+    for (current = tests; current != NULL; current = current->next) {
+        ts = current->ts;
+
+        /* Print out the name of the test file. */
+        fputs(ts->file, stdout);
+        if (verbose)
+            fputs("\n\n", stdout);
+        else
+            for (i = strlen(ts->file); i < longest; i++)
+                putchar('.');
         if (isatty(STDOUT_FILENO))
             fflush(stdout);
-        memset(&ts, 0, sizeof(ts));
-        ts.plan = PLAN_INIT;
-        ts.file = xstrdup(buffer);
-        find_test(buffer, &ts, source, build);
-        ts.reason = NULL;
-        if (test_run(&ts)) {
-            free(ts.file);
-            free(ts.path);
-            free(ts.results);
-            if (ts.reason != NULL)
-                free(ts.reason);
-        } else {
-            tmp = xmalloc(sizeof(struct testset));
-            memcpy(tmp, &ts, sizeof(struct testset));
-            if (!failhead) {
-                failhead = xmalloc(sizeof(struct testset));
-                failhead->ts = tmp;
-                failhead->next = NULL;
+
+        /* Run the test. */
+        succeeded = test_run(ts, verbose);
+        fflush(stdout);
+        if (verbose)
+            putchar('\n');
+
+        /* Record cumulative statistics. */
+        aborted += ts->aborted;
+        total += ts->count + ts->all_skipped;
+        passed += ts->passed;
+        skipped += ts->skipped + ts->all_skipped;
+        failed += ts->failed;
+        count++;
+
+        /* If the test fails, we shuffle it over to the fail list. */
+        if (!succeeded) {
+            if (failhead == NULL) {
+                failhead = xcalloc(1, struct testlist);
                 failtail = failhead;
             } else {
-                failtail->next = xmalloc(sizeof(struct testset));
+                failtail->next = xcalloc(1, struct testlist);
                 failtail = failtail->next;
-                failtail->ts = tmp;
-                failtail->next = NULL;
             }
+            failtail->ts = ts;
+            failtail->next = NULL;
         }
-        aborted += ts.aborted;
-        total += ts.count + ts.all_skipped;
-        passed += ts.passed;
-        skipped += ts.skipped + ts.all_skipped;
-        failed += ts.failed;
     }
     total -= skipped;
-    fclose(tests);
 
     /* Stop the timer and get our child resource statistics. */
     gettimeofday(&end, NULL);
     getrusage(RUSAGE_CHILDREN, &stats);
 
-    /* Print out our final results. */
+    /* Summarize the failures and free the failure list. */
     if (failhead != NULL) {
         test_fail_summary(failhead);
         while (failhead != NULL) {
@@ -1064,6 +1600,16 @@ test_batch(const char *testlist, const char *source, const char *build)
             failhead = next;
         }
     }
+
+    /* Free the memory used by the test lists. */
+    while (tests != NULL) {
+        next = tests->next;
+        free_testset(tests->ts);
+        free(tests);
+        tests = next;
+    }
+
+    /* Print out the final test summary. */
     putchar('\n');
     if (aborted != 0) {
         if (aborted == 1)
@@ -1071,12 +1617,11 @@ test_batch(const char *testlist, const char *source, const char *build)
         else
             printf("Aborted %lu test sets", aborted);
         printf(", passed %lu/%lu tests", passed, total);
-    }
-    else if (failed == 0)
+    } else if (failed == 0)
         fputs("All tests successful", stdout);
     else
         printf("Failed %lu/%lu tests, %.2f%% okay", failed, total,
-               (total - failed) * 100.0 / total);
+               (double) (total - failed) * 100.0 / (double) total);
     if (skipped != 0) {
         if (skipped == 1)
             printf(", %lu test skipped", skipped);
@@ -1084,10 +1629,10 @@ test_batch(const char *testlist, const char *source, const char *build)
             printf(", %lu tests skipped", skipped);
     }
     puts(".");
-    printf("Files=%u,  Tests=%lu", line, total);
+    printf("Files=%u,  Tests=%lu", count, total);
     printf(",  %.2f seconds", tv_diff(&end, &start));
-    printf(" (%.2f usr + %.2f sys = %.2f CPU)\n",
-           tv_seconds(&stats.ru_utime), tv_seconds(&stats.ru_stime),
+    printf(" (%.2f usr + %.2f sys = %.2f CPU)\n", tv_seconds(&stats.ru_utime),
+           tv_seconds(&stats.ru_stime),
            tv_sum(&stats.ru_utime, &stats.ru_stime));
     return (failed == 0 && aborted == 0);
 }
@@ -1100,18 +1645,18 @@ test_batch(const char *testlist, const char *source, const char *build)
 static void
 test_single(const char *program, const char *source, const char *build)
 {
-    struct testset ts;
+    char *path;
 
-    memset(&ts, 0, sizeof(ts));
-    find_test(program, &ts, source, build);
-    if (execl(ts.path, ts.path, (char *) 0) == -1)
-        sysdie("cannot exec %s", ts.path);
+    path = find_test(program, source, build);
+    if (execl(path, path, (char *) 0) == -1)
+        sysdie("cannot exec %s", path);
 }
 
 
 /*
- * Main routine.  Set the SOURCE and BUILD environment variables and then,
- * given a file listing tests, run each test listed.
+ * Main routine.  Set the C_TAP_SOURCE, C_TAP_BUILD, SOURCE, and BUILD
+ * environment variables and then, given a file listing tests, run each test
+ * listed.
  */
 int
 main(int argc, char *argv[])
@@ -1119,20 +1664,29 @@ main(int argc, char *argv[])
     int option;
     int status = 0;
     int single = 0;
+    enum test_verbose verbose = CONCISE;
+    char *c_tap_source_env = NULL;
+    char *c_tap_build_env = NULL;
     char *source_env = NULL;
     char *build_env = NULL;
-    const char *list;
-    const char *source = SOURCE;
-    const char *build = BUILD;
-
-    while ((option = getopt(argc, argv, "b:hos:")) != EOF) {
+    const char *program;
+    const char *shortlist;
+    const char *list = NULL;
+    const char *source = C_TAP_SOURCE;
+    const char *build = C_TAP_BUILD;
+    struct testlist *tests;
+
+    program = argv[0];
+    while ((option = getopt(argc, argv, "b:hl:os:v")) != EOF) {
         switch (option) {
         case 'b':
             build = optarg;
             break;
         case 'h':
-            printf(usage_message, argv[0], argv[0]);
+            printf(usage_message, program, program, program, usage_extra);
             exit(0);
+        case 'l':
+            list = optarg;
             break;
         case 'o':
             single = 1;
@@ -1140,49 +1694,77 @@ main(int argc, char *argv[])
         case 's':
             source = optarg;
             break;
+        case 'v':
+            verbose = VERBOSE;
+            break;
         default:
             exit(1);
         }
     }
-    if (argc - optind != 1) {
-        fprintf(stderr, usage_message, argv[0], argv[0]);
+    argv += optind;
+    argc -= optind;
+    if ((list == NULL && argc < 1) || (list != NULL && argc > 0)) {
+        fprintf(stderr, usage_message, program, program, program, usage_extra);
         exit(1);
     }
-    argc -= optind;
-    argv += optind;
 
+    /*
+     * If C_TAP_VERBOSE is set in the environment, that also turns on verbose
+     * mode.
+     */
+    if (getenv("C_TAP_VERBOSE") != NULL)
+        verbose = VERBOSE;
+
+    /*
+     * Set C_TAP_SOURCE and C_TAP_BUILD environment variables.  Also set
+     * SOURCE and BUILD for backward compatibility, although we're trying to
+     * migrate to the ones with a C_TAP_* prefix.
+     */
     if (source != NULL) {
-        source_env = xmalloc(strlen("SOURCE=") + strlen(source) + 1);
-        sprintf(source_env, "SOURCE=%s", source);
+        c_tap_source_env = concat("C_TAP_SOURCE=", source, (const char *) 0);
+        if (putenv(c_tap_source_env) != 0)
+            sysdie("cannot set C_TAP_SOURCE in the environment");
+        source_env = concat("SOURCE=", source, (const char *) 0);
         if (putenv(source_env) != 0)
             sysdie("cannot set SOURCE in the environment");
     }
     if (build != NULL) {
-        build_env = xmalloc(strlen("BUILD=") + strlen(build) + 1);
-        sprintf(build_env, "BUILD=%s", build);
+        c_tap_build_env = concat("C_TAP_BUILD=", build, (const char *) 0);
+        if (putenv(c_tap_build_env) != 0)
+            sysdie("cannot set C_TAP_BUILD in the environment");
+        build_env = concat("BUILD=", build, (const char *) 0);
         if (putenv(build_env) != 0)
             sysdie("cannot set BUILD in the environment");
     }
 
+    /* Run the tests as instructed. */
     if (single)
         test_single(argv[0], source, build);
-    else {
-        list = strrchr(argv[0], '/');
-        if (list == NULL)
-            list = argv[0];
+    else if (list != NULL) {
+        shortlist = strrchr(list, '/');
+        if (shortlist == NULL)
+            shortlist = list;
         else
-            list++;
-        printf(banner, list);
-        status = test_batch(argv[0], source, build) ? 0 : 1;
+            shortlist++;
+        printf(banner, shortlist);
+        tests = read_test_list(list, source, build);
+        status = test_batch(tests, verbose) ? 0 : 1;
+    } else {
+        tests = build_test_list(argv, argc, source, build);
+        status = test_batch(tests, verbose) ? 0 : 1;
     }
 
-    /* For valgrind cleanliness. */
+    /* For valgrind cleanliness, free all our memory. */
     if (source_env != NULL) {
+        putenv((char *) "C_TAP_SOURCE=");
         putenv((char *) "SOURCE=");
+        free(c_tap_source_env);
         free(source_env);
     }
     if (build_env != NULL) {
+        putenv((char *) "C_TAP_BUILD=");
         putenv((char *) "BUILD=");
+        free(c_tap_build_env);
         free(build_env);
     }
     exit(status);
diff --git a/src/external/c-tap-harness/tests/tap/basic.c b/src/external/c-tap-harness/tests/tap/basic.c
index e8196fc87..b5f42d021 100644
--- a/src/external/c-tap-harness/tests/tap/basic.c
+++ b/src/external/c-tap-harness/tests/tap/basic.c
@@ -10,10 +10,11 @@
  * up the TAP output format, or finding things in the test environment.
  *
  * This file is part of C TAP Harness.  The current version plus supporting
- * documentation is at <http://www.eyrie.org/~eagle/software/c-tap-harness/>.
+ * documentation is at <https://www.eyrie.org/~eagle/software/c-tap-harness/>.
  *
- * Copyright 2009, 2010, 2011, 2012 Russ Allbery <rra@stanford.edu>
- * Copyright 2001, 2002, 2004, 2005, 2006, 2007, 2008, 2011, 2012
+ * Written by Russ Allbery <eagle@eyrie.org>
+ * Copyright 2009-2019 Russ Allbery <eagle@eyrie.org>
+ * Copyright 2001-2002, 2004-2008, 2011-2014
  *     The Board of Trustees of the Leland Stanford Junior University
  *
  * Permission is hereby granted, free of charge, to any person obtaining a
@@ -33,17 +34,20 @@
  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
  * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
  * DEALINGS IN THE SOFTWARE.
+ *
+ * SPDX-License-Identifier: MIT
  */
 
 #include <errno.h>
+#include <limits.h>
 #include <stdarg.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 #ifdef _WIN32
-# include <direct.h>
+#    include <direct.h>
 #else
-# include <sys/stat.h>
+#    include <sys/stat.h>
 #endif
 #include <sys/types.h>
 #include <unistd.h>
@@ -52,13 +56,13 @@
 
 /* Windows provides mkdir and rmdir under different names. */
 #ifdef _WIN32
-# define mkdir(p, m) _mkdir(p)
-# define rmdir(p)    _rmdir(p)
+#    define mkdir(p, m) _mkdir(p)
+#    define rmdir(p)    _rmdir(p)
 #endif
 
 /*
  * The test count.  Always contains the number that will be used for the next
- * test status.
+ * test status.  This is exported to callers of the library.
  */
 unsigned long testnum = 1;
 
@@ -66,72 +70,324 @@ unsigned long testnum = 1;
  * Status information stored so that we can give a test summary at the end of
  * the test case.  We store the planned final test and the count of failures.
  * We can get the highest test count from testnum.
- *
- * We also store the PID of the process that called plan() and only summarize
+ */
+static unsigned long _planned = 0;
+static unsigned long _failed = 0;
+
+/*
+ * Store the PID of the process that called plan() and only summarize
  * results when that process exits, so as to not misreport results in forked
  * processes.
- *
- * If _lazy is true, we're doing lazy planning and will print out the plan
- * based on the last test number at the end of testing.
  */
-static unsigned long _planned = 0;
-static unsigned long _failed  = 0;
 static pid_t _process = 0;
+
+/*
+ * If true, we're doing lazy planning and will print out the plan based on the
+ * last test number at the end of testing.
+ */
 static int _lazy = 0;
 
+/*
+ * If true, the test was aborted by calling bail().  Currently, this is only
+ * used to ensure that we pass a false value to any cleanup functions even if
+ * all tests to that point have passed.
+ */
+static int _aborted = 0;
+
+/*
+ * Registered cleanup functions.  These are stored as a linked list and run in
+ * registered order by finish when the test program exits.  Each function is
+ * passed a boolean value indicating whether all tests were successful.
+ */
+struct cleanup_func {
+    test_cleanup_func func;
+    test_cleanup_func_with_data func_with_data;
+    void *data;
+    struct cleanup_func *next;
+};
+static struct cleanup_func *cleanup_funcs = NULL;
+
+/*
+ * Registered diag files.  Any output found in these files will be printed out
+ * as if it were passed to diag() before any other output we do.  This allows
+ * background processes to log to a file and have that output interleaved with
+ * the test output.
+ */
+struct diag_file {
+    char *name;
+    FILE *file;
+    char *buffer;
+    size_t bufsize;
+    struct diag_file *next;
+};
+static struct diag_file *diag_files = NULL;
+
+/*
+ * Print a specified prefix and then the test description.  Handles turning
+ * the argument list into a va_args structure suitable for passing to
+ * print_desc, which has to be done in a macro.  Assumes that format is the
+ * argument immediately before the variadic arguments.
+ */
+#define PRINT_DESC(prefix, format)  \
+    do {                            \
+        if (format != NULL) {       \
+            va_list args;           \
+            printf("%s", prefix);   \
+            va_start(args, format); \
+            vprintf(format, args);  \
+            va_end(args);           \
+        }                           \
+    } while (0)
+
+
+/*
+ * Form a new string by concatenating multiple strings.  The arguments must be
+ * terminated by (const char *) 0.
+ *
+ * This function only exists because we can't assume asprintf.  We can't
+ * simulate asprintf with snprintf because we're only assuming SUSv3, which
+ * does not require that snprintf with a NULL buffer return the required
+ * length.  When those constraints are relaxed, this should be ripped out and
+ * replaced with asprintf or a more trivial replacement with snprintf.
+ */
+static char *
+concat(const char *first, ...)
+{
+    va_list args;
+    char *result;
+    const char *string;
+    size_t offset;
+    size_t length = 0;
+
+    /*
+     * Find the total memory required.  Ensure we don't overflow length.  See
+     * the comment for breallocarray for why we're using UINT_MAX here.
+     */
+    va_start(args, first);
+    for (string = first; string != NULL; string = va_arg(args, const char *)) {
+        if (length >= UINT_MAX - strlen(string))
+            bail("strings too long in concat");
+        length += strlen(string);
+    }
+    va_end(args);
+    length++;
+
+    /* Create the string. */
+    result = bcalloc_type(length, char);
+    va_start(args, first);
+    offset = 0;
+    for (string = first; string != NULL; string = va_arg(args, const char *)) {
+        memcpy(result + offset, string, strlen(string));
+        offset += strlen(string);
+    }
+    va_end(args);
+    result[offset] = '\0';
+    return result;
+}
+
+
+/*
+ * Helper function for check_diag_files to handle a single line in a diag
+ * file.
+ *
+ * The general scheme here used is as follows: read one line of output.  If we
+ * get NULL, check for an error.  If there was one, bail out of the test
+ * program; otherwise, return, and the enclosing loop will check for EOF.
+ *
+ * If we get some data, see if it ends in a newline.  If it doesn't end in a
+ * newline, we have one of two cases: our buffer isn't large enough, in which
+ * case we resize it and try again, or we have incomplete data in the file, in
+ * which case we rewind the file and will try again next time.
+ *
+ * Returns a boolean indicating whether the last line was incomplete.
+ */
+static int
+handle_diag_file_line(struct diag_file *file, fpos_t where)
+{
+    int size;
+    size_t length;
+
+    /* Read the next line from the file. */
+    size = file->bufsize > INT_MAX ? INT_MAX : (int) file->bufsize;
+    if (fgets(file->buffer, size, file->file) == NULL) {
+        if (ferror(file->file))
+            sysbail("cannot read from %s", file->name);
+        return 0;
+    }
+
+    /*
+     * See if the line ends in a newline.  If not, see which error case we
+     * have.
+     */
+    length = strlen(file->buffer);
+    if (file->buffer[length - 1] != '\n') {
+        int incomplete = 0;
+
+        /* Check whether we ran out of buffer space and resize if so. */
+        if (length < file->bufsize - 1)
+            incomplete = 1;
+        else {
+            file->bufsize += BUFSIZ;
+            file->buffer =
+                breallocarray_type(file->buffer, file->bufsize, char);
+        }
+
+        /*
+         * On either incomplete lines or too small of a buffer, rewind
+         * and read the file again (on the next pass, if incomplete).
+         * It's simpler than trying to double-buffer the file.
+         */
+        if (fsetpos(file->file, &where) < 0)
+            sysbail("cannot set position in %s", file->name);
+        return incomplete;
+    }
+
+    /* We saw a complete line.  Print it out. */
+    printf("# %s", file->buffer);
+    return 0;
+}
+
+
+/*
+ * Check all registered diag_files for any output.  We only print out the
+ * output if we see a complete line; otherwise, we wait for the next newline.
+ */
+static void
+check_diag_files(void)
+{
+    struct diag_file *file;
+    fpos_t where;
+    int incomplete;
+
+    /*
+     * Walk through each file and read each line of output available.
+     */
+    for (file = diag_files; file != NULL; file = file->next) {
+        clearerr(file->file);
+
+        /* Store the current position in case we have to rewind. */
+        if (fgetpos(file->file, &where) < 0)
+            sysbail("cannot get position in %s", file->name);
+
+        /* Continue until we get EOF or an incomplete line of data. */
+        incomplete = 0;
+        while (!feof(file->file) && !incomplete) {
+            incomplete = handle_diag_file_line(file, where);
+        }
+    }
+}
+
 
 /*
  * Our exit handler.  Called on completion of the test to report a summary of
  * results provided we're still in the original process.  This also handles
  * printing out the plan if we used plan_lazy(), although that's suppressed if
- * we never ran a test (due to an early bail, for example).
+ * we never ran a test (due to an early bail, for example), and running any
+ * registered cleanup functions.
  */
 static void
 finish(void)
 {
+    int success, primary;
+    struct cleanup_func *current;
     unsigned long highest = testnum - 1;
+    struct diag_file *file, *tmp;
+
+    /* Check for pending diag_file output. */
+    check_diag_files();
+
+    /* Free the diag_files. */
+    file = diag_files;
+    while (file != NULL) {
+        tmp = file;
+        file = file->next;
+        fclose(tmp->file);
+        free(tmp->name);
+        free(tmp->buffer);
+        free(tmp);
+    }
+    diag_files = NULL;
+
+    /*
+     * Determine whether all tests were successful, which is needed before
+     * calling cleanup functions since we pass that fact to the functions.
+     */
+    if (_planned == 0 && _lazy)
+        _planned = highest;
+    success = (!_aborted && _planned == highest && _failed == 0);
+
+    /*
+     * If there are any registered cleanup functions, we run those first.  We
+     * always run them, even if we didn't run a test.  Don't do anything
+     * except free the diag_files and call cleanup functions if we aren't the
+     * primary process (the process in which plan or plan_lazy was called),
+     * and tell the cleanup functions that fact.
+     */
+    primary = (_process == 0 || getpid() == _process);
+    while (cleanup_funcs != NULL) {
+        if (cleanup_funcs->func_with_data) {
+            void *data = cleanup_funcs->data;
+
+            cleanup_funcs->func_with_data(success, primary, data);
+        } else {
+            cleanup_funcs->func(success, primary);
+        }
+        current = cleanup_funcs;
+        cleanup_funcs = cleanup_funcs->next;
+        free(current);
+    }
+    if (!primary)
+        return;
+
+    /* Don't do anything further if we never planned a test. */
+    if (_planned == 0)
+        return;
 
-    if (_planned == 0 && !_lazy)
+    /* If we're aborting due to bail, don't print summaries. */
+    if (_aborted)
         return;
+
+    /* Print out the lazy plan if needed. */
     fflush(stderr);
-    if (_process != 0 && getpid() == _process) {
-        if (_lazy && highest > 0) {
-            printf("1..%lu\n", highest);
-            _planned = highest;
-        }
-        if (_planned > highest)
-            printf("# Looks like you planned %lu test%s but only ran %lu\n",
-                   _planned, (_planned > 1 ? "s" : ""), highest);
-        else if (_planned < highest)
-            printf("# Looks like you planned %lu test%s but ran %lu extra\n",
-                   _planned, (_planned > 1 ? "s" : ""), highest - _planned);
-        else if (_failed > 0)
-            printf("# Looks like you failed %lu test%s of %lu\n", _failed,
-                   (_failed > 1 ? "s" : ""), _planned);
-        else if (_planned > 1)
-            printf("# All %lu tests successful or skipped\n", _planned);
-        else
-            printf("# %lu test successful or skipped\n", _planned);
-    }
+    if (_lazy && _planned > 0)
+        printf("1..%lu\n", _planned);
+
+    /* Print out a summary of the results. */
+    if (_planned > highest)
+        diag("Looks like you planned %lu test%s but only ran %lu", _planned,
+             (_planned > 1 ? "s" : ""), highest);
+    else if (_planned < highest)
+        diag("Looks like you planned %lu test%s but ran %lu extra", _planned,
+             (_planned > 1 ? "s" : ""), highest - _planned);
+    else if (_failed > 0)
+        diag("Looks like you failed %lu test%s of %lu", _failed,
+             (_failed > 1 ? "s" : ""), _planned);
+    else if (_planned != 1)
+        diag("All %lu tests successful or skipped", _planned);
+    else
+        diag("%lu test successful or skipped", _planned);
 }
 
 
 /*
  * Initialize things.  Turns on line buffering on stdout and then prints out
- * the number of tests in the test suite.
+ * the number of tests in the test suite.  We intentionally don't check for
+ * pending diag_file output here, since it should really come after the plan.
  */
 void
 plan(unsigned long count)
 {
     if (setvbuf(stdout, NULL, _IOLBF, BUFSIZ) != 0)
-        fprintf(stderr, "# cannot set stdout to line buffered: %s\n",
-                strerror(errno));
+        sysdiag("cannot set stdout to line buffered");
     fflush(stderr);
     printf("1..%lu\n", count);
     testnum = 1;
     _planned = count;
     _process = getpid();
-    atexit(finish);
+    if (atexit(finish) != 0) {
+        sysdiag("cannot register exit handler");
+        diag("cleanups will not be run");
+    }
 }
 
 
@@ -143,83 +399,66 @@ void
 plan_lazy(void)
 {
     if (setvbuf(stdout, NULL, _IOLBF, BUFSIZ) != 0)
-        fprintf(stderr, "# cannot set stdout to line buffered: %s\n",
-                strerror(errno));
+        sysdiag("cannot set stdout to line buffered");
     testnum = 1;
     _process = getpid();
     _lazy = 1;
-    atexit(finish);
+    if (atexit(finish) != 0)
+        sysbail("cannot register exit handler to display plan");
 }
 
 
 /*
  * Skip the entire test suite and exits.  Should be called instead of plan(),
- * not after it, since it prints out a special plan line.
+ * not after it, since it prints out a special plan line.  Ignore diag_file
+ * output here, since it's not clear if it's allowed before the plan.
  */
 void
 skip_all(const char *format, ...)
 {
     fflush(stderr);
     printf("1..0 # skip");
-    if (format != NULL) {
-        va_list args;
-
-        putchar(' ');
-        va_start(args, format);
-        vprintf(format, args);
-        va_end(args);
-    }
+    PRINT_DESC(" ", format);
     putchar('\n');
     exit(0);
 }
 
 
-/*
- * Print the test description.
- */
-static void
-print_desc(const char *format, va_list args)
-{
-    printf(" - ");
-    vprintf(format, args);
-}
-
-
 /*
  * Takes a boolean success value and assumes the test passes if that value
  * is true and fails if that value is false.
  */
-void
+int
 ok(int success, const char *format, ...)
 {
     fflush(stderr);
+    check_diag_files();
     printf("%sok %lu", success ? "" : "not ", testnum++);
     if (!success)
         _failed++;
-    if (format != NULL) {
-        va_list args;
-
-        va_start(args, format);
-        print_desc(format, args);
-        va_end(args);
-    }
+    PRINT_DESC(" - ", format);
     putchar('\n');
+    return success;
 }
 
 
 /*
  * Same as ok(), but takes the format arguments as a va_list.
  */
-void
+int
 okv(int success, const char *format, va_list args)
 {
     fflush(stderr);
+    check_diag_files();
     printf("%sok %lu", success ? "" : "not ", testnum++);
     if (!success)
         _failed++;
-    if (format != NULL)
-        print_desc(format, args);
+    if (format != NULL) {
+        printf(" - ");
+        vprintf(format, args);
+    }
     putchar('\n');
+    return success;
 }
 
 
@@ -230,15 +469,9 @@ void
 skip(const char *reason, ...)
 {
     fflush(stderr);
+    check_diag_files();
     printf("ok %lu # skip", testnum++);
-    if (reason != NULL) {
-        va_list args;
-
-        va_start(args, reason);
-        putchar(' ');
-        vprintf(reason, args);
-        va_end(args);
-    }
+    PRINT_DESC(" ", reason);
     putchar('\n');
 }
 
@@ -246,25 +479,21 @@ skip(const char *reason, ...)
 /*
  * Report the same status on the next count tests.
  */
-void
-ok_block(unsigned long count, int status, const char *format, ...)
+int
+ok_block(unsigned long count, int success, const char *format, ...)
 {
     unsigned long i;
 
     fflush(stderr);
+    check_diag_files();
     for (i = 0; i < count; i++) {
-        printf("%sok %lu", status ? "" : "not ", testnum++);
-        if (!status)
+        printf("%sok %lu", success ? "" : "not ", testnum++);
+        if (!success)
             _failed++;
-        if (format != NULL) {
-            va_list args;
-
-            va_start(args, format);
-            print_desc(format, args);
-            va_end(args);
-        }
+        PRINT_DESC(" - ", format);
         putchar('\n');
     }
+    return success;
 }
 
 
@@ -277,101 +506,157 @@ skip_block(unsigned long count, const char *reason, ...)
     unsigned long i;
 
     fflush(stderr);
+    check_diag_files();
     for (i = 0; i < count; i++) {
         printf("ok %lu # skip", testnum++);
-        if (reason != NULL) {
-            va_list args;
-
-            va_start(args, reason);
-            putchar(' ');
-            vprintf(reason, args);
-            va_end(args);
-        }
+        PRINT_DESC(" ", reason);
         putchar('\n');
     }
 }
 
 
 /*
- * Takes an expected integer and a seen integer and assumes the test passes
- * if those two numbers match.
+ * Takes two boolean values and requires the truth value of both match.
  */
-void
-is_int(long wanted, long seen, const char *format, ...)
+int
+is_bool(int left, int right, const char *format, ...)
 {
+    int success;
+
     fflush(stderr);
-    if (wanted == seen)
+    check_diag_files();
+    success = (!!left == !!right);
+    if (success)
         printf("ok %lu", testnum++);
     else {
-        printf("# wanted: %ld\n#   seen: %ld\n", wanted, seen);
+        diag(" left: %s", !!left ? "true" : "false");
+        diag("right: %s", !!right ? "true" : "false");
         printf("not ok %lu", testnum++);
         _failed++;
     }
-    if (format != NULL) {
-        va_list args;
-
-        va_start(args, format);
-        print_desc(format, args);
-        va_end(args);
-    }
+    PRINT_DESC(" - ", format);
     putchar('\n');
+    return success;
 }
 
 
 /*
- * Takes a string and what the string should be, and assumes the test passes
- * if those strings match (using strcmp).
+ * Takes two integer values and requires they match.
  */
-void
-is_string(const char *wanted, const char *seen, const char *format, ...)
+int
+is_int(long left, long right, const char *format, ...)
 {
-    if (wanted == NULL)
-        wanted = "(null)";
-    if (seen == NULL)
-        seen = "(null)";
+    int success;
+
     fflush(stderr);
-    if (strcmp(wanted, seen) == 0)
+    check_diag_files();
+    success = (left == right);
+    if (success)
         printf("ok %lu", testnum++);
     else {
-        printf("# wanted: %s\n#   seen: %s\n", wanted, seen);
+        diag(" left: %ld", left);
+        diag("right: %ld", right);
         printf("not ok %lu", testnum++);
         _failed++;
     }
-    if (format != NULL) {
-        va_list args;
+    PRINT_DESC(" - ", format);
+    putchar('\n');
+    return success;
+}
 
-        va_start(args, format);
-        print_desc(format, args);
-        va_end(args);
+
+/*
+ * Takes two strings and requires they match (using strcmp).  NULL arguments
+ * are permitted and handled correctly.
+ */
+int
+is_string(const char *left, const char *right, const char *format, ...)
+{
+    int success;
+
+    fflush(stderr);
+    check_diag_files();
+
+    /* Compare the strings, being careful of NULL. */
+    if (left == NULL)
+        success = (right == NULL);
+    else if (right == NULL)
+        success = 0;
+    else
+        success = (strcmp(left, right) == 0);
+
+    /* Report the results. */
+    if (success)
+        printf("ok %lu", testnum++);
+    else {
+        diag(" left: %s", left == NULL ? "(null)" : left);
+        diag("right: %s", right == NULL ? "(null)" : right);
+        printf("not ok %lu", testnum++);
+        _failed++;
     }
+    PRINT_DESC(" - ", format);
     putchar('\n');
+    return success;
 }
 
 
 /*
- * Takes an expected unsigned long and a seen unsigned long and assumes the
- * test passes if the two numbers match.  Otherwise, reports them in hex.
+ * Takes two unsigned longs and requires they match.  On failure, reports them
+ * in hex.
  */
-void
-is_hex(unsigned long wanted, unsigned long seen, const char *format, ...)
+int
+is_hex(unsigned long left, unsigned long right, const char *format, ...)
 {
+    int success;
+
     fflush(stderr);
-    if (wanted == seen)
+    check_diag_files();
+    success = (left == right);
+    if (success)
         printf("ok %lu", testnum++);
     else {
-        printf("# wanted: %lx\n#   seen: %lx\n", (unsigned long) wanted,
-               (unsigned long) seen);
+        diag(" left: %lx", (unsigned long) left);
+        diag("right: %lx", (unsigned long) right);
         printf("not ok %lu", testnum++);
         _failed++;
     }
-    if (format != NULL) {
-        va_list args;
+    PRINT_DESC(" - ", format);
+    putchar('\n');
+    return success;
+}
+
+
+/*
+ * Takes pointers to a regions of memory and requires that len bytes from each
+ * match.  Otherwise reports any bytes which didn't match.
+ */
+int
+is_blob(const void *left, const void *right, size_t len, const char *format,
+        ...)
+{
+    int success;
+    size_t i;
+
+    fflush(stderr);
+    check_diag_files();
+    success = (memcmp(left, right, len) == 0);
+    if (success)
+        printf("ok %lu", testnum++);
+    else {
+        const unsigned char *left_c = (const unsigned char *) left;
+        const unsigned char *right_c = (const unsigned char *) right;
 
-        va_start(args, format);
-        print_desc(format, args);
-        va_end(args);
+        for (i = 0; i < len; i++) {
+            if (left_c[i] != right_c[i])
+                diag("offset %lu: left %02x, right %02x", (unsigned long) i,
+                     left_c[i], right_c[i]);
+        }
+        printf("not ok %lu", testnum++);
+        _failed++;
     }
+    PRINT_DESC(" - ", format);
     putchar('\n');
+    return success;
 }
 
 
@@ -383,14 +668,16 @@ bail(const char *format, ...)
 {
     va_list args;
 
+    _aborted = 1;
     fflush(stderr);
+    check_diag_files();
     fflush(stdout);
     printf("Bail out! ");
     va_start(args, format);
     vprintf(format, args);
     va_end(args);
     printf("\n");
-    exit(1);
+    exit(255);
 }
 
 
@@ -403,51 +690,110 @@ sysbail(const char *format, ...)
     va_list args;
     int oerrno = errno;
 
+    _aborted = 1;
     fflush(stderr);
+    check_diag_files();
     fflush(stdout);
     printf("Bail out! ");
     va_start(args, format);
     vprintf(format, args);
     va_end(args);
     printf(": %s\n", strerror(oerrno));
-    exit(1);
+    exit(255);
 }
 
 
 /*
- * Report a diagnostic to stderr.
+ * Report a diagnostic to stderr.  Always returns 1 to allow embedding in
+ * compound statements.
  */
-void
+int
 diag(const char *format, ...)
 {
     va_list args;
 
     fflush(stderr);
+    check_diag_files();
     fflush(stdout);
     printf("# ");
     va_start(args, format);
     vprintf(format, args);
     va_end(args);
     printf("\n");
+    return 1;
 }
 
 
 /*
- * Report a diagnostic to stderr, appending strerror(errno).
+ * Report a diagnostic to stderr, appending strerror(errno).  Always returns 1
+ * to allow embedding in compound statements.
  */
-void
+int
 sysdiag(const char *format, ...)
 {
     va_list args;
     int oerrno = errno;
 
     fflush(stderr);
+    check_diag_files();
     fflush(stdout);
     printf("# ");
     va_start(args, format);
     vprintf(format, args);
     va_end(args);
     printf(": %s\n", strerror(oerrno));
+    return 1;
+}
+
+
+/*
+ * Register a new file for diag_file processing.
+ */
+void
+diag_file_add(const char *name)
+{
+    struct diag_file *file, *prev;
+
+    file = bcalloc_type(1, struct diag_file);
+    file->name = bstrdup(name);
+    file->file = fopen(file->name, "r");
+    if (file->file == NULL)
+        sysbail("cannot open %s", name);
+    file->buffer = bcalloc_type(BUFSIZ, char);
+    file->bufsize = BUFSIZ;
+    if (diag_files == NULL)
+        diag_files = file;
+    else {
+        for (prev = diag_files; prev->next != NULL; prev = prev->next)
+            ;
+        prev->next = file;
+    }
+}
+
+
+/*
+ * Remove a file from diag_file processing.  If the file is not found, do
+ * nothing, since there are some situations where it can be removed twice
+ * (such as if it's removed from a cleanup function, since cleanup functions
+ * are called after freeing all the diag_files).
+ */
+void
+diag_file_remove(const char *name)
+{
+    struct diag_file *file;
+    struct diag_file **prev = &diag_files;
+
+    for (file = diag_files; file != NULL; file = file->next) {
+        if (strcmp(file->name, name) == 0) {
+            *prev = file->next;
+            fclose(file->file);
+            free(file->name);
+            free(file->buffer);
+            free(file);
+            return;
+        }
+        prev = &file->next;
+    }
 }
 
 
@@ -461,7 +807,7 @@ bcalloc(size_t n, size_t size)
 
     p = calloc(n, size);
     if (p == NULL)
-        sysbail("failed to calloc %lu", (unsigned long)(n * size));
+        sysbail("failed to calloc %lu", (unsigned long) (n * size));
     return p;
 }
 
@@ -494,6 +840,34 @@ brealloc(void *p, size_t size)
 }
 
 
+/*
+ * The same as brealloc, but determine the size by multiplying an element
+ * count by a size, similar to calloc.  The multiplication is checked for
+ * integer overflow.
+ *
+ * We should technically use SIZE_MAX here for the overflow check, but
+ * SIZE_MAX is C99 and we're only assuming C89 + SUSv3, which does not
+ * guarantee that it exists.  They do guarantee that UINT_MAX exists, and we
+ * can assume that UINT_MAX <= SIZE_MAX.
+ *
+ * (In theory, C89 and C99 permit size_t to be smaller than unsigned int, but
+ * I disbelieve in the existence of such systems and they will have to cope
+ * without overflow checks.)
+ */
+void *
+breallocarray(void *p, size_t n, size_t size)
+{
+    if (n > 0 && UINT_MAX / n <= size)
+        bail("reallocarray too large");
+    if (n == 0)
+        n = 1;
+    p = realloc(p, n * size);
+    if (p == NULL)
+        sysbail("failed to realloc %lu bytes", (unsigned long) (n * size));
+    return p;
+}
+
+
 /*
  * Copy a string, reporting a fatal error with bail on failure.
  */
@@ -504,7 +878,7 @@ bstrdup(const char *s)
     size_t len;
 
     len = strlen(s) + 1;
-    p = malloc(len);
+    p = (char *) malloc(len);
     if (p == NULL)
         sysbail("failed to strdup %lu bytes", (unsigned long) len);
     memcpy(p, s, len);
@@ -525,11 +899,11 @@ bstrndup(const char *s, size_t n)
     size_t length;
 
     /* Don't assume that the source string is nul-terminated. */
-    for (p = s; (size_t) (p - s) < n && *p != '\0'; p++)
+    for (p = s; (size_t)(p - s) < n && *p != '\0'; p++)
         ;
-    length = p - s;
-    copy = malloc(length + 1);
-    if (p == NULL)
+    length = (size_t)(p - s);
+    copy = (char *) malloc(length + 1);
+    if (copy == NULL)
         sysbail("failed to strndup %lu bytes", (unsigned long) length);
     memcpy(copy, s, length);
     copy[length] = '\0';
@@ -538,31 +912,24 @@ bstrndup(const char *s, size_t n)
 
 
 /*
- * Locate a test file.  Given the partial path to a file, look under BUILD and
- * then SOURCE for the file and return the full path to the file.  Returns
- * NULL if the file doesn't exist.  A non-NULL return should be freed with
- * test_file_path_free().
- *
- * This function uses sprintf because it attempts to be independent of all
- * other portability layers.  The use immediately after a memory allocation
- * should be safe without using snprintf or strlcpy/strlcat.
+ * Locate a test file.  Given the partial path to a file, look under
+ * C_TAP_BUILD and then C_TAP_SOURCE for the file and return the full path to
+ * the file.  Returns NULL if the file doesn't exist.  A non-NULL return
+ * should be freed with test_file_path_free().
  */
 char *
 test_file_path(const char *file)
 {
     char *base;
     char *path = NULL;
-    size_t length;
-    const char *envs[] = { "BUILD", "SOURCE", NULL };
+    const char *envs[] = {"C_TAP_BUILD", "C_TAP_SOURCE", NULL};
     int i;
 
     for (i = 0; envs[i] != NULL; i++) {
         base = getenv(envs[i]);
         if (base == NULL)
             continue;
-        length = strlen(base) + 1 + strlen(file) + 1;
-        path = bmalloc(length);
-        sprintf(path, "%s/%s", base, file);
+        path = concat(base, "/", file, (const char *) 0);
         if (access(path, R_OK) == 0)
             break;
         free(path);
@@ -580,13 +947,12 @@ test_file_path(const char *file)
 void
 test_file_path_free(char *path)
 {
-    if (path != NULL)
-        free(path);
+    free(path);
 }
 
 
 /*
- * Create a temporary directory, tmp, under BUILD if set and the current
+ * Create a temporary directory, tmp, under C_TAP_BUILD if set and the current
  * directory if it does not.  Returns the path to the temporary directory in
  * newly allocated memory, and calls bail on any failure.  The return value
  * should be freed with test_tmpdir_free.
@@ -600,14 +966,11 @@ test_tmpdir(void)
 {
     const char *build;
     char *path = NULL;
-    size_t length;
 
-    build = getenv("BUILD");
+    build = getenv("C_TAP_BUILD");
     if (build == NULL)
         build = ".";
-    length = strlen(build) + strlen("/tmp") + 1;
-    path = bmalloc(length);
-    sprintf(path, "%s/tmp", build);
+    path = concat(build, "/tmp", (const char *) 0);
     if (access(path, X_OK) < 0)
         if (mkdir(path, 0777) < 0)
             sysbail("error creating temporary directory %s", path);
@@ -623,7 +986,44 @@ test_tmpdir(void)
 void
 test_tmpdir_free(char *path)
 {
-    rmdir(path);
     if (path != NULL)
-        free(path);
+        rmdir(path);
+    free(path);
+}
+
+static void
+register_cleanup(test_cleanup_func func,
+                 test_cleanup_func_with_data func_with_data, void *data)
+{
+    struct cleanup_func *cleanup, **last;
+
+    cleanup = bcalloc_type(1, struct cleanup_func);
+    cleanup->func = func;
+    cleanup->func_with_data = func_with_data;
+    cleanup->data = data;
+    cleanup->next = NULL;
+    last = &cleanup_funcs;
+    while (*last != NULL)
+        last = &(*last)->next;
+    *last = cleanup;
+}
+
+/*
+ * Register a cleanup function that is called when testing ends.  All such
+ * registered functions will be run by finish.
+ */
+void
+test_cleanup_register(test_cleanup_func func)
+{
+    register_cleanup(func, NULL, NULL);
+}
+
+/*
+ * Same as above, but also allows an opaque pointer to be passed to the cleanup
+ * function.
+ */
+void
+test_cleanup_register_with_data(test_cleanup_func_with_data func, void *data)
+{
+    register_cleanup(NULL, func, data);
 }
diff --git a/src/external/c-tap-harness/tests/tap/basic.h b/src/external/c-tap-harness/tests/tap/basic.h
index fa4adafe2..45f15f289 100644
--- a/src/external/c-tap-harness/tests/tap/basic.h
+++ b/src/external/c-tap-harness/tests/tap/basic.h
@@ -2,10 +2,11 @@
  * Basic utility routines for the TAP protocol.
  *
  * This file is part of C TAP Harness.  The current version plus supporting
- * documentation is at <http://www.eyrie.org/~eagle/software/c-tap-harness/>.
+ * documentation is at <https://www.eyrie.org/~eagle/software/c-tap-harness/>.
  *
- * Copyright 2009, 2010, 2011, 2012 Russ Allbery <rra@stanford.edu>
- * Copyright 2001, 2002, 2004, 2005, 2006, 2007, 2008, 2011, 2012
+ * Written by Russ Allbery <eagle@eyrie.org>
+ * Copyright 2009-2019 Russ Allbery <eagle@eyrie.org>
+ * Copyright 2001-2002, 2004-2008, 2011-2012, 2014
  *     The Board of Trustees of the Leland Stanford Junior University
  *
  * Permission is hereby granted, free of charge, to any person obtaining a
@@ -25,14 +26,16 @@
  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
  * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
  * DEALINGS IN THE SOFTWARE.
+ *
+ * SPDX-License-Identifier: MIT
  */
 
 #ifndef TAP_BASIC_H
 #define TAP_BASIC_H 1
 
+#include <stdarg.h> /* va_list */
+#include <stddef.h> /* size_t */
 #include <tests/tap/macros.h>
-#include <stdarg.h>             /* va_list */
-#include <sys/types.h>          /* size_t */
 
 /*
  * Used for iterating through arrays.  ARRAY_SIZE returns the number of
@@ -40,8 +43,8 @@
  * ARRAY_END returns a pointer to the element past the end (ISO C99 makes it
  * legal to refer to such a pointer as long as it's never dereferenced).
  */
-#define ARRAY_SIZE(array)       (sizeof(array) / sizeof((array)[0]))
-#define ARRAY_END(array)        (&(array)[ARRAY_SIZE(array)])
+#define ARRAY_SIZE(array) (sizeof(array) / sizeof((array)[0]))
+#define ARRAY_END(array)  (&(array)[ARRAY_SIZE(array)])
 
 BEGIN_DECLS
 
@@ -55,7 +58,7 @@ extern unsigned long testnum;
 void plan(unsigned long count);
 
 /*
- * Prepare for lazy planning, in which the plan will be  printed automatically
+ * Prepare for lazy planning, in which the plan will be printed automatically
  * at the end of the test program.
  */
 void plan_lazy(void);
@@ -67,27 +70,40 @@ void skip_all(const char *format, ...)
 /*
  * Basic reporting functions.  The okv() function is the same as ok() but
  * takes the test description as a va_list to make it easier to reuse the
- * reporting infrastructure when writing new tests.
+ * reporting infrastructure when writing new tests.  ok() and okv() return the
+ * value of the success argument.
  */
-void ok(int success, const char *format, ...)
+int ok(int success, const char *format, ...)
     __attribute__((__format__(printf, 2, 3)));
-void okv(int success, const char *format, va_list args);
-void skip(const char *reason, ...)
-    __attribute__((__format__(printf, 1, 2)));
+int okv(int success, const char *format, va_list args)
+    __attribute__((__format__(printf, 2, 0)));
+void skip(const char *reason, ...) __attribute__((__format__(printf, 1, 2)));
 
-/* Report the same status on, or skip, the next count tests. */
-void ok_block(unsigned long count, int success, const char *format, ...)
+/*
+ * Report the same status on, or skip, the next count tests.  ok_block()
+ * returns the value of the success argument.
+ */
+int ok_block(unsigned long count, int success, const char *format, ...)
     __attribute__((__format__(printf, 3, 4)));
 void skip_block(unsigned long count, const char *reason, ...)
     __attribute__((__format__(printf, 2, 3)));
 
-/* Check an expected value against a seen value. */
-void is_int(long wanted, long seen, const char *format, ...)
+/*
+ * Compare two values.  Returns true if the test passes and false if it fails.
+ * is_bool takes an int since the bool type isn't fully portable yet, but
+ * interprets both arguments for their truth value, not for their numeric
+ * value.
+ */
+int is_bool(int, int, const char *format, ...)
     __attribute__((__format__(printf, 3, 4)));
-void is_string(const char *wanted, const char *seen, const char *format, ...)
+int is_int(long, long, const char *format, ...)
     __attribute__((__format__(printf, 3, 4)));
-void is_hex(unsigned long wanted, unsigned long seen, const char *format, ...)
+int is_string(const char *, const char *, const char *format, ...)
     __attribute__((__format__(printf, 3, 4)));
+int is_hex(unsigned long, unsigned long, const char *format, ...)
+    __attribute__((__format__(printf, 3, 4)));
+int is_blob(const void *, const void *, size_t, const char *format, ...)
+    __attribute__((__format__(printf, 4, 5)));
 
 /* Bail out with an error.  sysbail appends strerror(errno). */
 void bail(const char *format, ...)
@@ -96,39 +112,81 @@ void sysbail(const char *format, ...)
     __attribute__((__noreturn__, __nonnull__, __format__(printf, 1, 2)));
 
 /* Report a diagnostic to stderr prefixed with #. */
-void diag(const char *format, ...)
+int diag(const char *format, ...)
     __attribute__((__nonnull__, __format__(printf, 1, 2)));
-void sysdiag(const char *format, ...)
+int sysdiag(const char *format, ...)
     __attribute__((__nonnull__, __format__(printf, 1, 2)));
 
+/*
+ * Register or unregister a file that contains supplementary diagnostics.
+ * Before any other output, all registered files will be read, line by line,
+ * and each line will be reported as a diagnostic as if it were passed to
+ * diag().  Nul characters are not supported in these files and will result in
+ * truncated output.
+ */
+void diag_file_add(const char *file) __attribute__((__nonnull__));
+void diag_file_remove(const char *file) __attribute__((__nonnull__));
+
 /* Allocate memory, reporting a fatal error with bail on failure. */
 void *bcalloc(size_t, size_t)
-    __attribute__((__alloc_size__(1, 2), __malloc__));
+    __attribute__((__alloc_size__(1, 2), __malloc__, __warn_unused_result__));
 void *bmalloc(size_t)
-    __attribute__((__alloc_size__(1), __malloc__));
+    __attribute__((__alloc_size__(1), __malloc__, __warn_unused_result__));
+void *breallocarray(void *, size_t, size_t)
+    __attribute__((__alloc_size__(2, 3), __malloc__, __warn_unused_result__));
 void *brealloc(void *, size_t)
-    __attribute__((__alloc_size__(2), __malloc__));
+    __attribute__((__alloc_size__(2), __malloc__, __warn_unused_result__));
 char *bstrdup(const char *)
-    __attribute__((__malloc__, __nonnull__));
+    __attribute__((__malloc__, __nonnull__, __warn_unused_result__));
 char *bstrndup(const char *, size_t)
-    __attribute__((__malloc__, __nonnull__));
+    __attribute__((__malloc__, __nonnull__, __warn_unused_result__));
 
 /*
- * Find a test file under BUILD or SOURCE, returning the full path.  The
- * returned path should be freed with test_file_path_free().
+ * Macros that cast the return value from b* memory functions, making them
+ * usable in C++ code and providing some additional type safety.
+ */
+#define bcalloc_type(n, type) ((type *) bcalloc((n), sizeof(type)))
+#define breallocarray_type(p, n, type) \
+    ((type *) breallocarray((p), (n), sizeof(type)))
+
+/*
+ * Find a test file under C_TAP_BUILD or C_TAP_SOURCE, returning the full
+ * path.  The returned path should be freed with test_file_path_free().
  */
 char *test_file_path(const char *file)
-    __attribute__((__malloc__, __nonnull__));
+    __attribute__((__malloc__, __nonnull__, __warn_unused_result__));
 void test_file_path_free(char *path);
 
 /*
- * Create a temporary directory relative to BUILD and return the path.  The
- * returned path should be freed with test_tmpdir_free.
+ * Create a temporary directory relative to C_TAP_BUILD and return the path.
+ * The returned path should be freed with test_tmpdir_free().
  */
-char *test_tmpdir(void)
-    __attribute__((__malloc__));
+char *test_tmpdir(void) __attribute__((__malloc__, __warn_unused_result__));
 void test_tmpdir_free(char *path);
 
+/*
+ * Register a cleanup function that is called when testing ends.  All such
+ * registered functions will be run during atexit handling (and are therefore
+ * subject to all the same constraints and caveats as atexit functions).
+ *
+ * The function must return void and will be passed two arguments: an int that
+ * will be true if the test completed successfully and false otherwise, and an
+ * int that will be true if the cleanup function is run in the primary process
+ * (the one that called plan or plan_lazy) and false otherwise.  If
+ * test_cleanup_register_with_data is used instead, a generic pointer can be
+ * provided and will be passed to the cleanup function as a third argument.
+ *
+ * test_cleanup_register_with_data is the better API and should have been the
+ * only API.  test_cleanup_register was an API error preserved for backward
+ * cmpatibility.
+ */
+typedef void (*test_cleanup_func)(int, int);
+typedef void (*test_cleanup_func_with_data)(int, int, void *);
+
+void test_cleanup_register(test_cleanup_func) __attribute__((__nonnull__));
+void test_cleanup_register_with_data(test_cleanup_func_with_data, void *)
+    __attribute__((__nonnull__));
+
 END_DECLS
 
 #endif /* TAP_BASIC_H */
diff --git a/src/external/c-tap-harness/tests/tap/float.c b/src/external/c-tap-harness/tests/tap/float.c
index 67dd555f3..8fbd441ae 100644
--- a/src/external/c-tap-harness/tests/tap/float.c
+++ b/src/external/c-tap-harness/tests/tap/float.c
@@ -8,9 +8,9 @@
  * otherwise care about floating point.
  *
  * This file is part of C TAP Harness.  The current version plus supporting
- * documentation is at <http://www.eyrie.org/~eagle/software/c-tap-harness/>.
+ * documentation is at <https://www.eyrie.org/~eagle/software/c-tap-harness/>.
  *
- * Copyright 2008, 2010, 2012 Russ Allbery <rra@stanford.edu>
+ * Copyright 2008, 2010, 2012-2019 Russ Allbery <eagle@eyrie.org>
  *
  * Permission is hereby granted, free of charge, to any person obtaining a
  * copy of this software and associated documentation files (the "Software"),
@@ -29,13 +29,15 @@
  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
  * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
  * DEALINGS IN THE SOFTWARE.
+ *
+ * SPDX-License-Identifier: MIT
  */
 
 /* Required for isnan() and isinf(). */
 #if defined(__STRICT_ANSI__) || defined(PEDANTIC)
-# ifndef _XOPEN_SOURCE
-#  define _XOPEN_SOURCE 600
-# endif
+#    ifndef _XOPEN_SOURCE
+#        define _XOPEN_SOURCE 600
+#    endif
 #endif
 
 #include <math.h>
@@ -46,22 +48,49 @@
 #include <tests/tap/float.h>
 
 /*
- * Takes an expected double and a seen double and assumes the test passes if
- * those two numbers are within delta of each other.
+ * Clang 4.0.1 gets very confused by this file and produces warnings about
+ * floating point implicit conversion from the isnan() and isinf() macros.
+ */
+#if defined(__llvm__) || defined(__clang__)
+#    pragma clang diagnostic ignored "-Wconversion"
+#    pragma clang diagnostic ignored "-Wdouble-promotion"
+#endif
+
+/*
+ * Returns true if the two doubles are equal infinities, false otherwise.
+ * This requires a bit of machination since isinf is not required to return
+ * different values for positive and negative infinity, and we're trying to
+ * avoid direct comparisons between floating point numbers.
+ */
+static int
+is_equal_infinity(double left, double right)
+{
+    if (!isinf(left) || !isinf(right))
+        return 0;
+    return !!(left < 0) == !!(right < 0);
+}
+
+/*
+ * Takes two doubles and requires they be within epsilon of each other.
  */
-void
-is_double(double wanted, double seen, double epsilon, const char *format, ...)
+int
+is_double(double left, double right, double epsilon, const char *format, ...)
 {
     va_list args;
+    int success;
 
     va_start(args, format);
     fflush(stderr);
-    if ((isnan(wanted) && isnan(seen))
-        || (isinf(wanted) && isinf(seen) && wanted == seen)
-        || fabs(wanted - seen) <= epsilon)
+    if ((isnan(left) && isnan(right)) || is_equal_infinity(left, right)
+        || fabs(left - right) <= epsilon) {
+        success = 1;
         okv(1, format, args);
-    else {
-        printf("# wanted: %g\n#   seen: %g\n", wanted, seen);
+    } else {
+        success = 0;
+        diag(" left: %g", left);
+        diag("right: %g", right);
         okv(0, format, args);
     }
+    va_end(args);
+    return success;
 }
diff --git a/src/external/c-tap-harness/tests/tap/float.h b/src/external/c-tap-harness/tests/tap/float.h
index 746453564..bdf845108 100644
--- a/src/external/c-tap-harness/tests/tap/float.h
+++ b/src/external/c-tap-harness/tests/tap/float.h
@@ -2,9 +2,9 @@
  * Floating point check function for the TAP protocol.
  *
  * This file is part of C TAP Harness.  The current version plus supporting
- * documentation is at <http://www.eyrie.org/~eagle/software/c-tap-harness/>.
+ * documentation is at <https://www.eyrie.org/~eagle/software/c-tap-harness/>.
  *
- * Copyright 2008, 2010, 2012 Russ Allbery <rra@stanford.edu>
+ * Copyright 2008, 2010, 2012, 2014, 2018 Russ Allbery <eagle@eyrie.org>
  *
  * Permission is hereby granted, free of charge, to any person obtaining a
  * copy of this software and associated documentation files (the "Software"),
@@ -23,6 +23,8 @@
  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
  * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
  * DEALINGS IN THE SOFTWARE.
+ *
+ * SPDX-License-Identifier: MIT
  */
 
 #ifndef TAP_FLOAT_H
@@ -32,9 +34,8 @@
 
 BEGIN_DECLS
 
-/* Check an expected value against a seen value within epsilon. */
-void is_double(double wanted, double seen, double epsilon,
-               const char *format, ...)
+/* Compare two values within epsilon. */
+int is_double(double, double, double epsilon, const char *format, ...)
     __attribute__((__format__(printf, 4, 5)));
 
 END_DECLS
diff --git a/src/external/c-tap-harness/tests/tap/libtap.sh b/src/external/c-tap-harness/tests/tap/libtap.sh
index f9347d80b..1827a689e 100644
--- a/src/external/c-tap-harness/tests/tap/libtap.sh
+++ b/src/external/c-tap-harness/tests/tap/libtap.sh
@@ -7,11 +7,11 @@
 #
 # This file provides a TAP-compatible shell function library useful for
 # writing test cases.  It is part of C TAP Harness, which can be found at
-# <http://www.eyrie.org/~eagle/software/c-tap-harness/>.
+# <https://www.eyrie.org/~eagle/software/c-tap-harness/>.
 #
-# Written by Russ Allbery <rra@stanford.edu>
-# Copyright 2009, 2010, 2011, 2012 Russ Allbery <rra@stanford.edu>
-# Copyright 2006, 2007, 2008
+# Written by Russ Allbery <eagle@eyrie.org>
+# Copyright 2009-2012, 2016 Russ Allbery <eagle@eyrie.org>
+# Copyright 2006-2008, 2013
 #     The Board of Trustees of the Leland Stanford Junior University
 #
 # Permission is hereby granted, free of charge, to any person obtaining a copy
@@ -31,6 +31,8 @@
 # LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 # FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 # IN THE SOFTWARE.
+#
+# SPDX-License-Identifier: MIT
 
 # Print out the number of test cases we expect to run.
 plan () {
@@ -204,7 +206,7 @@ strip_colon_error() {
 # Bail out with an error message.
 bail () {
     echo 'Bail out!' "$@"
-    exit 1
+    exit 255
 }
 
 # Output a diagnostic on standard error, preceded by the required # mark.
@@ -212,32 +214,32 @@ diag () {
     echo '#' "$@"
 }
 
-# Search for the given file first in $BUILD and then in $SOURCE and echo the
-# path where the file was found, or the empty string if the file wasn't
-# found.
+# Search for the given file first in $C_TAP_BUILD and then in $C_TAP_SOURCE
+# and echo the path where the file was found, or the empty string if the file
+# wasn't found.
 #
 # This macro uses puts, so don't run it using backticks inside double quotes
 # or bizarre quoting behavior will happen with Solaris sh.
 test_file_path () {
-    if [ -n "$BUILD" ] && [ -f "$BUILD/$1" ] ; then
-        puts "$BUILD/$1"
-    elif [ -n "$SOURCE" ] && [ -f "$SOURCE/$1" ] ; then
-        puts "$SOURCE/$1"
+    if [ -n "$C_TAP_BUILD" ] && [ -f "$C_TAP_BUILD/$1" ] ; then
+        puts "$C_TAP_BUILD/$1"
+    elif [ -n "$C_TAP_SOURCE" ] && [ -f "$C_TAP_SOURCE/$1" ] ; then
+        puts "$C_TAP_SOURCE/$1"
     else
         echo ''
     fi
 }
 
-# Create $BUILD/tmp for use by tests for storing temporary files and return
-# the path (via standard output).
+# Create $C_TAP_BUILD/tmp for use by tests for storing temporary files and
+# return the path (via standard output).
 #
 # This macro uses puts, so don't run it using backticks inside double quotes
 # or bizarre quoting behavior will happen with Solaris sh.
 test_tmpdir () {
-    if [ -z "$BUILD" ] ; then
+    if [ -z "$C_TAP_BUILD" ] ; then
         tap_tmpdir="./tmp"
     else
-        tap_tmpdir="$BUILD"/tmp
+        tap_tmpdir="$C_TAP_BUILD"/tmp
     fi
     if [ ! -d "$tap_tmpdir" ] ; then
         mkdir "$tap_tmpdir" || bail "Error creating $tap_tmpdir"
diff --git a/src/external/c-tap-harness/tests/tap/macros.h b/src/external/c-tap-harness/tests/tap/macros.h
index 33fee42d9..c2c8b5c73 100644
--- a/src/external/c-tap-harness/tests/tap/macros.h
+++ b/src/external/c-tap-harness/tests/tap/macros.h
@@ -6,9 +6,9 @@
  * everyone can pull them in.
  *
  * This file is part of C TAP Harness.  The current version plus supporting
- * documentation is at <http://www.eyrie.org/~eagle/software/c-tap-harness/>.
+ * documentation is at <https://www.eyrie.org/~eagle/software/c-tap-harness/>.
  *
- * Copyright 2008, 2012 Russ Allbery <rra@stanford.edu>
+ * Copyright 2008, 2012-2013, 2015 Russ Allbery <eagle@eyrie.org>
  *
  * Permission is hereby granted, free of charge, to any person obtaining a
  * copy of this software and associated documentation files (the "Software"),
@@ -27,6 +27,8 @@
  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
  * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
  * DEALINGS IN THE SOFTWARE.
+ *
+ * SPDX-License-Identifier: MIT
  */
 
 #ifndef TAP_MACROS_H
@@ -40,9 +42,9 @@
  * the other attributes to work with GCC versions between 2.7 and 2.96.
  */
 #ifndef __attribute__
-# if __GNUC__ < 2 || (__GNUC__ == 2 && __GNUC_MINOR__ < 96)
-#  define __attribute__(spec)   /* empty */
-# endif
+#    if __GNUC__ < 2 || (__GNUC__ == 2 && __GNUC_MINOR__ < 96)
+#        define __attribute__(spec) /* empty */
+#    endif
 #endif
 
 /*
@@ -53,9 +55,18 @@
  * variadic macro support.
  */
 #if !defined(__attribute__) && !defined(__alloc_size__)
-# if __GNUC__ < 4 || (__GNUC__ == 4 && __GNUC_MINOR__ < 3)
-#  define __alloc_size__(spec, args...) /* empty */
-# endif
+#    if defined(__GNUC__) && !defined(__clang__)
+#        if __GNUC__ < 4 || (__GNUC__ == 4 && __GNUC_MINOR__ < 3)
+#            define __alloc_size__(spec, args...) /* empty */
+#        endif
+#    endif
+#endif
+
+/* Suppress __warn_unused_result__ if gcc is too old. */
+#if !defined(__attribute__) && !defined(__warn_unused_result__)
+#    if __GNUC__ < 3 || (__GNUC__ == 3 && __GNUC_MINOR__ < 4)
+#        define __warn_unused_result__ /* empty */
+#    endif
 #endif
 
 /*
@@ -65,7 +76,7 @@
  * compilation context, but there's no push and pop available.
  */
 #if !defined(__attribute__) && (defined(__llvm__) || defined(__clang__))
-# pragma GCC diagnostic ignored "-Wattributes"
+#    pragma GCC diagnostic ignored "-Wattributes"
 #endif
 
 /* Used for unused parameters to silence gcc warnings. */
@@ -78,11 +89,11 @@
 #undef BEGIN_DECLS
 #undef END_DECLS
 #ifdef __cplusplus
-# define BEGIN_DECLS    extern "C" {
-# define END_DECLS      }
+#    define BEGIN_DECLS extern "C" {
+#    define END_DECLS   }
 #else
-# define BEGIN_DECLS    /* empty */
-# define END_DECLS      /* empty */
+#    define BEGIN_DECLS /* empty */
+#    define END_DECLS   /* empty */
 #endif
 
 #endif /* TAP_MACROS_H */
diff --git a/src/fsint/afsaux.c b/src/fsint/afsaux.c
index 3eeca5aca..6d14ef79d 100644
--- a/src/fsint/afsaux.c
+++ b/src/fsint/afsaux.c
@@ -20,7 +20,7 @@
 #if defined(AFS_NBSD50_ENV)
 #include "afs/afs_osi.h"
 #endif
-#if defined(AFS_LINUX20_ENV) || defined(AFS_DARWIN_ENV) || defined(AFS_FBSD_ENV)
+#if defined(AFS_LINUX_ENV) || defined(AFS_DARWIN_ENV) || defined(AFS_FBSD_ENV)
 #include "afs/sysincludes.h"
 #include "afsincludes.h"
 #else
diff --git a/src/gtx/curseswindows.c b/src/gtx/curseswindows.c
index 0c2001794..633030276 100644
--- a/src/gtx/curseswindows.c
+++ b/src/gtx/curseswindows.c
@@ -20,7 +20,7 @@
 
 #include <roken.h>
 
-#if !defined(AFS_SUN5_ENV) && !defined(AFS_LINUX20_ENV) && !defined(AFS_FBSD_ENV)
+#if !defined(AFS_SUN5_ENV) && !defined(AFS_LINUX_ENV) && !defined(AFS_FBSD_ENV)
 #include <sgtty.h>
 #endif
 
diff --git a/src/kauth/kalog.h b/src/kauth/kalog.h
index 2a0801eb9..f572a82a2 100644
--- a/src/kauth/kalog.h
+++ b/src/kauth/kalog.h
@@ -30,7 +30,7 @@ typedef struct {
 #define	LOG_TGTREQUEST		8
 
 #ifdef AUTH_DBM_LOG
-#ifdef AFS_LINUX20_ENV
+#ifdef AFS_LINUX_ENV
 #include <gdbm.h>
 #define dbm_store	gdbm_store
 #define dbm_firstkey	gdbm_firstkey
@@ -41,7 +41,7 @@ typedef struct {
 #define DBM GDBM_FILE
 #define DBM_REPLACE GDBM_REPLACE
 
-#else /* AFS_LINUX20_ENV */
+#else /* AFS_LINUX_ENV */
 #include <ndbm.h>
 #define afs_dbm_nextkey(d, k) dbm_nextkey(d)
 #endif
diff --git a/src/kauth/kaserver.c b/src/kauth/kaserver.c
index da824bc77..844ecda15 100644
--- a/src/kauth/kaserver.c
+++ b/src/kauth/kaserver.c
@@ -55,7 +55,7 @@ struct afsconf_dir *KA_conf;	/* for getting cell info */
 int MinHours = 0;
 int npwSums = KA_NPWSUMS;	/* needs to be variable sometime */
 
-#if !defined(AFS_NT40_ENV) && !defined(AFS_LINUX20_ENV) && !defined(AFS_DARWIN_ENV) && !defined(AFS_XBSD_ENV)
+#if !defined(AFS_NT40_ENV) && !defined(AFS_LINUX_ENV) && !defined(AFS_DARWIN_ENV) && !defined(AFS_XBSD_ENV)
 #undef vfprintf
 #define vfprintf(stream,fmt,args) _doprnt(fmt,args,stream)
 #endif
diff --git a/src/kauth/kauth.rg b/src/kauth/kauth.rg
index 80e5b1109..87fce623b 100644
--- a/src/kauth/kauth.rg
+++ b/src/kauth/kauth.rg
@@ -71,7 +71,7 @@ const KAMINORVERSION = 2;
  * On Linux, dbm is not part of the standard installation, and we can't
  * statically link it in. So, ignore it for now.
  */
-%#if !defined(AFS_HPUX_ENV) && !defined(AFS_NT40_ENV) && !defined(AFS_LINUX20_ENV)
+%#if !defined(AFS_HPUX_ENV) && !defined(AFS_NT40_ENV) && !defined(AFS_LINUX_ENV)
 %#define AUTH_DBM_LOG
 %#endif
 
diff --git a/src/kauth/kkids.c b/src/kauth/kkids.c
index 979e54416..d5437f152 100644
--- a/src/kauth/kkids.c
+++ b/src/kauth/kkids.c
@@ -15,6 +15,7 @@
 #include <afsconfig.h>
 #include <afs/param.h>
 #include <afs/stds.h>
+#include <afs/opr.h>
 
 #include <roken.h>
 
@@ -228,7 +229,7 @@ static struct Acl *
 ParseAcl(char *astr)
 {
     int nplus, nminus, i, trights;
-    char tname[MAXNAME];
+    char tname[MAXNAME + 1] = "";
     struct AclEntry *first, *last, *tl;
     struct Acl *ta;
     sscanf(astr, "%d", &nplus);
@@ -242,7 +243,7 @@ ParseAcl(char *astr)
     last = 0;
     first = 0;
     for (i = 0; i < nplus; i++) {
-	sscanf(astr, "%100s %d", tname, &trights);
+	sscanf(astr, "%" opr_stringize(MAXNAME) "s %d", tname, &trights);
 	SkipLine(astr);
 	tl = malloc(sizeof(struct AclEntry));
 	if (!first)
diff --git a/src/kauth/user.c b/src/kauth/user.c
index 14cd1b09a..c9137412f 100644
--- a/src/kauth/user.c
+++ b/src/kauth/user.c
@@ -163,7 +163,7 @@ ka_UserAuthenticateGeneral(afs_int32 flags, char *name, char *instance,
     }
 #endif
 
-#if !defined(AFS_NT40_ENV) && !defined(AFS_LINUX20_ENV) && !defined(AFS_USR_LINUX20_ENV) && (!defined(AFS_XBSD_ENV) || defined(AFS_FBSD_ENV))
+#if !defined(AFS_NT40_ENV) && !defined(AFS_LINUX_ENV) && !defined(AFS_USR_LINUX_ENV) && (!defined(AFS_XBSD_ENV) || defined(AFS_FBSD_ENV))
     /* handle smoothly the case where no AFS system calls exists (yet) */
     (void)signal(SIGSYS, SIG_IGN);
 #endif
diff --git a/src/libacl/Makefile.in b/src/libacl/Makefile.in
index f2c90f539..fbf532c81 100644
--- a/src/libacl/Makefile.in
+++ b/src/libacl/Makefile.in
@@ -64,8 +64,9 @@ dest: libacl.a acl.h prs_fs.h
 #
 # Misc. targets
 #
+.PHONY: test
 test:
-	cd test; $(MAKE)
+	cd test && $(MAKE)
 
 clean:
 	$(LT_CLEAN)
diff --git a/src/libadmin/cfg/cfginternal.c b/src/libadmin/cfg/cfginternal.c
index 1f581b8b4..f1abacbb4 100644
--- a/src/libadmin/cfg/cfginternal.c
+++ b/src/libadmin/cfg/cfginternal.c
@@ -348,7 +348,7 @@ cfgutil_HostNameGetCellServDbAlias(const char *fsDbHost, const char *hostName,
 		short dbhostFound = 0;
 
 		while (!dbhostDone) {
-		    short isAlias;
+		    short isAlias = 0;
 
 		    if (!bos_HostGetNext(dbIter, hostNameAlias, &tst2)) {
 			/* no more entries (or failure) */
@@ -357,15 +357,15 @@ cfgutil_HostNameGetCellServDbAlias(const char *fsDbHost, const char *hostName,
 			}
 			dbhostDone = 1;
 
-		    } else
-			if (!cfgutil_HostNameIsAlias
-			    (hostName, hostNameAlias, &isAlias, &tst2)) {
-			tst = tst2;
-			dbhostDone = 1;
-
-		    } else if (isAlias) {
-			dbhostFound = 1;
-			dbhostDone = 1;
+		    } else {
+			if (!cfgutil_HostNameIsAlias(hostName, hostNameAlias,
+						     &isAlias, &tst2)) {
+			    tst = tst2;
+			    dbhostDone = 1;
+			} else if (isAlias) {
+			    dbhostFound = 1;
+			    dbhostDone = 1;
+			}
 		    }
 		}
 
diff --git a/src/libadmin/vos/vsprocs.c b/src/libadmin/vos/vsprocs.c
index c82c684ce..475b3376f 100644
--- a/src/libadmin/vos/vsprocs.c
+++ b/src/libadmin/vos/vsprocs.c
@@ -3490,7 +3490,7 @@ UV_SyncServer(afs_cell_handle_p cellHandle, struct rx_connection *server,
     int rc = 0;
     afs_status_t tst = 0;
     int noError;
-    afs_int32 nentries, tentries = 0;
+    afs_int32 nentries;
     struct VldbListByAttributes attributes;
     nbulkentries arrayEntries;
     int totalF;
@@ -3519,7 +3519,6 @@ UV_SyncServer(afs_cell_handle_p cellHandle, struct rx_connection *server,
 	    goto fail_UV_SyncServer;
 	}
 	nsi = -1;
-	tentries += nentries;
 	totalF = 0;
 	for (j = 0; j < nentries; j++) {	/* process each entry */
 	    vllist = &arrayEntries.nbulkentries_val[j];
diff --git a/src/libafs/MakefileProto.FBSD.in b/src/libafs/MakefileProto.FBSD.in
index be7d2708e..8a2a369e7 100644
--- a/src/libafs/MakefileProto.FBSD.in
+++ b/src/libafs/MakefileProto.FBSD.in
@@ -60,13 +60,33 @@ WARNS= 1
 # We have some sketchy code that redeclares prototypes
 CWARNFLAGS+= -Wno-redundant-decls
 
+GEN_KBLD_DIR=@abs_builddir@/kconf-GENERIC
+AFS_OS_CLEAN=$(GEN_KBLD_DIR)
+
+# Starting with FreeBSD 12, opt_global.h is effectively required to build, even
+# for the GENERIC kernel. Normally this would be provided in the kernel build
+# dir (--with-bsd-kernel-build). If that dir was not specified, we can still
+# get the needed header files if we assume that the user is building for the
+# GENERIC kernel. So if we don't have a kernel build dir, generate the header
+# files in GEN_KBLD_DIR by using config(8), and specify that as the
+# KERNBUILDDIR. This won't always work, of course, but it has a chance at
+# working for the most common setups (when the user isn't using some custom
+# kernel). The kernel headers, of course, we assume are in $(KSRC).
+$(GEN_KBLD_DIR):
+	-mkdir $(GEN_KBLD_DIR)
+	cd $(KSRC)/$(MACHINE)/conf && \
+		/usr/sbin/config -d $(GEN_KBLD_DIR) GENERIC
+
 # setup for bsd.kmod.mk infrastructure
 .PATH:	${TOP_SRCDIR}/afs/FBSD
 KMODDIR=/boot/modules
 KERN_DEBUGDIR=/usr/lib/debug
 KMOD=	libafs
 SYSDIR= ${KSRC}
-.if !empty(KBLD)
+
+.if empty(KBLD)
+KERNBUILDDIR=$(GEN_KBLD_DIR)
+.else
 KERNBUILDDIR=${KBLD}
 .endif
 
@@ -83,7 +103,7 @@ DESTDIRS = single_destdir
 # generating headers and objects in this directory, which we want in $(KOBJ).
 # We also need the install target from bsd.kmod.mk in $(KOBJ), but the one
 # from Makefile.common in this directory.  A prime candidate for cleanup.
-setup:
+setup: $(KERNBUILDDIR)
 	-mkdir $(KOBJ)
 	-$(RM) $(KOBJ)/Makefile $(KOBJ)/Makefile.common
 	$(CP) Makefile $(KOBJ)/Makefile
diff --git a/src/libafs/MakefileProto.LINUX.in b/src/libafs/MakefileProto.LINUX.in
index d98fa05ad..c8b072060 100644
--- a/src/libafs/MakefileProto.LINUX.in
+++ b/src/libafs/MakefileProto.LINUX.in
@@ -79,8 +79,9 @@ CFLAGS_rxkad_common.o = -I${TOP_SRCDIR}/rxkad -I$(TOP_OBJDIR)/src/rxkad
 CFLAGS_opr_rbtree.o = -I${TOP_SRCDIR}/opr
 
 CFLAGS_evp.o = -I$(TOP_SRCDIR)/external/heimdal/hcrypto \
-	       -DHAVE_CONFIG_H
-CFLAGS_evp-algs.o = -I$(TOP_SRCDIR)/external/heimdal/hcrypto
+	       -DHAVE_CONFIG_H @CFLAGS_NOCAST_FUNCTION_TYPE@
+CFLAGS_evp-algs.o = -I$(TOP_SRCDIR)/external/heimdal/hcrypto \
+	       @CFLAGS_NOCAST_FUNCTION_TYPE@
 CFLAGS_evp-kernel.o = -I$(TOP_SRCDIR)/external/heimdal/hcrypto
 CFLAGS_rand-timer-kernel.o = -I$(TOP_SRCDIR)/external/heimdal/hcrypto
 CFLAGS_rand-kernel.o = -I$(TOP_SRCDIR)/external/heimdal/hcrypto
@@ -125,7 +126,7 @@ EXTRA_CFLAGS = -I$(LINUX_KERNEL_PATH)/arch/um/include -I$(LINUX_KERNEL_PATH)/arc
 INCLUDES = -I. -I../ -I${TOP_OBJDIR}/src/config \
   -I${TOP_SRCDIR}/rx -I${TOP_OBJDIR}/src/rxstat
 
-CFLAGS = $(CCFLAGS) $(KERN_DBG) $(DEFINES) $(INCLUDES)
+CFLAGS = $(CCFLAGS) $(KERN_DBG) $(DEFINES) $(INCLUDES) @CFLAGS_WERROR@
 
 # Name of directory to hold object files and libraries.
 KOBJ = MODLOAD
diff --git a/src/libafsauthent/afsauthent.def b/src/libafsauthent/afsauthent.def
index 8927ef8fd..10c71cbfc 100644
--- a/src/libafsauthent/afsauthent.def
+++ b/src/libafsauthent/afsauthent.def
@@ -209,3 +209,4 @@ EXPORTS
         xdr_idlist					@208
         xdr_namelist					@209
         xdr_prlist					@210
+        afsconf_CountKeys				@211
diff --git a/src/libuafs/MakefileProto.LINUX.in b/src/libuafs/MakefileProto.LINUX.in
index 3647a4d5f..4dd185a57 100644
--- a/src/libuafs/MakefileProto.LINUX.in
+++ b/src/libuafs/MakefileProto.LINUX.in
@@ -22,7 +22,7 @@ ifeq (${SYS_NAME}, ppc64_linux26)
 UAFS_CFLAGS=-fPIC
 endif
 
-TEST_CFLAGS=-pthread -D_REENTRANT -DAFS_PTHREAD_ENV -DAFS_LINUX22_ENV $(XCFLAGS)
+TEST_CFLAGS=-pthread -D_REENTRANT -DAFS_PTHREAD_ENV -DAFS_LINUX_ENV $(XCFLAGS)
 TEST_LDFLAGS=
 TEST_LIBS=-lpthread @LIB_crypt@
 
diff --git a/src/log/Makefile.in b/src/log/Makefile.in
index e067d3ab9..f1cbf7381 100644
--- a/src/log/Makefile.in
+++ b/src/log/Makefile.in
@@ -102,7 +102,8 @@ clean:
 	$(RM) -f *.o unlog tokens kseal pagsh pagsh.krb \
 		core AFS_component_version_number.c tokens.krb
 
+.PHONY: test
 test:
-	cd test; $(MAKE)
+	cd test && $(MAKE)
 
 include ../config/Makefile.version
diff --git a/src/lwp/Makefile.in b/src/lwp/Makefile.in
index 7b820c4dc..63c540f0c 100644
--- a/src/lwp/Makefile.in
+++ b/src/lwp/Makefile.in
@@ -60,6 +60,7 @@ process.default.s:
 # Making process.o for $(SYS_NAME)
 # The files "process.s" and "process.S" may be used internally,
 # but will be removed after building the .o
+CFLAGS_process.o = @CFLAGS_NODANGLING_POINTER@
 process.o	: process.default.s process.i386.s process.amd64.s process.c lwp.o
 	@set -x; case "$(SYS_NAME)" in \
 	sun4c_51 | sun4c_52 | sun4m_51 | sun4m_52 | sun4c_53 | sun4m_53  | sun4_53 | sun4_52 | sun4_54 | sun4c_54 | sun4m_54 | sun4x_5* | arm_linux* ) \
diff --git a/src/lwp/iomgr.c b/src/lwp/iomgr.c
index 670fd293a..1251d06ca 100644
--- a/src/lwp/iomgr.c
+++ b/src/lwp/iomgr.c
@@ -201,7 +201,7 @@ static struct IoRequest *NewRequest(void)
 
 /* On Linux without __USE_XOPEN, we have __fds_bits. With __USE_XOPEN, or
  * non-Linux, we have fds_bits. */
-#if defined(AFS_LINUX22_ENV) && (__GLIBC_MINOR__ > 0) && !defined(__USE_XOPEN)
+#if defined(AFS_LINUX_ENV) && (__GLIBC_MINOR__ > 0) && !defined(__USE_XOPEN)
 # define FDS_BITS __fds_bits
 #else
 # define FDS_BITS fds_bits
@@ -473,7 +473,7 @@ static void *IOMGR(void *dummy)
 		iomgr_timeout.tv_sec = 100000000;
 		iomgr_timeout.tv_usec = 0;
 	    }
-#if defined(AFS_NT40_ENV) || defined(AFS_LINUX24_ENV)
+#if defined(AFS_NT40_ENV) || defined(AFS_LINUX_ENV)
 	    /* On NT, signals don't interrupt a select call. So this can potentially
 	     * lead to long wait times before a signal is honored. To avoid this we
 	     * dont do select() for longer than IOMGR_MAXWAITTIME (5 secs) */
@@ -565,7 +565,7 @@ static void *IOMGR(void *dummy)
 		/* Real timeout only if signal handler hasn't set
 		   iomgr_timeout to zero. */
 
-#if defined(AFS_NT40_ENV) || defined(AFS_LINUX24_ENV)
+#if defined(AFS_NT40_ENV) || defined(AFS_LINUX_ENV)
 		/* On NT, real timeout only if above and if iomgr_timeout
 		 * interval is equal to timeout interval (i.e., not adjusted
 		 * to check for pseudo-signals).
diff --git a/src/lwp/lwp.c b/src/lwp/lwp.c
index 759947524..c7deffc1f 100644
--- a/src/lwp/lwp.c
+++ b/src/lwp/lwp.c
@@ -33,8 +33,8 @@
 int setlim(int limcon, uchar_t hard, int limit);
 #endif
 
-#ifndef AFS_ARM_LINUX20_ENV
-#if defined(AFS_S390_LINUX20_ENV)
+#ifndef AFS_ARM_LINUX_ENV
+#if defined(AFS_S390_LINUX_ENV)
 int PRE_Block;	/* Remnants of preemption support. */
 #else
 char PRE_Block;	/* Remnants of preemption support. */
@@ -52,7 +52,7 @@ char PRE_Block;	/* Remnants of preemption support. */
 #define MAXINT     (~(1<<((sizeof(int)*8)-1)))
 #define MINSTACK   44
 
-#if defined(__hp9000s800) || defined(AFS_PARISC_LINUX24_ENV)
+#if defined(__hp9000s800)
 #define MINFRAME 128
 #define STACK_ALIGN 8
 #else
@@ -365,7 +365,7 @@ LWP_CreateProcess(void *(*ep) (void *), int stacksize, int priority, void *parm,
 	Initialize_PCB(temp, priority, stackmemory, stacksize, ep, parm, name);
 	insert(temp, &runnable[priority]);
 	temp2 = lwp_cpptr;
-#if !defined(AFS_ARM_LINUX20_ENV) && !defined(AFS_ARM_DARWIN_ENV)
+#if !defined(AFS_ARM_LINUX_ENV) && !defined(AFS_ARM_DARWIN_ENV)
 	if (PRE_Block != 0)
 	    Abort_LWP("PRE_Block not 0");
 
@@ -373,10 +373,6 @@ LWP_CreateProcess(void *(*ep) (void *), int stacksize, int priority, void *parm,
 	PRE_Block = 1;
 #endif
 	lwp_cpptr = temp;
-#if defined(AFS_PARISC_LINUX24_ENV)
-	savecontext(Create_Process_Part2, &temp2->context,
-		    stackptr + MINFRAME);
-#else
 #ifdef __hp9000s800
 	savecontext(Create_Process_Part2, &temp2->context,
 		    stackptr + MINFRAME);
@@ -389,20 +385,19 @@ LWP_CreateProcess(void *(*ep) (void *), int stacksize, int priority, void *parm,
 	savecontext(Create_Process_Part2, &temp2->context, stackptr + stacksize - 16);	/* 16 = 2 * jmp_buf_type */
 #endif /* !sys_x86_darwin_80 */
 #else
-#if defined(AFS_SPARC64_LINUX20_ENV) || defined(AFS_SPARC_LINUX20_ENV)
+#if defined(AFS_SPARC64_LINUX_ENV) || defined(AFS_SPARC_LINUX_ENV)
 	savecontext(Create_Process_Part2, &temp2->context, stackptr + stacksize - 0x40);	/* lomgjmp does something
 												 * with %fp + 0x38 */
 #else
-#if defined(AFS_S390_LINUX20_ENV)
+#if defined(AFS_S390_LINUX_ENV)
 	savecontext(Create_Process_Part2, &temp2->context,
 		    stackptr + stacksize - MINFRAME);
-#else /* !AFS_S390_LINUX20_ENV */
+#else /* !AFS_S390_LINUX_ENV */
 	savecontext(Create_Process_Part2, &temp2->context,
 		    stackptr + stacksize - sizeof(void *));
-#endif /* AFS_S390_LINUX20_ENV */
-#endif /* AFS_SPARC64_LINUX20_ENV || AFS_SPARC_LINUX20_ENV */
+#endif /* AFS_S390_LINUX_ENV */
+#endif /* AFS_SPARC64_LINUX_ENV || AFS_SPARC_LINUX_ENV */
 #endif /* AFS_SGI62_ENV */
-#endif
 #endif
 	/* End of gross hack */
 
@@ -461,7 +456,7 @@ LWP_CreateProcess2(void *(*ep) (void *), int stacksize, int priority, void *parm
 	Initialize_PCB(temp, priority, stackptr, stacksize, ep, parm, name);
 	insert(temp, &runnable[priority]);
 	temp2 = lwp_cpptr;
-#if !defined(AFS_ARM_LINUX20_ENV) && !defined(AFS_ARM_DARWIN_ENV)
+#if !defined(AFS_ARM_LINUX_ENV) && !defined(AFS_ARM_DARWIN_ENV)
 	if (PRE_Block != 0)
 	    Abort_LWP("PRE_Block not 0");
 
@@ -519,19 +514,19 @@ LWP_DestroyProcess(PROCESS pid)
 	    pid->status = DESTROYED;
 	    move(pid, &runnable[pid->priority], &blocked);
 	    temp = lwp_cpptr;
-#if defined(__hp9000s800) || defined(AFS_PARISC_LINUX24_ENV)
+#if defined(__hp9000s800)
 	    savecontext(Dispatcher, &(temp->context),
 			&(LWPANCHOR.dsptchstack[MINFRAME]));
 #elif defined(AFS_SGI62_ENV) || defined(AFS_DARWIN_ENV) || defined(AFS_XBSD_ENV)
 	    savecontext(Dispatcher, &(temp->context),
 			&(LWPANCHOR.
 			  dsptchstack[(sizeof LWPANCHOR.dsptchstack) - 8]));
-#elif defined(AFS_SPARC64_LINUX20_ENV) || defined(AFS_SPARC_LINUX20_ENV)
+#elif defined(AFS_SPARC64_LINUX_ENV) || defined(AFS_SPARC_LINUX_ENV)
 	    savecontext(Dispatcher, &(temp->context),
 			&(LWPANCHOR.
 			  dsptchstack[(sizeof LWPANCHOR.dsptchstack) -
 				      0x40]));
-#elif defined(AFS_S390_LINUX20_ENV)
+#elif defined(AFS_S390_LINUX_ENV)
 	    savecontext(Dispatcher, &(temp->context),
 			&(LWPANCHOR.
 			  dsptchstack[(sizeof LWPANCHOR.dsptchstack) -
@@ -909,7 +904,7 @@ Dispatcher(void)
      * the guard word at the front of the stack being damaged and
      * for the stack pointer being below the front of the stack.
      * WARNING!  This code assumes that stacks grow downward. */
-#if defined(__hp9000s800) || defined(AFS_PARISC_LINUX24_ENV)
+#if defined(__hp9000s800)
     /* Fix this (stackcheck at other end of stack?) */
     if (lwp_cpptr != NULL && lwp_cpptr->stack != NULL
 	&& (lwp_cpptr->stackcheck !=
@@ -961,7 +956,7 @@ Dispatcher(void)
 	printf("Dispatch %d [PCB at 0x%x] \"%s\"\n", ++dispatch_count,
 	       runnable[i].head, runnable[i].head->name);
 #endif
-#if !defined(AFS_ARM_LINUX20_ENV) && !defined(AFS_ARM_DARWIN_ENV)
+#if !defined(AFS_ARM_LINUX_ENV) && !defined(AFS_ARM_DARWIN_ENV)
     if (PRE_Block != 1)
 	Abort_LWP("PRE_Block not 1");
 #endif
@@ -1052,7 +1047,7 @@ Initialize_PCB(PROCESS temp, int priority, char *stack, int stacksize,
     temp->index = lwp_nextindex++;
     temp->stack = stack;
     temp->stacksize = stacksize;
-#if defined(__hp9000s800) || defined(AFS_PARISC_LINUX24_ENV)
+#if defined(__hp9000s800)
     if (temp->stack != NULL)
 	temp->stackcheck = *(int *)((temp->stack) + stacksize - 4);
 #else
@@ -1107,7 +1102,7 @@ Initialize_Stack(char *stackptr, int stacksize)
 	for (i = 0; i < stacksize; i++)
 	    stackptr[i] = i & 0xff;
     else
-#if defined(__hp9000s800) || defined(AFS_PARISC_LINUX24_ENV)
+#if defined(__hp9000s800)
 	*(afs_int32 *) (stackptr + stacksize - 4) = STACKMAGIC;
 #else
 	*(afs_int32 *) stackptr = STACKMAGIC;
@@ -1120,7 +1115,7 @@ Stack_Used(char *stackptr, int stacksize)
 {
     int i;
 
-#if defined(__hp9000s800) || defined(AFS_PARISC_LINUX24_ENV)
+#if defined(__hp9000s800)
     if (*(afs_int32 *) (stackptr + stacksize - 4) == STACKMAGIC)
 	return 0;
     else {
diff --git a/src/lwp/lwp.h b/src/lwp/lwp.h
index 3b58c5917..3f57dd63f 100644
--- a/src/lwp/lwp.h
+++ b/src/lwp/lwp.h
@@ -26,7 +26,7 @@
 #ifndef _MFC_VER		/*skip if doing Microsoft foundation class */
 #include <winsock2.h>
 #endif
-#elif defined(AFS_LINUX20_ENV)
+#elif defined(AFS_LINUX_ENV)
 #include <unistd.h>
 #include <time.h>
 #include <sys/time.h>
@@ -212,7 +212,7 @@ char lwp_debug;			/* ON = show LWP debugging trace */
  */
 #if defined(USE_UCONTEXT) && defined(HAVE_UCONTEXT_H)
 #define AFS_LWP_MINSTACKSIZE  (288 * 1024)
-#elif defined(AFS_LINUX22_ENV)
+#elif defined(AFS_LINUX_ENV)
 #define AFS_LWP_MINSTACKSIZE	(192 * 1024)
 #else
 #define AFS_LWP_MINSTACKSIZE	(48 * 1024)
@@ -273,7 +273,7 @@ extern afs_int32 savecontext(void (*ep)(void),
 			     struct lwp_context *savearea, char *sp);
 extern void returnto(struct lwp_context *savearea);
 
-#ifdef AFS_LINUX24_ENV
+#ifdef AFS_LINUX_ENV
 /* max time we are allowed to spend in a select call on Linux to avoid
  lost signal issues */
 #define IOMGR_MAXWAITTIME        60	/* seconds */
diff --git a/src/lwp/process.c b/src/lwp/process.c
index 954057193..7130c3ea1 100644
--- a/src/lwp/process.c
+++ b/src/lwp/process.c
@@ -18,7 +18,7 @@
 
 #include "lwp.h"
 
-#if defined(AFS_S390_LINUX20_ENV)
+#if defined(AFS_S390_LINUX_ENV)
 extern int PRE_Block;		/* used in lwp.c and process.s */
 #else
 extern char PRE_Block;		/* used in lwp.c and process.s */
@@ -26,7 +26,7 @@ extern char PRE_Block;		/* used in lwp.c and process.s */
 
 #if defined(USE_UCONTEXT) && defined(HAVE_UCONTEXT_H)
 
-# if defined(AFS_LINUX20_ENV) || defined(AFS_XBSD_ENV)
+# if defined(AFS_LINUX_ENV) || defined(AFS_XBSD_ENV)
 #  define AFS_UCONTEXT_NOSTACK
 # endif
 
@@ -88,27 +88,25 @@ returnto(struct lwp_context *savearea)
 # else
 #  define LWP_SP JB_SP
 # endif
-#elif	defined(AFS_HPUX_ENV) || defined(AFS_PARISC_LINUX24_ENV)
+#elif	defined(AFS_HPUX_ENV)
 #define	LWP_SP	1
-#elif	defined(AFS_LINUX20_ENV)
-#if defined(AFS_PPC_LINUX20_ENV) || defined(AFS_PPC64_LINUX20_ENV)
+#elif	defined(AFS_LINUX_ENV)
+#if defined(AFS_PPC_LINUX_ENV) || defined(AFS_PPC64_LINUX_ENV)
 #define LWP_SP 0
-#elif   defined(AFS_I386_LINUX20_ENV)
+#elif   defined(AFS_I386_LINUX_ENV)
 #define LWP_SP 4
-#elif   defined(AFS_S390_LINUX20_ENV)
+#elif   defined(AFS_S390_LINUX_ENV)
 #define LWP_SP 9
 #define LWP_FP 5
-#elif   defined(AFS_SPARC_LINUX20_ENV)
+#elif   defined(AFS_SPARC_LINUX_ENV)
 #define LWP_SP 0
 #define LWP_FP 1
-#elif   defined(AFS_SPARC64_LINUX20_ENV) && defined(AFS_32BIT_USR_ENV)
+#elif   defined(AFS_SPARC64_LINUX_ENV) && defined(AFS_32BIT_USR_ENV)
 #define LWP_SP 0
 #define LWP_FP 1
-#elif defined(AFS_ALPHA_LINUX20_ENV)
+#elif defined(AFS_ALPHA_LINUX_ENV)
 #define LWP_SP 8
 #define LWP_FP 7
-#elif defined(AFS_PARISC_LINUX24_ENV)
-#define LWP_SP 19
 #else
 #error Unsupported linux LWP system type.
 #endif
@@ -129,11 +127,11 @@ Need offset to SP in jmp_buf for this platform.
 typedef __uint64_t jmp_buf_type;
 #endif
 #else
-#if defined(AFS_ALPHA_LINUX20_ENV) || defined(AFS_PPC64_LINUX20_ENV)
+#if defined(AFS_ALPHA_LINUX_ENV) || defined(AFS_PPC64_LINUX_ENV)
 typedef long jmp_buf_type;
 #else
 typedef int jmp_buf_type;
-#endif /*AFS_ALPHA_LINUX20_ENV */
+#endif /*AFS_ALPHA_LINUX_ENV */
 #endif /*SGI*/
 
     static jmp_buf jmp_tmp;
@@ -145,12 +143,12 @@ static jmp_buf_type *jmpBuffer;
   * On Sparc ucontext functions are not implemented.
   */
 #define ptr_mangle(x) (x)
-#ifdef AFS_LINUX20_ENV
+#ifdef AFS_LINUX_ENV
 
 #ifdef __GLIBC__
 #if (__GLIBC__ > 2) || (__GLIBC__ == 2 && __GLIBC_MINOR__ > 3)
 
-#if defined(AFS_SPARC64_LINUX24_ENV) || defined(AFS_SPARC_LINUX24_ENV)
+#if defined(AFS_SPARC64_LINUX_ENV) || defined(AFS_SPARC_LINUX_ENV)
 /* technically we should use POINTER_GUARD
  * ( == offsetof (tcbhead_t, pointer_guard) )
  * instead of 0x18
@@ -204,7 +202,7 @@ savecontext(void (*ep)(void), struct lwp_context *savearea, char *sp)
 	    case 0:
 		jmpBuffer = (jmp_buf_type *) jmp_tmp;
 		jmpBuffer[LWP_SP] = ptr_mangle((jmp_buf_type) sp);
-#if defined(AFS_S390_LINUX20_ENV) || defined(AFS_SPARC_LINUX20_ENV) || (defined(AFS_SPARC64_LINUX20_ENV) && defined(AFS_32BIT_USR_ENV))
+#if defined(AFS_S390_LINUX_ENV) || defined(AFS_SPARC_LINUX_ENV) || (defined(AFS_SPARC64_LINUX_ENV) && defined(AFS_32BIT_USR_ENV))
 		jmpBuffer[LWP_FP] = ptr_mangle((jmp_buf_type) sp);
 #endif
 		longjmp(jmp_tmp, 1);
diff --git a/src/lwp/waitkey.c b/src/lwp/waitkey.c
index 11ef20b8d..aa7755510 100644
--- a/src/lwp/waitkey.c
+++ b/src/lwp/waitkey.c
@@ -164,7 +164,7 @@ LWP_WaitForKeystroke(int seconds)
 #if defined(HAVE_STDIO_EXT_H)
     if (__fbufsize(stdin) > 0)
         return 1;
-#elif defined(AFS_LINUX20_ENV)
+#elif defined(AFS_LINUX_ENV)
     if (stdin->_IO_read_ptr < stdin->_IO_read_end)
 	return 1;
 #elif (defined(AFS_DARWIN_ENV) || defined(AFS_XBSD_ENV)) && defined(AFS_DFBSD_ENV)
diff --git a/src/opr/jhash.h b/src/opr/jhash.h
index 4568f567c..5fedaa1f7 100644
--- a/src/opr/jhash.h
+++ b/src/opr/jhash.h
@@ -79,13 +79,10 @@ opr_jhash(const afs_uint32 *k, size_t length, afs_uint32 initval)
 
     /* All the case statements fall through */
     switch(length) {
-      case 3 : c+=k[2];
-	/* fall through */
-      case 2 : b+=k[1];
-	/* fall through */
+      case 3 : c+=k[2];			AFS_FALLTHROUGH;
+      case 2 : b+=k[1];			AFS_FALLTHROUGH;
       case 1 : a+=k[0];
-	opr_jhash_final(a, b, c);
-	/* fall through */
+	opr_jhash_final(a, b, c);	AFS_FALLTHROUGH;
       case 0:     /* case 0: nothing left to add */
 	break;
     }
@@ -150,19 +147,19 @@ opr_jhash_opaque(const void *val, size_t length, afs_uint32 initval)
 
     /* All the case statements fall through */
     switch(length) {
-      case 12 : c += (afs_uint32) str[11]<<24;
-      case 11 : c += (afs_uint32) str[10]<<16;
-      case 10 : c += (afs_uint32) str[9]<<8;
-      case 9  : c += (afs_uint32) str[8];
-      case 8  : b += (afs_uint32) str[7]<<24;
-      case 7  : b += (afs_uint32) str[6]<<16;
-      case 6  : b += (afs_uint32) str[5]<<8;
-      case 5  : b += (afs_uint32) str[4];
-      case 4  : a += (afs_uint32) str[3]<<24;
-      case 3  : a += (afs_uint32) str[2]<<16;
-      case 2  : a += (afs_uint32) str[1]<<8;
+      case 12 : c += (afs_uint32) str[11]<<24;	AFS_FALLTHROUGH;
+      case 11 : c += (afs_uint32) str[10]<<16;	AFS_FALLTHROUGH;
+      case 10 : c += (afs_uint32) str[9]<<8;	AFS_FALLTHROUGH;
+      case 9  : c += (afs_uint32) str[8];	AFS_FALLTHROUGH;
+      case 8  : b += (afs_uint32) str[7]<<24;	AFS_FALLTHROUGH;
+      case 7  : b += (afs_uint32) str[6]<<16;	AFS_FALLTHROUGH;
+      case 6  : b += (afs_uint32) str[5]<<8;	AFS_FALLTHROUGH;
+      case 5  : b += (afs_uint32) str[4];	AFS_FALLTHROUGH;
+      case 4  : a += (afs_uint32) str[3]<<24;	AFS_FALLTHROUGH;
+      case 3  : a += (afs_uint32) str[2]<<16;	AFS_FALLTHROUGH;
+      case 2  : a += (afs_uint32) str[1]<<8;	AFS_FALLTHROUGH;
       case 1  : a += (afs_uint32) str[0];
-	opr_jhash_final(a, b, c);
+	opr_jhash_final(a, b, c);		AFS_FALLTHROUGH;
       case 0:     /* case 0: nothing left to add */
 	break;
     }
diff --git a/src/opr/opr.h b/src/opr/opr.h
index 98bdf39be..aae17e3cb 100644
--- a/src/opr/opr.h
+++ b/src/opr/opr.h
@@ -9,6 +9,11 @@
 
 /* assert.c */
 
+/* A simple macro to help show the value of #define'd constants. e.g. If 'FOO'
+ * is defined as 5, then opr_stringize(FOO) expands to "5" */
+#define opr_stringize_(s) #s
+#define opr_stringize(s) opr_stringize_(s)
+
 #ifdef AFS_NT40_ENV
 # define opr_abort() opr_NTAbort()
 extern void opr_NTAbort(void);
diff --git a/src/pam/afs_auth.c b/src/pam/afs_auth.c
index d41d2f074..e5992ad23 100644
--- a/src/pam/afs_auth.c
+++ b/src/pam/afs_auth.c
@@ -66,7 +66,7 @@ pam_sm_authenticate(pam_handle_t * pamh, int flags, int argc,
     pid_t cpid, rcpid;
     int status;
     struct sigaction newAction, origAction;
-#if !(defined(AFS_LINUX20_ENV) || defined(AFS_FBSD_ENV) || defined(AFS_DFBSD_ENV) || defined(AFS_NBSD_ENV))
+#if !(defined(AFS_LINUX_ENV) || defined(AFS_FBSD_ENV) || defined(AFS_DFBSD_ENV) || defined(AFS_NBSD_ENV))
     char upwd_buf[2048];       /* size is a guess. */
     struct passwd unix_pwd;
 #endif
@@ -187,7 +187,7 @@ pam_sm_authenticate(pam_handle_t * pamh, int flags, int argc,
 	RET(PAM_AUTH_ERR);
     }
 #else
-#if     defined(AFS_LINUX20_ENV) || defined(AFS_FBSD_ENV) || defined(AFS_DFBSD_ENV) || defined(AFS_NBSD_ENV)
+#if     defined(AFS_LINUX_ENV) || defined(AFS_FBSD_ENV) || defined(AFS_DFBSD_ENV) || defined(AFS_NBSD_ENV)
     upwd = getpwnam(user);
 #else
     upwd = getpwnam_r(user, &unix_pwd, upwd_buf, sizeof(upwd_buf));
diff --git a/src/pam/afs_password.c b/src/pam/afs_password.c
index 547e72300..e2c072c81 100644
--- a/src/pam/afs_password.c
+++ b/src/pam/afs_password.c
@@ -53,7 +53,7 @@ pam_sm_chauthtok(pam_handle_t * pamh, int flags, int argc, const char **argv)
     struct ubik_client *conn = 0;
     PAM_CONST struct pam_conv *pam_convp = NULL;
     struct passwd *upwd = NULL;
-#if !(defined(AFS_LINUX20_ENV) || defined(AFS_FBSD_ENV) || defined(AFS_DFBSD_ENV) || defined(AFS_NBSD_ENV))
+#if !(defined(AFS_LINUX_ENV) || defined(AFS_FBSD_ENV) || defined(AFS_DFBSD_ENV) || defined(AFS_NBSD_ENV))
     char upwd_buf[2048];	/* size is a guess. */
     struct passwd unix_pwd;
 #endif
@@ -130,7 +130,7 @@ pam_sm_chauthtok(pam_handle_t * pamh, int flags, int argc, const char **argv)
 	RET(PAM_AUTH_ERR);
     }
 #else
-#if     defined(AFS_LINUX20_ENV) || defined(AFS_FBSD_ENV) || defined(AFS_DFBSD_ENV) || defined(AFS_NBSD_ENV)
+#if     defined(AFS_LINUX_ENV) || defined(AFS_FBSD_ENV) || defined(AFS_DFBSD_ENV) || defined(AFS_NBSD_ENV)
     upwd = getpwnam(user);
 #else
     upwd = getpwnam_r(user, &unix_pwd, upwd_buf, sizeof(upwd_buf));
diff --git a/src/pam/afs_session.c b/src/pam/afs_session.c
index e4a3620fa..9b460a0d0 100644
--- a/src/pam/afs_session.c
+++ b/src/pam/afs_session.c
@@ -81,7 +81,7 @@ pam_sm_close_session(pam_handle_t * pamh, int flags, int argc,
 	case -1:		/* error */
 	    return (PAM_SESSION_ERR);
 	case 0:		/* child */
-#ifdef AFS_LINUX20_ENV
+#ifdef AFS_LINUX_ENV
 	    setpgrp();
 #endif
 	    setsid();
diff --git a/src/pam/afs_setcred.c b/src/pam/afs_setcred.c
index 0bfbb85ae..f6c4fc4ff 100644
--- a/src/pam/afs_setcred.c
+++ b/src/pam/afs_setcred.c
@@ -57,7 +57,7 @@ pam_sm_setcred(pam_handle_t * pamh, int flags, int argc, const char **argv)
     int password_expires = -1;
     char *reason = NULL;
     struct passwd *upwd = NULL;
-#if !(defined(AFS_LINUX20_ENV) || defined(AFS_FBSD_ENV) || defined(AFS_DFBSD_ENV) || defined(AFS_NBSD_ENV))
+#if !(defined(AFS_LINUX_ENV) || defined(AFS_FBSD_ENV) || defined(AFS_DFBSD_ENV) || defined(AFS_NBSD_ENV))
     char upwd_buf[2048];       /* size is a guess. */
     struct passwd unix_pwd;
 #endif
@@ -165,7 +165,7 @@ pam_sm_setcred(pam_handle_t * pamh, int flags, int argc, const char **argv)
 	RET(PAM_AUTH_ERR);
     }
 #else
-#if     defined(AFS_LINUX20_ENV) || defined(AFS_FBSD_ENV) || defined(AFS_DFBSD_ENV) || defined(AFS_NBSD_ENV)
+#if     defined(AFS_LINUX_ENV) || defined(AFS_FBSD_ENV) || defined(AFS_DFBSD_ENV) || defined(AFS_NBSD_ENV)
     upwd = getpwnam(user);
 #else
     upwd = getpwnam_r(user, &unix_pwd, upwd_buf, sizeof(upwd_buf));
diff --git a/src/pam/test_pam.c b/src/pam/test_pam.c
index 1133c2529..f557ae832 100644
--- a/src/pam/test_pam.c
+++ b/src/pam/test_pam.c
@@ -28,7 +28,7 @@ static const char *service = "afstest";
 static const char *new_envstring = "GOTHEREVIATESTPAM=1";
 static const char *new_homestring = "HOME=/tmp";
 
-#if defined(AFS_LINUX20_ENV) || defined(AFS_FBSD_ENV) || defined(AFS_DFBSD_ENV) || defined(AFS_NBSD_ENV) || defined(AFS_DARWIN_ENV)
+#if defined(AFS_LINUX_ENV) || defined(AFS_FBSD_ENV) || defined(AFS_DFBSD_ENV) || defined(AFS_NBSD_ENV) || defined(AFS_DARWIN_ENV)
 #define getpassphrase getpass
 #endif
 
diff --git a/src/platform/IRIX/rcmd.c b/src/platform/IRIX/rcmd.c
index 37ad40f1c..5bc93f6ad 100644
--- a/src/platform/IRIX/rcmd.c
+++ b/src/platform/IRIX/rcmd.c
@@ -87,7 +87,7 @@ rcmd(ahost, rport, locuser, remuser, cmd, fd2p)
 #endif
      char **ahost;
      u_short rport;
-#if defined(AFS_LINUX20_ENV) || defined(AFS_DARWIN_ENV) || defined(AFS_FBSD_ENV)
+#if defined(AFS_LINUX_ENV) || defined(AFS_DARWIN_ENV) || defined(AFS_FBSD_ENV)
      const char *locuser, *remuser, *cmd;
 #else
      char *locuser, *remuser, *cmd;
@@ -336,7 +336,7 @@ rresvport(alport)
 
 int _check_rhosts_file = 1;
 
-#if defined(AFS_HPUX102_ENV) || defined(AFS_LINUX20_ENV) || defined(AFS_DARWIN_ENV) || defined(AFS_FBSD_ENV)
+#if defined(AFS_HPUX102_ENV) || defined(AFS_LINUX_ENV) || defined(AFS_DARWIN_ENV) || defined(AFS_FBSD_ENV)
 ruserok(rhost, superuser, ruser, luser)
      const char *rhost;
      int superuser;
diff --git a/src/ptserver/ptprototypes.h b/src/ptserver/ptprototypes.h
index bc4c8d654..43b136140 100644
--- a/src/ptserver/ptprototypes.h
+++ b/src/ptserver/ptprototypes.h
@@ -76,7 +76,7 @@ extern afs_int32 AddToEntry(struct ubik_trans *tt, struct prentry *entry,
 			    afs_int32 loc, afs_int32 aid);
 extern int AccessOK(struct ubik_trans *ut, afs_int32 cid,
 		    struct prentry *tentry, int mem, int any);
-extern afs_int32 CreateEntry(struct ubik_trans *at, char aname[],
+extern afs_int32 CreateEntry(struct ubik_trans *at, char aname[PR_MAXNAMELEN],
 			     afs_int32 *aid, afs_int32 idflag,
 			     afs_int32 flag, afs_int32 oid, afs_int32 creator);
 extern afs_int32 RemoveFromEntry(struct ubik_trans *at, afs_int32 aid,
diff --git a/src/ptserver/pts.c b/src/ptserver/pts.c
index fb23968d9..3c5fc6d35 100644
--- a/src/ptserver/pts.c
+++ b/src/ptserver/pts.c
@@ -626,6 +626,7 @@ CheckEntry(struct cmd_syndesc *as, void *arock)
     idlist ids;
     idlist lids;
     struct prcheckentry aentry;
+    prname admins = "system:administrators";
 
     if (GetNameOrId(as, &ids, &names))
 	return PRBADARG;
@@ -691,7 +692,7 @@ CheckEntry(struct cmd_syndesc *as, void *arock)
 	}
 	if (aentry.id == SYSADMINID)
 	    admin = 1;
-	else if (!pr_IsAMemberOf(aentry.name, "system:administrators", &flag)) {
+	else if (!pr_IsAMemberOf(aentry.name, admins, &flag)) {
 	    if (flag)
 		admin = 1;
 	}
@@ -754,11 +755,12 @@ ChownGroup(struct cmd_syndesc *as, void *arock)
 {
     afs_int32 code;
     char *name;
+    prname newname = "";
     char *owner;
 
     name = as->parms[0].items->data;
     owner = as->parms[1].items->data;
-    code = pr_ChangeEntry(name, "", 0, owner);
+    code = pr_ChangeEntry(name, newname, 0, owner);
     if (code)
 	afs_com_err(whoami, code, "; unable to change owner of %s to %s", name,
 		owner);
@@ -771,10 +773,11 @@ ChangeName(struct cmd_syndesc *as, void *arock)
     afs_int32 code;
     char *oldname;
     char *newname;
+    prname owner = "";
 
     oldname = as->parms[0].items->data;
     newname = as->parms[1].items->data;
-    code = pr_ChangeEntry(oldname, newname, 0, "");
+    code = pr_ChangeEntry(oldname, newname, 0, owner);
     if (code)
 	afs_com_err(whoami, code, "; unable to change name of %s to %s", oldname,
 		newname);
diff --git a/src/ptserver/ptserver.c b/src/ptserver/ptserver.c
index 2ab437de6..c5e640e97 100644
--- a/src/ptserver/ptserver.c
+++ b/src/ptserver/ptserver.c
@@ -607,7 +607,11 @@ main(int argc, char **argv)
 		   "1.0",
 #endif
 		   "Starting AFS", FSLog);
-    if (afsconf_GetLatestKey(prdir, NULL, NULL) == 0) {
+    if (afsconf_CountKeys(prdir) == 0) {
+	ViceLog(0, ("WARNING: No encryption keys found! "
+		    "All authenticated accesses will fail. "
+		    "Run akeyconvert or asetkey to import encryption keys.\n"));
+    } else if (afsconf_GetLatestKey(prdir, NULL, NULL) == 0) {
 	LogDesWarning();
     }
 
diff --git a/src/ptserver/ptutils.c b/src/ptserver/ptutils.c
index c551c62b9..1a343feaa 100644
--- a/src/ptserver/ptutils.c
+++ b/src/ptserver/ptutils.c
@@ -1847,8 +1847,15 @@ Initdb(void)
 #define InitialGroup(id,name) do {    \
     afs_int32 temp = (id);		      \
     afs_int32 flag = (id) < 0 ? PRGRP : 0; \
+    char tname[PR_MAXNAMELEN]; \
+    if (strlcpy(tname, (name), sizeof(tname)) >= sizeof(tname)) { \
+	code = PRBADNAM; \
+	afs_com_err (whoami, code, "name too long %s", (name)); \
+	ubik_AbortTrans(tt);	      \
+	return code;		      \
+    } \
     code = CreateEntry		      \
-	(tt, (name), &temp, /*idflag*/1, flag, SYSADMINID, SYSADMINID); \
+	(tt, tname, &temp, /*idflag*/1, flag, SYSADMINID, SYSADMINID); \
     if (code) {			      \
 	afs_com_err (whoami, code, "couldn't create %s with id %di.", 	\
 		 (name), (id));	      \
diff --git a/src/ptserver/testpt.c b/src/ptserver/testpt.c
index eaaee48f1..c359f8f46 100644
--- a/src/ptserver/testpt.c
+++ b/src/ptserver/testpt.c
@@ -217,7 +217,7 @@ void
 CreateUser(int u)
 {
     afs_int32 code;
-    char name[16];
+    prname name;
     afs_int32 id;
 
     sprintf(name, "%s%d", createPrefix, u);
diff --git a/src/rx/UKERNEL/rx_knet.c b/src/rx/UKERNEL/rx_knet.c
index 7e14cf3f8..07046c149 100644
--- a/src/rx/UKERNEL/rx_knet.c
+++ b/src/rx/UKERNEL/rx_knet.c
@@ -227,7 +227,7 @@ rxk_InitializeSocket(void)
     len = sizeof(struct sockaddr_in);
     rc = getsockname(sock, (struct sockaddr *)&lcladdr, &len);
     usr_assert(rc >= 0);
-#ifdef AFS_USR_LINUX22_ENV
+#ifdef AFS_USR_LINUX_ENV
     optval0 = 131070;
 #else
     optval0 = 131072;
@@ -240,7 +240,7 @@ rxk_InitializeSocket(void)
     rc = getsockopt(sock, SOL_SOCKET, SO_SNDBUF, (void *)&optval, &optlen);
     usr_assert(rc == 0);
     /* usr_assert(optval == optval0); */
-#ifdef AFS_USR_LINUX22_ENV
+#ifdef AFS_USR_LINUX_ENV
     optval0 = 131070;
 #else
     optval0 = 131072;
diff --git a/src/rx/rx.c b/src/rx/rx.c
index 4931f735a..bb3b44561 100644
--- a/src/rx/rx.c
+++ b/src/rx/rx.c
@@ -19,7 +19,7 @@
 #  include "h/types.h"
 #  include "h/time.h"
 #  include "h/stat.h"
-#  ifdef AFS_LINUX20_ENV
+#  ifdef AFS_LINUX_ENV
 #   include "h/socket.h"
 #  endif
 #  include "netinet/in.h"
@@ -481,7 +481,7 @@ int
 rx_InitHost(u_int host, u_int port)
 {
 #ifdef KERNEL
-    osi_timeval_t tv;
+    osi_timeval32_t tv;
 #else /* KERNEL */
     struct timeval tv;
 #endif /* KERNEL */
diff --git a/src/rx/rx_atomic.h b/src/rx/rx_atomic.h
index 72ee054d4..29790411d 100644
--- a/src/rx/rx_atomic.h
+++ b/src/rx/rx_atomic.h
@@ -206,7 +206,7 @@ static_inline void
 rx_atomic_sub(rx_atomic_t *atomic, int change) {
     OSAtomicAdd32(0 - change, &atomic->var);
 }
-#elif defined(AFS_LINUX26_ENV) && defined(KERNEL)
+#elif defined(AFS_LINUX_ENV) && defined(KERNEL)
 #include <asm/atomic.h>
 
 typedef atomic_t rx_atomic_t;
diff --git a/src/rx/rx_clock.h b/src/rx/rx_clock.h
index e487b3066..a836fab57 100644
--- a/src/rx/rx_clock.h
+++ b/src/rx/rx_clock.h
@@ -94,21 +94,14 @@ extern void clock_UpdateTime(void);
 #endif /* AFS_USE_GETTIMEOFDAY || AFS_PTHREAD_ENV */
 #else /* KERNEL */
 #define clock_Init()
-#if defined(AFS_SGI61_ENV) || defined(AFS_HPUX_ENV) || defined(AFS_LINUX_64BIT_KERNEL)
-#define clock_GetTime(cv) osi_GetTime((osi_timeval_t *)cv)
-#else
-#if (defined(AFS_AIX51_ENV) && defined(AFS_64BIT_KERNEL)) || (defined(AFS_DARWIN100_ENV) && defined(__amd64__)) || defined(AFS_XBSD_ENV)
-#define        clock_GetTime(cv)                               \
-    BEGIN                                              \
-       struct timeval tv;                              \
-       osi_GetTime(&tv);                        \
-       (cv)->sec = (afs_int32)tv.tv_sec;               \
-       (cv)->usec = (afs_int32)tv.tv_usec;             \
-    END
-#else /* defined(AFS_AIX51_ENV) && defined(AFS_64BIT_KERNEL) */
-#define clock_GetTime(cv) osi_GetTime((osi_timeval_t *)(cv))
-#endif /* defined(AFS_AIX51_ENV) && defined(AFS_64BIT_KERNEL) */
-#endif
+static_inline void
+clock_GetTime(struct clock *cv)
+{
+    osi_timeval32_t now;
+    osi_GetTime(&now);
+    cv->sec = now.tv_sec;
+    cv->usec = now.tv_usec;
+}
 #define clock_Sec() osi_Time()
 #define	clock_NewTime()		/* don't do anything; clock is fast enough in kernel */
 #endif /* KERNEL */
diff --git a/src/rx/rx_internal.h b/src/rx/rx_internal.h
index 274d981c2..2eafc91c1 100644
--- a/src/rx/rx_internal.h
+++ b/src/rx/rx_internal.h
@@ -6,7 +6,7 @@
  */
 
 #ifdef AFS_RXERRQ_ENV
-# if defined(AFS_LINUX26_ENV) || defined(AFS_USR_LINUX26_ENV)
+# if defined(AFS_LINUX_ENV) || defined(AFS_USR_LINUX_ENV)
 #  include <linux/types.h>
 #  include <linux/errqueue.h>
 #  include <linux/icmp.h>
diff --git a/src/rx/rx_kcommon.c b/src/rx/rx_kcommon.c
index 0b2000dc0..688c81d42 100644
--- a/src/rx/rx_kcommon.c
+++ b/src/rx/rx_kcommon.c
@@ -197,7 +197,7 @@ osi_utoa(char *buf, size_t len, unsigned long val)
     return 0;
 }
 
-#ifndef AFS_LINUX26_ENV
+#ifndef AFS_LINUX_ENV
 /*
  * osi_AssertFailK() -- used by the osi_Assert() macro.
  *
@@ -250,7 +250,7 @@ osi_AssertFailK(const char *expr, const char *file, int line)
 
     osi_Panic("%s", buf);
 }
-#endif /* !AFS_LINUX26_ENV */
+#endif /* !AFS_LINUX_ENV */
 
 #ifndef UKERNEL
 /* This is the server process request loop. Kernel server
@@ -464,7 +464,7 @@ rxi_InitPeerParams(struct rx_peer *pp)
  */
 
 
-#if ! defined(AFS_AIX_ENV) && ! defined(AFS_SUN5_ENV) && ! defined(UKERNEL) && ! defined(AFS_LINUX20_ENV) && !defined (AFS_DARWIN_ENV) && !defined (AFS_XBSD_ENV)
+#if ! defined(AFS_AIX_ENV) && ! defined(AFS_SUN5_ENV) && ! defined(UKERNEL) && ! defined(AFS_LINUX_ENV) && !defined (AFS_DARWIN_ENV) && !defined (AFS_XBSD_ENV)
 /* Routine called during the afsd "-shutdown" process to put things back to
  * the initial state.
  */
@@ -824,7 +824,7 @@ rxi_FindIfnet(afs_uint32 addr, afs_uint32 * maskp)
  * most of it is simple to follow common code.
  */
 #if !defined(UKERNEL)
-# if !defined(AFS_SUN5_ENV) && !defined(AFS_LINUX20_ENV) && !defined(AFS_SOCKPROXY_ENV)
+# if !defined(AFS_SUN5_ENV) && !defined(AFS_LINUX_ENV) && !defined(AFS_SOCKPROXY_ENV)
 /* rxk_NewSocket creates a new socket on the specified port. The port is
  * in network byte order.
  */
@@ -1044,7 +1044,7 @@ rxk_FreeSocket(struct socket *asocket)
 #  endif
     return 0;
 }
-# endif /* !SUN5 && !LINUX20 && !AFS_SOCKPROXY_ENV */
+# endif /* !AFS_SUN5_ENV && !AFS_LINUX_ENV && !AFS_SOCKPROXY_ENV */
 
 # if defined(RXK_LISTENER_ENV) || defined(AFS_SUN5_ENV) || defined(RXK_UPCALL_ENV)
 #  ifdef RXK_TIMEDSLEEP_ENV
@@ -1218,7 +1218,7 @@ rxk_ReadPacket(osi_socket so, struct rx_packet *p, int *host, int *port)
  * OS's socket receive routine returns as a result of a signal.
  */
 int rxk_ListenerPid;		/* Used to signal process to wakeup at shutdown */
-#  ifdef AFS_LINUX20_ENV
+#  ifdef AFS_LINUX_ENV
 struct task_struct *rxk_ListenerTask;
 #  endif
 
@@ -1229,7 +1229,7 @@ rxk_Listener(void)
     int code;
     int host, port;
 
-#  ifdef AFS_LINUX20_ENV
+#  ifdef AFS_LINUX_ENV
     rxk_ListenerPid = current->pid;
     rxk_ListenerTask = current;
     allow_signal(SIGKILL);    /* Allowed, but blocked until shutdown */
@@ -1276,7 +1276,7 @@ rxk_Listener(void)
 	osi_rxWakeup(&afs_termState);
     }
     rxk_ListenerPid = 0;
-#  ifdef AFS_LINUX20_ENV
+#  ifdef AFS_LINUX_ENV
     rxk_ListenerTask = 0;
     osi_rxWakeup(&rxk_ListenerTask);
 #  endif
@@ -1285,7 +1285,7 @@ rxk_Listener(void)
 #  endif
 }
 
-#  if !defined(AFS_LINUX20_ENV) && !defined(AFS_SUN5_ENV) && !defined(AFS_DARWIN_ENV) && !defined(AFS_XBSD_ENV)
+#  if !defined(AFS_LINUX_ENV) && !defined(AFS_SUN5_ENV) && !defined(AFS_DARWIN_ENV) && !defined(AFS_XBSD_ENV)
 /* The manner of stopping the rx listener thread may vary. Most unix's should
  * be able to call soclose.
  */
@@ -1303,7 +1303,7 @@ osi_Msg(const char *fmt, ...)
 {
     va_list ap;
     va_start(ap, fmt);
-#if defined(AFS_LINUX26_ENV)
+#if defined(AFS_LINUX_ENV)
     vprintk(fmt, ap);
 #else
     vprintf(fmt, ap);
@@ -1311,7 +1311,7 @@ osi_Msg(const char *fmt, ...)
     va_end(ap);
 }
 
-#if !defined(AFS_LINUX26_ENV)
+#if !defined(AFS_LINUX_ENV)
 void
 # if defined(AFS_AIX_ENV)
 osi_Panic(char *msg, void *a1, void *a2, void *a3)
@@ -1340,7 +1340,7 @@ osi_Panic(char *msg, ...)
 	icmn_err(CE_PANIC, msg, ap);
 	va_end(ap);
     }
-# elif defined(AFS_DARWIN80_ENV) || defined(AFS_LINUX22_ENV) || defined(AFS_FBSD_ENV) || defined(UKERNEL)
+# elif defined(AFS_DARWIN80_ENV) || defined(AFS_LINUX_ENV) || defined(AFS_FBSD_ENV) || defined(UKERNEL)
     char buf[256];
     va_list ap;
     if (!msg)
@@ -1351,7 +1351,7 @@ osi_Panic(char *msg, ...)
     va_end(ap);
     printf("%s", buf);
     panic("%s", buf);
-# else /* DARWIN80 || LINUX22 || FBSD || UKERNEL */
+# else /* DARWIN80 || LINUX || FBSD || UKERNEL */
     va_list ap;
     if (!msg)
 	msg = "Unknown AFS panic";
@@ -1359,12 +1359,12 @@ osi_Panic(char *msg, ...)
     va_start(ap, msg);
     vprintf(msg, ap);
     va_end(ap);
-#  ifdef AFS_LINUX20_ENV
+#  ifdef AFS_LINUX_ENV
     * ((char *) 0) = 0;
 #  else
     panic("%s", msg);
 #  endif
-# endif /* else DARWIN80 || LINUX22 || FBSD || UKERNEL */
+# endif /* else DARWIN80 || LINUX || FBSD || UKERNEL */
 }
 
-#endif /* !AFS_LINUX26_ENV */
+#endif /* !AFS_LINUX_ENV */
diff --git a/src/rx/rx_kcommon.h b/src/rx/rx_kcommon.h
index d4d423a7f..9f0d89d55 100644
--- a/src/rx/rx_kcommon.h
+++ b/src/rx/rx_kcommon.h
@@ -18,7 +18,7 @@
 #ifndef _RX_KCOMMON_H_
 #define _RX_KCOMMON_H_
 
-#ifdef AFS_LINUX22_ENV
+#ifdef AFS_LINUX_ENV
 #ifndef _LINUX_CODA_FS_I
 #define _LINUX_CODA_FS_I 1
 #define _CODA_HEADER_ 1
@@ -29,10 +29,10 @@ struct coda_inode_info {
 
 
 #include "h/types.h"
-#if !defined(AFS_LINUX26_ENV)
+#if !defined(AFS_LINUX_ENV)
 #include "h/param.h"
 #endif
-#ifndef AFS_LINUX22_ENV
+#ifndef AFS_LINUX_ENV
 #include "h/systm.h"
 #endif
 #include "h/time.h"
@@ -43,7 +43,7 @@ struct coda_inode_info {
 #include "h/disp.h"
 #endif
 #include "h/socket.h"
-#if !defined(AFS_LINUX22_ENV) && !defined(AFS_OBSD_ENV)
+#if !defined(AFS_LINUX_ENV) && !defined(AFS_OBSD_ENV)
 #include "h/socketvar.h"
 #if !defined(AFS_SUN5_ENV) && !defined(AFS_XBSD_ENV)
 #include "h/domain.h"
@@ -68,7 +68,7 @@ struct coda_inode_info {
 #include "h/mbuf.h"
 #endif
 #endif /* !defined(AFS_SUN5_ENV) && !defined(AFS_XBSD_ENV) */
-#endif /* !defined(AFS_LINUX22_ENV) && !defined(AFS_OBSD_ENV) */
+#endif /* !defined(AFS_LINUX_ENV) && !defined(AFS_OBSD_ENV) */
 #ifdef AFS_SGI62_ENV
 #include "h/hashing.h"
 #endif
@@ -83,32 +83,32 @@ struct coda_inode_info {
 #include "h/signalvar.h"
 #endif /* AFS_OBSD_ENV */
 #include "netinet/in.h"
-#ifdef AFS_LINUX22_ENV
+#ifdef AFS_LINUX_ENV
 #include "linux/route.h"
 #else
 #include "net/route.h"
 #endif
-#if defined(HAVE_IN_SYSTM_H) || !defined(AFS_LINUX22_ENV)
+#if defined(HAVE_IN_SYSTM_H) || !defined(AFS_LINUX_ENV)
 #include "netinet/in_systm.h"
 #endif
 #include "netinet/ip.h"
-#if !defined(AFS_HPUX110_ENV) && !defined(AFS_LINUX22_ENV) && !defined(AFS_DARWIN_ENV) && !defined(AFS_OBSD_ENV)
+#if !defined(AFS_HPUX110_ENV) && !defined(AFS_LINUX_ENV) && !defined(AFS_DARWIN_ENV) && !defined(AFS_OBSD_ENV)
 #include "netinet/in_pcb.h"
-#endif /* ! AFS_HPUX110_ENV && ! AFS_LINUX22_ENV */
-#ifndef AFS_LINUX22_ENV
+#endif /* ! AFS_HPUX110_ENV && ! AFS_LINUX_ENV */
+#ifndef AFS_LINUX_ENV
 #if !defined(AFS_DARWIN_ENV)
 #include "netinet/ip_var.h"
 #endif
 #include "netinet/ip_icmp.h"
-#endif /* AFS_LINUX22_ENV */
+#endif /* AFS_LINUX_ENV */
 #include "netinet/udp.h"
-#if !defined(AFS_SGI62_ENV) && !defined(AFS_LINUX22_ENV) && !defined(AFS_DARWIN_ENV)
+#if !defined(AFS_SGI62_ENV) && !defined(AFS_LINUX_ENV) && !defined(AFS_DARWIN_ENV)
 #include "netinet/udp_var.h"
 #endif
 #if defined(AFS_HPUX102_ENV) || (defined(AFS_SGI62_ENV) && !defined(AFS_SGI64_ENV))
 #include "h/user.h"
 #endif
-#ifdef AFS_LINUX22_ENV
+#ifdef AFS_LINUX_ENV
 #include "h/sched.h"
 #include "h/netdevice.h"
 #include "linux/if.h"
@@ -124,9 +124,9 @@ struct coda_inode_info {
 #  include <net/if_var.h>
 # endif
 #endif
-#if !defined(AFS_HPUX110_ENV) && !defined(AFS_LINUX22_ENV) && !defined(AFS_DARWIN_ENV)
+#if !defined(AFS_HPUX110_ENV) && !defined(AFS_LINUX_ENV) && !defined(AFS_DARWIN_ENV)
 #include "netinet/in_var.h"
-#endif /* ! AFS_HPUX110_ENV && ! AFS_LINUX22_ENV */
+#endif /* ! AFS_HPUX110_ENV && ! AFS_LINUX_ENV */
 #include "afs/afs_osi.h"
 #include "rx_kmutex.h"
 #include "afs/lock.h"
diff --git a/src/rx/rx_kernel.h b/src/rx/rx_kernel.h
index 6f10ba469..6b96ff3fe 100644
--- a/src/rx/rx_kernel.h
+++ b/src/rx/rx_kernel.h
@@ -37,7 +37,7 @@ typedef struct socket *osi_socket;
 
 extern int osi_utoa(char *buf, size_t len, unsigned long val);
 
-#if defined(AFS_LINUX26_ENV)
+#if defined(AFS_LINUX_ENV)
 # define osi_Panic(msg...) \
     do { printk(KERN_CRIT "openafs: " msg); BUG(); } while (0)
 # define osi_Assert(expr) \
diff --git a/src/rx/rx_lwp.c b/src/rx/rx_lwp.c
index bc6ae663c..96965db67 100644
--- a/src/rx/rx_lwp.c
+++ b/src/rx/rx_lwp.c
@@ -451,7 +451,7 @@ rxi_Sendmsg(osi_socket socket, struct msghdr *msg_p, int flags)
 	}
 #ifdef AFS_NT40_ENV
 	if (err)
-#elif defined(AFS_LINUX22_ENV)
+#elif defined(AFS_LINUX_ENV)
 	/* linux unfortunately returns ECONNREFUSED if the target port
 	 * is no longer in use */
 	/* and EAGAIN if a UDP checksum is incorrect */
diff --git a/src/rx/rx_multi.c b/src/rx/rx_multi.c
index 85cca413b..7c7976762 100644
--- a/src/rx/rx_multi.c
+++ b/src/rx/rx_multi.c
@@ -121,20 +121,9 @@ multi_Finalize(struct multi_handle *mh)
     osi_Free(mh, sizeof(struct multi_handle));
 }
 
-/* ignores all remaining multiRx calls */
+/* Deprecated; use multi_Finalize() instead. */
 void
 multi_Finalize_Ignore(struct multi_handle *mh)
 {
-    int i;
-    int nCalls = mh->nConns;
-    for (i = 0; i < nCalls; i++) {
-	struct rx_call *call = mh->calls[i];
-	if (call)
-	    rx_EndCall(call, 0);
-    }
-    MUTEX_DESTROY(&mh->lock);
-    CV_DESTROY(&mh->cv);
-    osi_Free(mh->calls, sizeof(struct rx_call *) * nCalls);
-    osi_Free(mh->ready, sizeof(short) * nCalls);
-    osi_Free(mh, sizeof(struct multi_handle));
+    multi_Finalize(mh);
 }
diff --git a/src/rx/rx_multi.h b/src/rx/rx_multi.h
index de67ae33c..80bf1ecc9 100644
--- a/src/rx/rx_multi.h
+++ b/src/rx/rx_multi.h
@@ -54,9 +54,7 @@ struct multi_handle {
 	multi_Finalize(multi_h);\
     } while (0)
 
-/* Ignore remaining multi RPC's */
-#define multi_End_Ignore\
-	multi_Finalize_Ignore(multi_h);\
-    } while (0)
+/* Deprecated; use multi_End instead. */
+#define multi_End_Ignore multi_End
 
 #endif /* _RX_MULTI_     End of rx_multi.h */
diff --git a/src/rx/rx_packet.c b/src/rx/rx_packet.c
index 61a535111..2cefeee21 100644
--- a/src/rx/rx_packet.c
+++ b/src/rx/rx_packet.c
@@ -20,7 +20,7 @@
 #   include "rx_kcommon.h"
 #  endif
 #  include "h/types.h"
-#  ifndef AFS_LINUX20_ENV
+#  ifndef AFS_LINUX_ENV
 #   include "h/systm.h"
 #  endif
 #  if defined(AFS_SGI_ENV) || defined(AFS_HPUX110_ENV) || defined(AFS_NBSD50_ENV)
@@ -30,7 +30,7 @@
 #   include "h/proc.h"
 #  endif
 #  include "h/socket.h"
-#  if !defined(AFS_SUN5_ENV) &&  !defined(AFS_LINUX20_ENV) && !defined(AFS_HPUX110_ENV)
+#  if !defined(AFS_SUN5_ENV) &&  !defined(AFS_LINUX_ENV) && !defined(AFS_HPUX110_ENV)
 #   if	!defined(AFS_AIX41_ENV)
 #    include "sys/mount.h"		/* it gets pulled in by something later anyway */
 #   endif
@@ -1691,7 +1691,7 @@ cpytoiovec(mblk_t * mp, int off, int len, struct iovec *iovs,
 #define m_cpytoc(a, b, c, d)  cpytoc(a, b, c, d)
 #define m_cpytoiovec(a, b, c, d, e) cpytoiovec(a, b, c, d, e)
 #else
-#if !defined(AFS_LINUX20_ENV) && !defined(AFS_DARWIN80_ENV)
+#if !defined(AFS_LINUX_ENV) && !defined(AFS_DARWIN80_ENV)
 static int
 m_cpytoiovec(struct mbuf *m, int off, int len, struct iovec iovs[], int niovs)
 {
@@ -1744,10 +1744,10 @@ m_cpytoiovec(struct mbuf *m, int off, int len, struct iovec iovs[], int niovs)
 
     return len;
 }
-#endif /* LINUX */
+#endif /* !AFS_LINUX_ENV && !AFS_DARWIN80_ENV */
 #endif /* AFS_SUN5_ENV */
 
-#if !defined(AFS_LINUX20_ENV) && !defined(AFS_DARWIN80_ENV)
+#if !defined(AFS_LINUX_ENV) && !defined(AFS_DARWIN80_ENV)
 #if defined(AFS_NBSD_ENV)
 int
 rx_mb_to_packet(struct mbuf *amb, void (*free) (struct mbuf *), int hdr_len, int data_len, struct rx_packet *phandle)
@@ -2192,7 +2192,7 @@ rxi_NetSendError(struct rx_call *call, int code)
     if (code == -WSAEHOSTUNREACH) {
 	down = 1;
     }
-#elif defined(AFS_LINUX20_ENV)
+#elif defined(AFS_LINUX_ENV)
     if (code == -ENETUNREACH) {
 	down = 1;
     }
diff --git a/src/rx/rx_packet.h b/src/rx/rx_packet.h
index 94269df7a..46c07895d 100644
--- a/src/rx/rx_packet.h
+++ b/src/rx/rx_packet.h
@@ -42,12 +42,12 @@
 #else /* AFS_NT40_ENV */
 # if !defined(AFS_DARWIN_ENV) && !defined(AFS_USR_DARWIN_ENV)   \
     && !defined(AFS_XBSD_ENV) && !defined(AFS_USR_FBSD_ENV)     \
-    && !defined(AFS_USR_DFBSD_ENV) && !defined(AFS_LINUX20_ENV)
+    && !defined(AFS_USR_DFBSD_ENV) && !defined(AFS_LINUX_ENV)
 #  include <sys/sysmacros.h>	/* MIN, MAX on most commercial UNIX */
 # endif
 /* Linux 3.7 doesn't have sys/param.h in kernel space, and afs/param.h ensures
  * that MIN and MAX are available for kernel builds. */
-# if !(defined(AFS_LINUX26_ENV) && defined(KERNEL))
+# if !(defined(AFS_LINUX_ENV) && defined(KERNEL))
 #  include <sys/param.h>	/* MIN, MAX elsewhere */
 # endif
 #endif /* !AFS_NT40_ENV */
diff --git a/src/rx/rx_prototypes.h b/src/rx/rx_prototypes.h
index d33d235eb..190bb5876 100644
--- a/src/rx/rx_prototypes.h
+++ b/src/rx/rx_prototypes.h
@@ -188,9 +188,6 @@ extern int clock_UnInit(void);
 #if !defined(clock_UpdateTime)
 extern void clock_UpdateTime(void);
 #endif
-#if defined(UKERNEL) && !defined(osi_GetTime)
-extern int osi_GetTime(struct timeval *tv);
-#endif
 
 /* rx_clock_nt.c */
 
@@ -274,7 +271,7 @@ extern int rxk_ReadPacket(osi_socket so, struct rx_packet *p, int *host,
 # ifdef UKERNEL
 extern void *rx_ServerProc(void *);
 # endif
-# ifndef AFS_LINUX26_ENV
+# ifndef AFS_LINUX_ENV
 extern void osi_AssertFailK(const char *expr, const char *file, int line) AFS_NORETURN;
 # endif
 extern void rxk_ListenerProc(void);
@@ -286,7 +283,7 @@ extern rx_ifnet_t rxi_FindIfnet(afs_uint32 addr, afs_uint32 * maskp);
 extern void osi_StopListener(void);
 
 /* ARCH/rx_kmutex.c */
-# if defined(AFS_LINUX20_ENV)
+# if defined(AFS_LINUX_ENV)
 extern void afs_mutex_init(afs_kmutex_t * l);
 extern void afs_mutex_enter(afs_kmutex_t * l);
 extern int afs_mutex_tryenter(afs_kmutex_t * l);
diff --git a/src/rx/rx_pthread.c b/src/rx/rx_pthread.c
index 57f1edb4e..64240b50d 100644
--- a/src/rx/rx_pthread.c
+++ b/src/rx/rx_pthread.c
@@ -418,7 +418,7 @@ rxi_Sendmsg(osi_socket socket, struct msghdr *msg_p, int flags)
 #endif
 
 #ifndef AFS_RXERRQ_ENV
-# ifdef AFS_LINUX22_ENV
+# ifdef AFS_LINUX_ENV
     /* linux unfortunately returns ECONNREFUSED if the target port
      * is no longer in use */
     /* and EAGAIN if a UDP checksum is incorrect */
diff --git a/src/rx/rx_rdwr.c b/src/rx/rx_rdwr.c
index e2721d384..ee1c3e3d4 100644
--- a/src/rx/rx_rdwr.c
+++ b/src/rx/rx_rdwr.c
@@ -24,7 +24,7 @@
 #   if defined(AFS_AIX_ENV) || defined(AFS_AUX_ENV) || defined(AFS_SUN5_ENV)
 #    include "h/systm.h"
 #   endif
-#   ifdef AFS_LINUX20_ENV
+#   ifdef AFS_LINUX_ENV
 #    include "h/socket.h"
 #   endif
 #   include "netinet/in.h"
diff --git a/src/rx/rx_trace.c b/src/rx/rx_trace.c
index 59cc646a2..512491e7c 100644
--- a/src/rx/rx_trace.c
+++ b/src/rx/rx_trace.c
@@ -122,6 +122,8 @@ rxi_calltrace(unsigned int event, struct rx_call *call)
 
     case RX_CALL_ARRIVAL:
 	call->traceWait = now;
+	break;
+
     default:
 	break;
     }
diff --git a/src/rx/rx_user.c b/src/rx/rx_user.c
index 04e154234..15695265e 100644
--- a/src/rx/rx_user.c
+++ b/src/rx/rx_user.c
@@ -36,7 +36,7 @@
 #define IPPORT_USERRESERVED 5000
 # endif
 
-#if defined(AFS_LINUX22_ENV) && defined(AFS_RXERRQ_ENV)
+#if defined(AFS_LINUX_ENV) && defined(AFS_RXERRQ_ENV)
 # include <linux/types.h>
 # include <linux/errqueue.h>
 # if defined(AFS_ADAPT_PMTU) && !defined(IP_MTU)
@@ -94,7 +94,7 @@ rxi_GetHostUDPSocket(u_int ahost, u_short port)
     osi_socket socketFd = OSI_NULLSOCKET;
     struct sockaddr_in taddr;
     char *name = "rxi_GetUDPSocket: ";
-#ifdef AFS_LINUX22_ENV
+#ifdef AFS_LINUX_ENV
 # if defined(AFS_ADAPT_PMTU)
     int pmtu = IP_PMTUDISC_WANT;
 # else
@@ -197,7 +197,7 @@ rxi_GetHostUDPSocket(u_int ahost, u_short port)
             rx_atomic_set(&rx_stats.socketGreedy, greedy);
     }
 
-#ifdef AFS_LINUX22_ENV
+#ifdef AFS_LINUX_ENV
     setsockopt(socketFd, SOL_IP, IP_MTU_DISCOVER, &pmtu, sizeof(pmtu));
 #endif
 #ifdef AFS_RXERRQ_ENV
@@ -445,7 +445,7 @@ fudge_netmask(afs_uint32 addr)
 
 
 
-#if !defined(AFS_AIX_ENV) && !defined(AFS_NT40_ENV) && !defined(AFS_LINUX20_ENV) && !defined(AFS_DARWIN160_ENV)
+#if !defined(AFS_AIX_ENV) && !defined(AFS_NT40_ENV) && !defined(AFS_LINUX_ENV) && !defined(AFS_DARWIN160_ENV)
 int
 rxi_syscall(afs_uint32 a3, afs_uint32 a4, void *a5)
 {
@@ -574,7 +574,7 @@ rx_GetIFInfo(void)
 	}
 #endif /* SIOCGIFFLAGS */
 
-#if !defined(AFS_AIX_ENV) && !defined(AFS_LINUX20_ENV) && !defined(AFS_DARWIN160_ENV)
+#if !defined(AFS_AIX_ENV) && !defined(AFS_LINUX_ENV) && !defined(AFS_DARWIN160_ENV)
 	/* this won't run on an AIX system w/o a cache manager */
 	rxi_syscallp = rxi_syscall;
 #endif
diff --git a/src/rx/test/testclient.c b/src/rx/test/testclient.c
index accd085ea..0ed74c625 100644
--- a/src/rx/test/testclient.c
+++ b/src/rx/test/testclient.c
@@ -57,7 +57,7 @@ quitSignal(int ignore)
 	rx_PrintStats(debugFile);
 }
 
-#if !defined(AFS_NT40_ENV) && !defined(AFS_LINUX20_ENV)
+#if !defined(AFS_NT40_ENV) && !defined(AFS_LINUX_ENV)
 int
 test_syscall(afs_uint32 a3, afs_uint32 a4, void *a5)
 {
@@ -91,7 +91,7 @@ main(int argc, char **argv)
     int setFD = 0;
     int jumbo = 0;
 
-#if !defined(AFS_NT40_ENV) && !defined(AFS_LINUX20_ENV)
+#if !defined(AFS_NT40_ENV) && !defined(AFS_LINUX_ENV)
     setlinebuf(stdout);
     rxi_syscallp = test_syscall;
 #endif
diff --git a/src/rx/test/testserver.c b/src/rx/test/testserver.c
index a84d206e1..deead4464 100644
--- a/src/rx/test/testserver.c
+++ b/src/rx/test/testserver.c
@@ -53,7 +53,7 @@ quitSignal(int ignore)
 	rx_PrintStats(debugFile);
 }
 
-#if !defined(AFS_NT40_ENV) && !defined(AFS_LINUX20_ENV)
+#if !defined(AFS_NT40_ENV) && !defined(AFS_LINUX_ENV)
 int
 test_syscall(a3, a4, a5)
      afs_uint32 a3, a4;
@@ -80,7 +80,7 @@ main(argc, argv)
     int setFD = 0;
     int jumbo = 0;
 
-#if !defined(AFS_NT40_ENV) && !defined(AFS_LINUX20_ENV)
+#if !defined(AFS_NT40_ENV) && !defined(AFS_LINUX_ENV)
     setlinebuf(stdout);
     rxi_syscallp = test_syscall;
 #endif
diff --git a/src/rx/xdr.c b/src/rx/xdr.c
index b1efad33e..7ef772d73 100644
--- a/src/rx/xdr.c
+++ b/src/rx/xdr.c
@@ -48,10 +48,10 @@
 #ifndef	NeXT
 
 #if defined(KERNEL) && !defined(UKERNEL)
-#if !defined(AFS_LINUX26_ENV)
+#if !defined(AFS_LINUX_ENV)
 #include <sys/param.h>
 #endif
-#ifndef AFS_LINUX20_ENV
+#ifndef AFS_LINUX_ENV
 #include <sys/systm.h>
 #endif
 #endif
@@ -424,7 +424,7 @@ xdr_bytes(XDR * xdrs, char **cpp, u_int * sizep,
 	if (sp == NULL) {
 	    return (FALSE);
 	}
-	/* fall through */
+	AFS_FALLTHROUGH;
 
     case XDR_ENCODE:
 	return (xdr_opaque(xdrs, sp, nodesize));
@@ -519,7 +519,7 @@ xdr_string(XDR * xdrs, char **cpp, u_int maxsize)
 	if (sp == NULL) {
 	    return (TRUE);	/* already free */
 	}
-	/* Fall through */
+	AFS_FALLTHROUGH;
     case XDR_ENCODE:
 	size = strlen(sp);
 	break;
@@ -547,7 +547,7 @@ xdr_string(XDR * xdrs, char **cpp, u_int maxsize)
 	    return (FALSE);
 	}
 	sp[size] = 0;
-	/* fall through */
+	AFS_FALLTHROUGH;
 
     case XDR_ENCODE:
 	return (xdr_opaque(xdrs, sp, size));
@@ -591,7 +591,7 @@ xdr_free(xdrproc_t proc, void *obj)
     x.x_op = XDR_FREE;
 
     /* See note in xdr.h for the method behind this madness */
-#if defined(AFS_I386_LINUX26_ENV) && defined(KERNEL) && !defined(UKERNEL)
+#if defined(AFS_I386_LINUX_ENV) && defined(KERNEL) && !defined(UKERNEL)
     (*proc)(&x, obj, 0);
 #else
     (*proc)(&x, obj);
diff --git a/src/rx/xdr.h b/src/rx/xdr.h
index 61df7a119..2567372f9 100644
--- a/src/rx/xdr.h
+++ b/src/rx/xdr.h
@@ -185,7 +185,7 @@ enum xdr_op {
  * normal va_args prototype results in the arguments being placed on the
  * stack, where they aren't accessible to the 'real' function.
  */
-#if defined(AFS_I386_LINUX26_ENV) && defined(KERNEL) && !defined(UKERNEL)
+#if defined(AFS_I386_LINUX_ENV) && defined(KERNEL) && !defined(UKERNEL)
 typedef bool_t(*xdrproc_t) (void *, caddr_t, u_int);
 #else
 typedef bool_t(*xdrproc_t) (void *, ...);
diff --git a/src/rx/xdr_afsuuid.c b/src/rx/xdr_afsuuid.c
index da7855a1f..dadfcf6e5 100644
--- a/src/rx/xdr_afsuuid.c
+++ b/src/rx/xdr_afsuuid.c
@@ -15,7 +15,7 @@
 #include <afs/param.h>
 
 #if defined(KERNEL) && !defined(UKERNEL)
-#ifdef AFS_LINUX20_ENV
+#ifdef AFS_LINUX_ENV
 #include "h/string.h"
 #else
 #include <sys/param.h>
diff --git a/src/rx/xdr_array.c b/src/rx/xdr_array.c
index 75bcd7c15..178501992 100644
--- a/src/rx/xdr_array.c
+++ b/src/rx/xdr_array.c
@@ -47,16 +47,16 @@
  */
 
 #if defined(KERNEL) && !defined(UKERNEL)
-#if !defined(AFS_LINUX26_ENV)
+#if !defined(AFS_LINUX_ENV)
 #include <sys/param.h>
 #endif
-#ifdef AFS_LINUX20_ENV
+#ifdef AFS_LINUX_ENV
 #include "h/string.h"
 #else
 #ifndef AFS_DARWIN90_ENV
 #include <sys/systm.h>
 #endif
-#endif /* AFS_LINUX20_ENV */
+#endif /* AFS_LINUX_ENV */
 #endif
 #include "xdr.h"
 
diff --git a/src/rx/xdr_arrayn.c b/src/rx/xdr_arrayn.c
index 2a2e0811d..d6cb1f7d1 100644
--- a/src/rx/xdr_arrayn.c
+++ b/src/rx/xdr_arrayn.c
@@ -47,10 +47,10 @@
  */
 
 #if defined(KERNEL) && !defined(UKERNEL)
-#if !defined(AFS_LINUX26_ENV)
+#if !defined(AFS_LINUX_ENV)
 #include <sys/param.h>
 #endif
-#ifdef AFS_LINUX20_ENV
+#ifdef AFS_LINUX_ENV
 #include "h/string.h"
 #else
 #include <sys/systm.h>
diff --git a/src/rx/xdr_int32.c b/src/rx/xdr_int32.c
index 63bf09aca..cc87a8117 100644
--- a/src/rx/xdr_int32.c
+++ b/src/rx/xdr_int32.c
@@ -34,7 +34,7 @@
 #ifndef	NeXT
 
 #if defined(KERNEL) && !defined(UKERNEL)
-# if !defined(AFS_LINUX26_ENV)
+# if !defined(AFS_LINUX_ENV)
 #  include <sys/param.h>
 # endif
 #else
diff --git a/src/rx/xdr_int64.c b/src/rx/xdr_int64.c
index c1925ed70..d2b1e6b50 100644
--- a/src/rx/xdr_int64.c
+++ b/src/rx/xdr_int64.c
@@ -8,7 +8,7 @@
 
 
 #if defined(KERNEL) && !defined(UKERNEL)
-#ifdef AFS_LINUX20_ENV
+#ifdef AFS_LINUX_ENV
 #include "h/string.h"
 #else
 #include <sys/param.h>
diff --git a/src/rx/xdr_rx.c b/src/rx/xdr_rx.c
index 9a7aba999..62fbed331 100644
--- a/src/rx/xdr_rx.c
+++ b/src/rx/xdr_rx.c
@@ -19,10 +19,8 @@
 # ifndef UKERNEL
 #  include "h/types.h"
 #  include "h/uio.h"
-#  ifdef AFS_LINUX20_ENV
+#  ifdef AFS_LINUX_ENV
 #   include "h/socket.h"
-#  endif
-#  ifdef AFS_LINUX22_ENV
 #   ifndef quad_t
 #    define quad_t __quad_t
 #    define u_quad_t __u_quad_t
diff --git a/src/rxgen/rpc_main.c b/src/rxgen/rpc_main.c
index 10aee6c0a..ecd2f4f15 100644
--- a/src/rxgen/rpc_main.c
+++ b/src/rxgen/rpc_main.c
@@ -455,7 +455,7 @@ h_output(char *infile, char *define, int extend, char *outfile, int append)
     f_print(fout, "#include \"h/socket.h\"\n");
     f_print(fout, "#endif\n");
     f_print(fout, "#ifndef	DTYPE_SOCKET  /* XXXXX */\n");
-    f_print(fout, "#ifndef AFS_LINUX22_ENV\n");
+    f_print(fout, "#ifndef AFS_LINUX_ENV\n");
     f_print(fout, "#include \"h/file.h\"\n");
     f_print(fout, "#endif\n");
     f_print(fout, "#endif\n");
@@ -472,7 +472,7 @@ h_output(char *infile, char *define, int extend, char *outfile, int append)
     f_print(fout, "#include \"h/time.h\"\n");
     f_print(fout, "#endif\n");
     f_print(fout, "#ifndef	XDR_GETLONG /* XXXXX */\n");
-    f_print(fout, "#ifdef AFS_LINUX22_ENV\n");
+    f_print(fout, "#ifdef AFS_LINUX_ENV\n");
     f_print(fout, "#ifndef quad_t\n");
     f_print(fout, "#define quad_t __quad_t\n");
     f_print(fout, "#define u_quad_t __u_quad_t\n");
diff --git a/src/rxkad/bg-fcrypt.c b/src/rxkad/bg-fcrypt.c
index c88dbd003..28b6bfe57 100644
--- a/src/rxkad/bg-fcrypt.c
+++ b/src/rxkad/bg-fcrypt.c
@@ -38,13 +38,13 @@
 #ifdef KERNEL
 #ifndef UKERNEL
 #include "h/types.h"
-#if !defined(AFS_LINUX20_ENV) && !defined(AFS_OBSD_ENV)
+#if !defined(AFS_LINUX_ENV) && !defined(AFS_OBSD_ENV)
 #include "netinet/in.h"
 #endif
 #else /* UKERNEL */
 #include "afs/sysincludes.h"
 #endif /* UKERNEL */
-#ifdef AFS_LINUX22_ENV
+#ifdef AFS_LINUX_ENV
 #include <asm/byteorder.h>
 #endif
 
diff --git a/src/rxkad/fcrypt.c b/src/rxkad/fcrypt.c
index 5488a0dd1..7108933c5 100644
--- a/src/rxkad/fcrypt.c
+++ b/src/rxkad/fcrypt.c
@@ -23,13 +23,13 @@
 #include "h/systm.h"
 #endif
 #include "h/types.h"
-#if !defined(AFS_LINUX20_ENV) && !defined(AFS_OBSD_ENV)
+#if !defined(AFS_LINUX_ENV) && !defined(AFS_OBSD_ENV)
 #include "netinet/in.h"
 #endif
 #else /* UKERNEL */
 #include "afs/sysincludes.h"
 #endif /* UKERNEL */
-#ifdef AFS_LINUX22_ENV
+#ifdef AFS_LINUX_ENV
 #include <asm/byteorder.h>
 #endif
 
diff --git a/src/rxkad/rxkad_client.c b/src/rxkad/rxkad_client.c
index 2f894253f..630488374 100644
--- a/src/rxkad/rxkad_client.c
+++ b/src/rxkad/rxkad_client.c
@@ -22,7 +22,7 @@
 #if defined(AFS_AIX_ENV) || defined(AFS_AUX_ENV) || defined(AFS_SUN5_ENV) || defined(AFS_XBSD_ENV)
 #include "h/systm.h"
 #endif
-#ifdef AFS_LINUX20_ENV
+#ifdef AFS_LINUX_ENV
 #include "h/socket.h"
 #endif
 #ifndef AFS_OBSD_ENV
diff --git a/src/rxkad/ticket5.c b/src/rxkad/ticket5.c
index 326e1b81c..3fd508208 100644
--- a/src/rxkad/ticket5.c
+++ b/src/rxkad/ticket5.c
@@ -749,7 +749,7 @@ tkt_DeriveDesKey(int enctype, void *keydata, size_t keylen,
     case ETYPE_DES3_CBC_SHA1:
 	if (compress_parity_bits(keydata, &keylen))
 	    return 1;
-	/* FALLTHROUGH */
+	AFS_FALLTHROUGH;
     default:
 	if (enctype < 0)
 	    return 1;
diff --git a/src/sys/afssyscalls.c b/src/sys/afssyscalls.c
index 8291a46c5..b248e6975 100644
--- a/src/sys/afssyscalls.c
+++ b/src/sys/afssyscalls.c
@@ -281,23 +281,16 @@ inode_write(afs_int32 dev, Inode inode, afs_int32 inode_p1,
 }
 
 
-/* PrintInode
+/**
+ * Format a string to print either 32 or 64 bit inode numbers.
  *
- * returns a static string used to print either 32 or 64 bit inode numbers.
+ * @param[out]  s    string buffer
+ * @param[in]   ino  inode number
+ * @returns pointer to formatted inode number string
  */
-#ifdef AFS_64BIT_IOPS_ENV
-char *
-PrintInode(char *s, Inode ino)
-#else
 char *
 PrintInode(afs_ino_str_t s, Inode ino)
-#endif
 {
-    static afs_ino_str_t result;
-
-    if (!s)
-	s = result;
-
 #ifdef AFS_64BIT_IOPS_ENV
     (void)sprintf((char *)s, "%llu", ino);
 #else
diff --git a/src/sys/afssyscalls.h b/src/sys/afssyscalls.h
index cd014d805..aa47d6d31 100644
--- a/src/sys/afssyscalls.h
+++ b/src/sys/afssyscalls.h
@@ -39,7 +39,7 @@ extern FILE *inode_debug_log;
 #endif
 
 /* Glue layer. */
-#ifdef AFS_LINUX20_ENV
+#ifdef AFS_LINUX_ENV
 int proc_afs_syscall(long syscall, long param1, long param2, long param3,
 		     long param4, int *rval);
 #endif
@@ -88,14 +88,9 @@ extern int afs_init_kernel_config(int flag);
 #define AFS_INO_STR_LENGTH 32
 typedef char afs_ino_str_t[AFS_INO_STR_LENGTH];
 
-/* Print either 32 or 64 bit inode numbers. char * may be NULL. In which case
- * a local statis is returned.
+/* Format either 32 or 64 bit inode numbers.
  */
-#ifdef AFS_64BIT_IOPS_ENV
-extern char *PrintInode(afs_ino_str_t, Inode);
-#else
-extern char *PrintInode();
-#endif
+extern char *PrintInode(afs_ino_str_t s, Inode ino) AFS_NONNULL((1));
 
 /* Some places in the code assume icreate can return 0 when there's
  * an error.
diff --git a/src/sys/glue.c b/src/sys/glue.c
index 356245975..a14314160 100644
--- a/src/sys/glue.c
+++ b/src/sys/glue.c
@@ -20,7 +20,7 @@
 
 #include "afssyscalls.h"
 
-#ifdef AFS_LINUX20_ENV
+#ifdef AFS_LINUX_ENV
 int proc_afs_syscall(long syscall, long param1, long param2, long param3,
 		     long param4, int *rval) {
   struct afsprocdata syscall_data;
diff --git a/src/sys/iopen.c b/src/sys/iopen.c
index 7c1a9614d..b9cd3d65b 100644
--- a/src/sys/iopen.c
+++ b/src/sys/iopen.c
@@ -37,6 +37,7 @@ main(argc, argv)
     int fd, n;
     struct stat status;
     Inode ino;
+    afs_ino_str_t inode_str;
 
     if (argc != 3)
 	Usage();
@@ -54,7 +55,7 @@ main(argc, argv)
     }
     printf("ino=%" AFS_INT64_FMT "\n", ino);
     printf("About to iopen(dev=(%d,%d), inode=%s, mode=%d\n",
-	   major(status.st_dev), minor(status.st_dev), PrintInode(NULL, ino),
+	   major(status.st_dev), minor(status.st_dev), PrintInode(inode_str, ino),
 	   O_RDONLY);
     fflush(stdout);
     fd = IOPEN(status.st_dev, ino, O_RDONLY);
diff --git a/src/sys/pioctl.c b/src/sys/pioctl.c
index f2f9138de..c71b14006 100644
--- a/src/sys/pioctl.c
+++ b/src/sys/pioctl.c
@@ -40,7 +40,7 @@ lpioctl(char *path, int cmd, void *cmarg, int follow)
     return (syscall(AFS_PIOCTL, path, cmd, cmarg, follow));
 }
 
-#elif defined(AFS_LINUX20_ENV)
+#elif defined(AFS_LINUX_ENV)
 
 int
 lpioctl(char *path, int cmd, void *cmarg, int follow)
diff --git a/src/sys/rmtsysnet.c b/src/sys/rmtsysnet.c
index 296145eeb..da6b3e64e 100644
--- a/src/sys/rmtsysnet.c
+++ b/src/sys/rmtsysnet.c
@@ -9,6 +9,7 @@
 
 #include <afsconfig.h>
 #include <afs/param.h>
+#include <afs/opr.h>
 
 #include <roken.h>
 
@@ -65,7 +66,7 @@ struct Acl *
 RParseAcl(char *astr)
 {
     int nplus, nminus, i, trights;
-    char tname[MAXNAME];
+    char tname[MAXNAME + 1] = "";
     struct AclEntry *first, *last, *tl;
     struct Acl *ta;
     sscanf(astr, "%d", &nplus);
@@ -80,7 +81,7 @@ RParseAcl(char *astr)
     last = 0;
     first = 0;
     for (i = 0; i < nplus; i++) {
-	sscanf(astr, "%100s %d", tname, &trights);
+	sscanf(astr, "%" opr_stringize(MAXNAME) "s %d", tname, &trights);
 	astr = RSkipLine(astr);
 	tl = malloc(sizeof(struct AclEntry));
 	if (!first)
@@ -97,7 +98,7 @@ RParseAcl(char *astr)
     last = 0;
     first = 0;
     for (i = 0; i < nminus; i++) {
-	sscanf(astr, "%100s %d", tname, &trights);
+	sscanf(astr, "%" opr_stringize(MAXNAME) "s %d", tname, &trights);
 	astr = RSkipLine(astr);
 	tl = malloc(sizeof(struct AclEntry));
 	if (!first)
diff --git a/src/sys/setpag.c b/src/sys/setpag.c
index 48570bf78..ef1f4ffa0 100644
--- a/src/sys/setpag.c
+++ b/src/sys/setpag.c
@@ -50,7 +50,7 @@ lsetpag(void)
 {
     int errcode;
 
-#ifdef AFS_LINUX20_ENV
+#ifdef AFS_LINUX_ENV
     int rval;
 
     rval = proc_afs_syscall(AFSCALL_SETPAG,0,0,0,0,&errcode);
diff --git a/src/sys/sys_prototypes.h b/src/sys/sys_prototypes.h
index beb28f617..659cd8388 100644
--- a/src/sys/sys_prototypes.h
+++ b/src/sys/sys_prototypes.h
@@ -11,7 +11,7 @@
 #define _SYS_PROTOTYPES_H
 
 /* glue.c */
-#ifdef AFS_LINUX20_ENV
+#ifdef AFS_LINUX_ENV
 extern int proc_afs_syscall(long, long, long, long, long, int *);
 #endif
 #ifdef AFS_DARWIN80_ENV
diff --git a/src/tests/snprintf.c b/src/tests/snprintf.c
index aaed1a7e5..a8eeb19ed 100644
--- a/src/tests/snprintf.c
+++ b/src/tests/snprintf.c
@@ -442,7 +442,7 @@ xyzprintf(struct state *state, const char *char_format, va_list ap)
 		}
 	    case '\0':
 		--format;
-		/* FALLTHROUGH */
+		AFS_FALLTHROUGH;
 	    case '%':
 		if ((*state->append_char) (state, c))
 		    return -1;
diff --git a/src/tools/dumpscan/afsdump_dirlist.c b/src/tools/dumpscan/afsdump_dirlist.c
index 0af2ed7d1..811ddd45c 100644
--- a/src/tools/dumpscan/afsdump_dirlist.c
+++ b/src/tools/dumpscan/afsdump_dirlist.c
@@ -56,7 +56,7 @@ static dump_parser dp;
 
 
 /* Print a usage message and exit */
-static void
+static void AFS_NORETURN
 usage(int status, char *msg)
 {
     if (msg)
diff --git a/src/tools/dumpscan/afsdump_extract.c b/src/tools/dumpscan/afsdump_extract.c
index db0b2fab9..dfe0369fb 100644
--- a/src/tools/dumpscan/afsdump_extract.c
+++ b/src/tools/dumpscan/afsdump_extract.c
@@ -62,7 +62,7 @@ static path_hashinfo phi;
 static dump_parser dp;
 
 /* Print a usage message and exit */
-static void
+static void AFS_NORETURN
 usage(int status, char *msg)
 {
     if (msg)
diff --git a/src/tools/dumpscan/afsdump_scan.c b/src/tools/dumpscan/afsdump_scan.c
index dafae676b..787172d45 100644
--- a/src/tools/dumpscan/afsdump_scan.c
+++ b/src/tools/dumpscan/afsdump_scan.c
@@ -63,7 +63,7 @@ static dump_parser dp;
 
 
 /* Print a usage message and exit */
-static void
+static void AFS_NORETURN
 usage(int status, char *msg)
 {
     if (msg)
diff --git a/src/tools/dumpscan/dumptool.c b/src/tools/dumpscan/dumptool.c
index 58d67e82b..4ded93c39 100644
--- a/src/tools/dumpscan/dumptool.c
+++ b/src/tools/dumpscan/dumptool.c
@@ -88,7 +88,7 @@
 #include <afs/vnode.h>
 #include <afs/volume.h>
 
-#ifdef AFS_LINUX24_ENV
+#ifdef AFS_LINUX_ENV
 #define _LARGEFILE64_SOURCE 1
 #endif
 #ifdef RESIDENCY
@@ -1300,6 +1300,7 @@ DirectoryList(int argc, char **argv, struct vnodeData *vdata,
 	    break;
 	case 'R':
 	    Rflag++;
+	    break;
 	case 's':
 	    sflag++;
 	    break;
diff --git a/src/tools/dumpscan/parsevnode.c b/src/tools/dumpscan/parsevnode.c
index 0e18e498e..f4e5e4b7d 100644
--- a/src/tools/dumpscan/parsevnode.c
+++ b/src/tools/dumpscan/parsevnode.c
@@ -27,7 +27,7 @@
  */
 
 /* parsevnode.c - Parse a VNode */
-
+#include <afsconfig.h>
 #include <sys/types.h>
 #include <netinet/in.h>
 #include <errno.h>
@@ -480,7 +480,7 @@ parse_vdata(XFILE * X, unsigned char *tag, tagged_field * field,
 		    return r;
 		break;
 	    }
-
+	    AFS_FALLTHROUGH;
 	default:
 	    if ((r = xfskip(X, v->size)))
 		return r;
diff --git a/src/ubik/disk.c b/src/ubik/disk.c
index ed2b55b36..61e7078a4 100644
--- a/src/ubik/disk.c
+++ b/src/ubik/disk.c
@@ -680,11 +680,10 @@ udisk_read(struct ubik_trans *atrans, afs_int32 afile, void *abuffer,
 	   afs_int32 apos, afs_int32 alen)
 {
     char *bp;
-    afs_int32 offset, len, totalLen;
+    afs_int32 offset, len;
 
     if (atrans->flags & TRDONE)
 	return UDONE;
-    totalLen = 0;
     while (alen > 0) {
 	bp = DRead(atrans, afile, apos >> UBIK_LOGPAGESIZE);
 	if (!bp)
@@ -698,7 +697,6 @@ udisk_read(struct ubik_trans *atrans, afs_int32 afile, void *abuffer,
 	abuffer = (char *)abuffer + len;
 	apos += len;
 	alen -= len;
-	totalLen += len;
 	DRelease(bp, 0);
     }
     return 0;
@@ -746,7 +744,7 @@ udisk_write(struct ubik_trans *atrans, afs_int32 afile, void *abuffer,
 	    afs_int32 apos, afs_int32 alen)
 {
     char *bp;
-    afs_int32 offset, len, totalLen;
+    afs_int32 offset, len;
     struct ubik_trunc *tt;
     afs_int32 code;
 
@@ -769,7 +767,6 @@ udisk_write(struct ubik_trans *atrans, afs_int32 afile, void *abuffer,
     }
 
     /* now update vm */
-    totalLen = 0;
     while (alen > 0) {
 	bp = DRead(atrans, afile, apos >> UBIK_LOGPAGESIZE);
 	if (!bp) {
@@ -786,7 +783,6 @@ udisk_write(struct ubik_trans *atrans, afs_int32 afile, void *abuffer,
 	abuffer = (char *)abuffer + len;
 	apos += len;
 	alen -= len;
-	totalLen += len;
 	DRelease(bp, 1);	/* buffer modified */
     }
     return 0;
diff --git a/src/ubik/recovery.c b/src/ubik/recovery.c
index 34a36c913..5ddd5ef19 100644
--- a/src/ubik/recovery.c
+++ b/src/ubik/recovery.c
@@ -949,7 +949,7 @@ DoProbe(struct ubik_server *server)
 
 	    multi_Abort;
 	}
-    } multi_End_Ignore;
+    } multi_End;
 
     if (success_i >= 0) {
 	UBIK_ADDR_LOCK;
diff --git a/src/ubik/remote.c b/src/ubik/remote.c
index a7ddcc4b6..549334862 100644
--- a/src/ubik/remote.c
+++ b/src/ubik/remote.c
@@ -472,11 +472,11 @@ SDISK_SendFile(struct rx_call *rxcall, afs_int32 file,
     afs_int32 code;
     struct ubik_dbase *dbase = NULL;
     char tbuffer[1024];
-    afs_int32 offset;
     struct ubik_version tversion;
     int tlen;
     struct rx_peer *tpeer;
     struct rx_connection *tconn;
+    afs_uint32 syncHost = 0;
     afs_uint32 otherHost = 0;
     char hoststr[16];
     char pbuffer[1028];
@@ -503,17 +503,17 @@ SDISK_SendFile(struct rx_call *rxcall, afs_int32 file,
      * screwup.  Thus, we only object if we're sure we know who the sync site
      * is, and it ain't the guy talking to us.
      */
-    offset = uvote_GetSyncSite();
+    syncHost = uvote_GetSyncSite();
     tconn = rx_ConnectionOf(rxcall);
     tpeer = rx_PeerOf(tconn);
     otherHost = ubikGetPrimaryInterfaceAddr(rx_HostOf(tpeer));
-    if (offset && offset != otherHost) {
+    if (syncHost && syncHost != otherHost) {
 	/* we *know* this is the wrong guy */
         char sync_hoststr[16];
 	ViceLog(0,
 	    ("Ubik: Refusing synchronization with server %s since it is not the sync-site (%s).\n",
 	     afs_inet_ntoa_r(otherHost, hoststr),
-	     afs_inet_ntoa_r(offset, sync_hoststr)));
+	     afs_inet_ntoa_r(syncHost, sync_hoststr)));
 	return USYNC;
     }
 
@@ -525,7 +525,6 @@ SDISK_SendFile(struct rx_call *rxcall, afs_int32 file,
     ViceLog(0, ("Ubik: Synchronize database: receive (via SendFile) from server %s begin\n",
 	       afs_inet_ntoa_r(otherHost, hoststr)));
 
-    offset = 0;
     UBIK_VERSION_LOCK;
     epoch = tversion.epoch = 0;		/* start off by labelling in-transit db as invalid */
     (*dbase->setlabel) (dbase, file, &tversion);	/* setlabel does sync */
@@ -569,7 +568,6 @@ SDISK_SendFile(struct rx_call *rxcall, afs_int32 file,
 	    close(fd);
 	    goto failed;
 	}
-	offset += tlen;
 	length -= tlen;
     }
     code = close(fd);
diff --git a/src/ubik/ubik.p.h b/src/ubik/ubik.p.h
index 4585ba96f..6567961df 100644
--- a/src/ubik/ubik.p.h
+++ b/src/ubik/ubik.p.h
@@ -491,7 +491,7 @@ extern int ubeacon_InitServerListByInfo(afs_uint32 ame,
 					char clones[]);
 extern int ubeacon_InitServerList(afs_uint32 ame, afs_uint32 aservers[]);
 extern void *ubeacon_Interact(void *);
-extern int ubeacon_updateUbikNetworkAddress(afs_uint32 ubik_host[]);
+extern int ubeacon_updateUbikNetworkAddress(afs_uint32 ubik_host[UBIK_MAX_INTERFACE_ADDR]);
 extern struct beacon_data beacon_globals;
 extern struct addr_data addr_globals;
 
diff --git a/src/update/server.c b/src/update/server.c
index c2985d375..1b191e1e5 100644
--- a/src/update/server.c
+++ b/src/update/server.c
@@ -289,6 +289,12 @@ main(int argc, char *argv[])
 	exit(1);
     }
 
+    if (afsconf_CountKeys(cdir) == 0) {
+	fprintf(stderr, "WARNING: No encryption keys found! "
+			"All authenticated accesses will fail."
+			"Run akeyconvert or asetkey to import encryption keys.\n");
+    }
+
     if (rxBind) {
 	afs_int32 ccode;
         if (AFSDIR_SERVER_NETRESTRICT_FILEPATH ||
diff --git a/src/uss/Makefile.in b/src/uss/Makefile.in
index 7a5fe4f98..aa1ddb71b 100644
--- a/src/uss/Makefile.in
+++ b/src/uss/Makefile.in
@@ -48,7 +48,7 @@ uss: uss.o ${OBJS} $(LIBS)
 
 uss.o:  uss.c AFS_component_version_number.c
 
-CFLAGS_lex.yy.o = @CFLAGS_NOUNUSED@ @CFLAGS_NOOLDSTYLE@
+CFLAGS_lex.yy.o = @CFLAGS_NOUNUSED@ @CFLAGS_NOOLDSTYLE@ @CFLAGS_NOIMPLICIT_FALLTHROUGH@
 lex.yy.o : lex.yy.c y.tab.c
 
 lex.yy.c : lex.l
diff --git a/src/uss/uss_acl.c b/src/uss/uss_acl.c
index ee945e82b..003eff8b9 100644
--- a/src/uss/uss_acl.c
+++ b/src/uss/uss_acl.c
@@ -17,6 +17,7 @@
  */
 #include <afsconfig.h>
 #include <afs/param.h>
+#include <afs/opr.h>
 
 #include <roken.h>
 
@@ -404,7 +405,7 @@ ParseAcl(char *a_str)
 {				/*ParseAcl */
 
     int nplus, nminus, i, trights;
-    char tname[MAXNAME];
+    char tname[MAXNAME + 1] = "";
     struct AclEntry *first, *last, *tl;
     struct Acl *ta;
 
@@ -430,7 +431,7 @@ ParseAcl(char *a_str)
     last = 0;
     first = 0;
     for (i = 0; i < nplus; i++) {
-	sscanf(a_str, "%100s %d", tname, &trights);
+	sscanf(a_str, "%" opr_stringize(MAXNAME) "s %d", tname, &trights);
 	a_str = SkipLine(a_str);
 	tl = malloc(sizeof(struct AclEntry));
 	if (!first)
@@ -450,7 +451,7 @@ ParseAcl(char *a_str)
     last = 0;
     first = 0;
     for (i = 0; i < nminus; i++) {
-	sscanf(a_str, "%100s %d", tname, &trights);
+	sscanf(a_str, "%" opr_stringize(MAXNAME) "s %d", tname, &trights);
 	a_str = SkipLine(a_str);
 	tl = malloc(sizeof(struct AclEntry));
 	if (!first)
diff --git a/src/uss/uss_common.h b/src/uss/uss_common.h
index ceda7c901..b0536ecc1 100644
--- a/src/uss/uss_common.h
+++ b/src/uss/uss_common.h
@@ -60,7 +60,7 @@
 #define uss_VolumeLen		300
 #define uss_DirPoolLen		300
 
-#if !defined(AFS_LINUX20_ENV) && !defined(AFS_DARWIN_ENV) && !defined(AFS_XBSD_ENV)
+#if !defined(AFS_LINUX_ENV) && !defined(AFS_DARWIN_ENV) && !defined(AFS_XBSD_ENV)
 extern char *sys_errlist[];
 #endif
 
diff --git a/src/util/Makefile.in b/src/util/Makefile.in
index 27fa26e81..d1fcbaebb 100644
--- a/src/util/Makefile.in
+++ b/src/util/Makefile.in
@@ -212,8 +212,9 @@ clean:
 	$(RM) -f sys dirpath.h
 	$(RM) -f util.a *.o core AFS_component_version_number.c
 
+.PHONY: test
 test:
-	cd test; $(MAKE)
+	cd test && $(MAKE)
 
 include ../config/Makefile.version
 
diff --git a/src/util/afsutil.h b/src/util/afsutil.h
index bbebcc16d..bd78946b4 100644
--- a/src/util/afsutil.h
+++ b/src/util/afsutil.h
@@ -121,11 +121,6 @@ extern int re_exec(const char *p1);
 /* b64_string_t is 8 bytes, in stds.h */
      typedef char lb64_string_t[12];
 
-/* A simple macro to help show the value of #define'd constants. e.g. If 'FOO'
- * is defined as 5, then AFS_STRINGIZE(FOO) expands to "5" */
-#define AFS_STRINGIZE_(s) #s
-#define AFS_STRINGIZE(s) AFS_STRINGIZE_(s)
-
 #include <afs/ktime.h>
 #include "afsutil_prototypes.h"
 
diff --git a/src/util/uuid.c b/src/util/uuid.c
index dbf77d062..57be4d50b 100644
--- a/src/util/uuid.c
+++ b/src/util/uuid.c
@@ -52,7 +52,7 @@
 #  include <rpc.h>
 # else
 #  include <net/if.h>
-#  if !defined(AFS_LINUX20_ENV) && !defined(AFS_ARM_DARWIN_ENV)
+#  if !defined(AFS_LINUX_ENV) && !defined(AFS_ARM_DARWIN_ENV)
 #   include <netinet/if_ether.h>
 #  endif
 # endif
@@ -393,7 +393,7 @@ uuid_get_address(uuid_address_p_t addr)
 void
 uuid__get_os_time(uuid_time_t * os_time)
 {
-    osi_timeval_t tp;
+    osi_timeval32_t tp;
 
     osi_GetTime(&tp);
     os_time->hi = tp.tv_sec;
diff --git a/src/util/vice.h b/src/util/vice.h
index 5342be78f..bd05d9155 100644
--- a/src/util/vice.h
+++ b/src/util/vice.h
@@ -12,7 +12,7 @@
 
 #include <sys/types.h>
 #if !defined(AFS_NT40_ENV)
-# if (!defined(AFS_FBSD_ENV) && !defined(AFS_LINUX26_ENV)) || !defined(KERNEL) || defined(UKERNEL)
+# if (!defined(AFS_FBSD_ENV) && !defined(AFS_LINUX_ENV)) || !defined(KERNEL) || defined(UKERNEL)
 #  include <sys/ioctl.h>
 # endif
 #endif /* AFS_NT40_ENV */
diff --git a/src/venus/Makefile.in b/src/venus/Makefile.in
index 78645b7d6..6ad22114b 100644
--- a/src/venus/Makefile.in
+++ b/src/venus/Makefile.in
@@ -366,7 +366,8 @@ clean:
 		AFS_component_version_number.c fstrace gcpags livesys dedebug \
 		cacheout afsio
 
+.PHONY: test
 test:
-	cd test; $(MAKE)
+	cd test && $(MAKE)
 
 include ../config/Makefile.version
diff --git a/src/venus/fs.c b/src/venus/fs.c
index 630f44c66..103f3096a 100644
--- a/src/venus/fs.c
+++ b/src/venus/fs.c
@@ -66,7 +66,7 @@ static void ZapList(struct AclEntry *);
 static int PruneList(struct AclEntry **, int);
 static int CleanAcl(struct Acl *, char *);
 static int SetVolCmd(struct cmd_syndesc *as, void *arock);
-static int GetCellName(char *, struct afsconf_cell *);
+static int GetCellName(char *, char *, size_t);
 static void Die(int, char *);
 
 /*
@@ -2063,7 +2063,6 @@ CheckServersCmd(struct cmd_syndesc *as, void *arock)
     afs_int32 j;
     afs_int32 temp;
     char *tp;
-    struct afsconf_cell info;
     struct chservinfo checkserv;
 
     memset(&checkserv, 0, sizeof(struct chservinfo));
@@ -2086,12 +2085,12 @@ CheckServersCmd(struct cmd_syndesc *as, void *arock)
 
     /* now copy in optional cell name, if specified */
     if (as->parms[0].items) {
-	code = GetCellName(as->parms[0].items->data, &info);
+	code = GetCellName(as->parms[0].items->data, &checkserv.tbuffer[0],
+			   sizeof(checkserv.tbuffer));
 	if (code) {
 	    return 1;
 	}
-	strcpy(checkserv.tbuffer, info.name);
-	checkserv.tsize = strlen(info.name) + 1;
+	checkserv.tsize = strlen(checkserv.tbuffer) + 1;
     } else {
 	strcpy(checkserv.tbuffer, "\0");
 	checkserv.tsize = 0;
@@ -2957,7 +2956,7 @@ GetCellCmd(struct cmd_syndesc *as, void *arock)
 {
     afs_int32 code;
     struct ViceIoctl blob;
-    struct afsconf_cell info;
+    char cellName[MAXCELLCHARS];
     struct cmd_item *ti;
     struct a {
 	afs_int32 stat;
@@ -2970,24 +2969,24 @@ GetCellCmd(struct cmd_syndesc *as, void *arock)
 	/* once per cell */
 	blob.out_size = sizeof(args);
 	blob.out = (caddr_t) & args;
-	code = GetCellName(ti->data, &info);
+	code = GetCellName(ti->data, &cellName[0], sizeof(cellName));
 	if (code) {
 	    error = 1;
 	    continue;
 	}
-	blob.in_size = 1 + strlen(info.name);
-	blob.in = info.name;
+	blob.in_size = 1 + strlen(cellName);
+	blob.in = cellName;
 	code = pioctl(0, VIOC_GETCELLSTATUS, &blob, 1);
 	if (code) {
 	    if (errno == ENOENT)
 		fprintf(stderr, "%s: the cell named '%s' does not exist\n",
-			pn, info.name);
+			pn, cellName);
 	    else
-		Die(errno, info.name);
+		Die(errno, cellName);
 	    error = 1;
 	    continue;
 	}
-	printf("Cell %s status: ", info.name);
+	printf("Cell %s status: ", cellName);
 	if (args.stat & 2)
 	    printf("no setuid allowed");
 	else
@@ -3004,7 +3003,6 @@ SetCellCmd(struct cmd_syndesc *as, void *arock)
 {
     afs_int32 code;
     struct ViceIoctl blob;
-    struct afsconf_cell info;
     struct cmd_item *ti;
     struct a {
 	afs_int32 stat;
@@ -3029,19 +3027,18 @@ SetCellCmd(struct cmd_syndesc *as, void *arock)
     /* set stat for all listed cells */
     for (ti = as->parms[0].items; ti; ti = ti->next) {
 	/* once per cell */
-	code = GetCellName(ti->data, &info);
+	code = GetCellName(ti->data, &args.cname[0], sizeof(args.cname));
 	if (code) {
 	    error = 1;
 	    continue;
 	}
-	strcpy(args.cname, info.name);
 	blob.in_size = sizeof(args);
 	blob.in = (caddr_t) & args;
 	blob.out_size = 0;
 	blob.out = (caddr_t) 0;
 	code = pioctl(0, VIOC_SETCELLSTATUS, &blob, 1);
 	if (code) {
-	    Die(errno, info.name);	/* XXX added cell name to Die() call */
+	    Die(errno, args.cname);	/* XXX added cell name to Die() call */
 	    error = 1;
 	}
     }
@@ -3049,7 +3046,7 @@ SetCellCmd(struct cmd_syndesc *as, void *arock)
 }
 
 static int
-GetCellName(char *cellName, struct afsconf_cell *info)
+GetCellName(char *cellName, char *buf, size_t buf_size)
 {
     struct afsconf_dir *tdir;
     int code;
@@ -3062,7 +3059,7 @@ GetCellName(char *cellName, struct afsconf_cell *info)
 	return -1;
     }
 
-    code = afsconf_GetCellInfo(tdir, cellName, AFSCONF_VLDBSERVICE, info);
+    code = afsconf_GetCellName(tdir, cellName, buf, buf_size);
     if (code) {
 	fprintf(stderr, "%s: cell %s not in %s\n", pn, cellName,
 		AFSDIR_CLIENT_CELLSERVDB_FILEPATH);
diff --git a/src/venus/fstrace.c b/src/venus/fstrace.c
index 38c1cc087..57258ac85 100644
--- a/src/venus/fstrace.c
+++ b/src/venus/fstrace.c
@@ -1089,10 +1089,10 @@ afs_syscall(long call, long parm0, long parm1, long parm2, long parm3,
 	    long parm4, long parm5, long parm6)
 {
     int code;
-#if defined(AFS_DARWIN80_ENV) || defined(AFS_LINUX20_ENV)
+#if defined(AFS_DARWIN80_ENV) || defined(AFS_LINUX_ENV)
     int rval;
 #endif
-#ifdef AFS_LINUX20_ENV
+#ifdef AFS_LINUX_ENV
 #if defined AFS_LINUX_64BIT_KERNEL
     long long eparm[4];
     /* don't want to sign extend it to 64bit, so using ulong */
@@ -1127,7 +1127,7 @@ afs_syscall(long call, long parm0, long parm1, long parm2, long parm3,
 #endif
 	}
     }
-#if defined(AFS_SPARC64_LINUX20_ENV) || defined(AFS_SPARC_LINUX20_ENV)
+#if defined(AFS_SPARC64_LINUX_ENV) || defined(AFS_SPARC_LINUX_ENV)
     /* on sparc this function returns none value, so do it myself */
     __asm__ __volatile__("mov	%o0, %i0; ret; restore");
 #endif
@@ -1150,7 +1150,7 @@ afs_syscall(long call, long parm0, long parm1, long parm2, long parm3,
 #endif
 #endif
 #endif
-#endif /* AFS_LINUX20_ENV */
+#endif /* AFS_LINUX_ENV */
     return code;
 }
 #endif
diff --git a/src/venus/kdump.c b/src/venus/kdump.c
index b10081ab2..3cef0f0cb 100644
--- a/src/venus/kdump.c
+++ b/src/venus/kdump.c
@@ -16,7 +16,7 @@
 
 #if !defined(AFS_DARWIN_ENV) && !defined(AFS_FBSD_ENV)
 /* Here be hacks. */
-#ifdef AFS_LINUX24_ENV
+#ifdef AFS_LINUX_ENV
 #define __KERNEL__
 #include <linux/string.h>
 #define _STRING_H 1
@@ -25,7 +25,7 @@
 #undef USE_UCONTEXT
 #endif
 
-#ifdef AFS_LINUX26_ENV
+#ifdef AFS_LINUX_ENV
 /* For some reason, this doesn't get defined in linux/types.h
    if __KERNEL_STRICT_NAMES is defined. But the definition of
    struct inode uses it.
@@ -106,7 +106,7 @@ struct ncp_sb_info {
 #define _KERNEL 1
 #endif
 
-#ifndef AFS_LINUX20_ENV
+#ifndef AFS_LINUX_ENV
 #include <nlist.h>
 #endif
 
@@ -142,7 +142,7 @@ struct vnode foo;
 #include <sys/user.h>
 #endif
 
-#ifndef AFS_LINUX26_ENV
+#ifndef AFS_LINUX_ENV
 #include <sys/file.h>
 #endif
 
@@ -177,7 +177,7 @@ struct vnode foo;
 #include <ufs/ffs/fs.h>
 #else
 #include "sys/vfs.h"
-#ifdef AFS_LINUX20_ENV
+#ifdef AFS_LINUX_ENV
 #ifndef UIO_MAXIOV
 #define UIO_MAXIOV 1		/* don't care */
 #endif
@@ -192,30 +192,30 @@ struct vnode foo;
 #undef LONG_MAX
 #undef ULONG_MAX
 #define _LINUX_TIME_H
-#ifndef AFS_LINUX26_ENV
+#ifndef AFS_LINUX_ENV
 #define _LINUX_FCNTL_H
 #endif
-#ifdef AFS_IA64_LINUX24_ENV
+#ifdef AFS_IA64_LINUX_ENV
 #define flock64  flock
-#endif /* AFS_IA64_LINUX24_ENV */
-#ifdef AFS_S390_LINUX20_ENV
+#endif /* AFS_IA64_LINUX_ENV */
+#ifdef AFS_S390_LINUX_ENV
 #define _S390_STATFS_H
 #else
-#ifdef AFS_SPARC64_LINUX20_ENV
+#ifdef AFS_SPARC64_LINUX_ENV
 #define _SPARC64_STATFS_H
 #define _SPARC_STATFS_H
 #else
-#ifdef AFS_SPARC_LINUX20_ENV
+#ifdef AFS_SPARC_LINUX_ENV
 #define _SPARC_STATFS_H
 #else
-#ifdef AFS_ALPHA_LINUX20_ENV
+#ifdef AFS_ALPHA_LINUX_ENV
 #define _ALPHA_STATFS_H
 #else
 #define _I386_STATFS_H
-#endif /* AFS_ALPHA_LINUX20_ENV */
-#endif /* AFS_SPARC_LINUX20_ENV */
-#endif /* AFS_SPARC64_LINUX20_ENV */
-#endif /* AFS_S390_LINUX20_ENV */
+#endif /* AFS_ALPHA_LINUX_ENV */
+#endif /* AFS_SPARC_LINUX_ENV */
+#endif /* AFS_SPARC64_LINUX_ENV */
+#endif /* AFS_S390_LINUX_ENV */
 struct timezone {
     int a, b;
 };
@@ -229,7 +229,7 @@ struct timezone {
 #define timer_t ktimer_t
 #define timer_t_redefined
 #endif
-#ifdef AFS_LINUX26_ENV
+#ifdef AFS_LINUX_ENV
 /* For some reason, this doesn't get defined in linux/types.h
    if __KERNEL_STRICT_NAMES is defined. But the definition of
    struct inode uses it.
@@ -238,7 +238,7 @@ struct timezone {
 /* got it from linux/types.h */
 typedef unsigned long sector_t;
 #endif /* HAVE_SECTOR_T */
-#endif /* AFS_LINUX26_ENV */
+#endif /* AFS_LINUX_ENV */
 #include <linux/version.h>
 #include <linux/fs.h>
 #include <osi_vfs.h>
@@ -246,7 +246,7 @@ typedef unsigned long sector_t;
 #undef timer_t
 #undef timer_t_redefined
 #endif
-#else /* AFS_LINUX20_ENV */
+#else /* AFS_LINUX_ENV */
 #ifdef AFS_HPUX110_ENV
 #define  KERNEL
 #define  _KERNEL 1
@@ -267,7 +267,7 @@ typedef enum _spustate {	/* FROM /etc/conf/h/_types.h */
 #else /* AFS_HPUX110_ENV */
 #include "sys/vnode.h"
 #endif /* else AFS_HPUX110_ENV */
-#endif /* else AFS_LINUX20_ENV */
+#endif /* else AFS_LINUX_ENV */
 #ifdef	AFS_HPUX_ENV
 #include "sys/inode.h"
 #else
@@ -275,7 +275,7 @@ typedef enum _spustate {	/* FROM /etc/conf/h/_types.h */
 #ifdef	AFS_SUN5_ENV
 #include "sys/fs/ufs_inode.h"
 #else
-#ifndef AFS_LINUX20_ENV
+#ifndef AFS_LINUX_ENV
 #include "ufs/inode.h"
 #endif
 #endif
@@ -338,7 +338,7 @@ typedef struct {
 } afs_kcondvar_t;
 #endif /* AFS_SGI65_ENV */
 
-#ifdef AFS_LINUX20_ENV
+#ifdef AFS_LINUX_ENV
 #include <asm/atomic.h>
 #include <asm/semaphore.h>
 #define RX_ENABLE_LOCKS 1
@@ -347,7 +347,7 @@ typedef struct {
     int opaque2;
 } afs_kmutex_t;
 typedef void *afs_kcondvar_t;
-#endif /* AFS_LINUX20_ENV */
+#endif /* AFS_LINUX_ENV */
 
 #include <afs/exporter.h>
 /*#include "afs/osi.h"*/
@@ -355,10 +355,10 @@ typedef void *afs_kcondvar_t;
 typedef struct {
     int tv_sec;
     int tv_usec;
-} osi_timeval_t;		/* Needed here since KERNEL defined. */
+} osi_timeval32_t;		/* Needed here since KERNEL defined. */
 
 /*#include "afs/volerrors.h"*/
-#ifdef AFS_LINUX20_ENV
+#ifdef AFS_LINUX_ENV
 #define _SYS_TIME_H
 #endif
 
@@ -483,14 +483,14 @@ int opencore();
 #define AFSNLIST(N, C) nlist64((N), (C))
 #endif /* AFS_32BIT_KERNEL_ENV */
 #else /* AFS_SGI61_ENV */
-#ifdef AFS_LINUX20_ENV
+#ifdef AFS_LINUX_ENV
 struct afs_nlist {
     char *n_name;
     unsigned long n_value;
 };
-#else /* AFS_LINUX20_ENV */
+#else /* AFS_LINUX_ENV */
 #define afs_nlist nlist
-#endif /* AFS_LINUX20_ENV */
+#endif /* AFS_LINUX_ENV */
 #define AFSNLIST(N, C) nlist((N), (C))
 #endif /* AFS_SGI61_ENV */
 #endif /* defined(AFS_HPUX_ENV) && defined(__LP64__) */
@@ -548,14 +548,10 @@ PrintIPAddr(int addr)
     return (char *)str;
 }
 
-#ifdef AFS_LINUX20_ENV
+#ifdef AFS_LINUX_ENV
 /* Find symbols in a live kernel. */
 
-#ifdef AFS_LINUX26_ENV
 #define KSYMS "/proc/kallsyms"
-#else
-#define KSYMS "/proc/ksyms"
-#endif
 
 /* symlist_t contains all the kernel symbols. Forcing a 64 byte array is
  * a bit wasteful, but simple.
@@ -626,13 +622,11 @@ read_ksyms(void)
 	ksyms[nksyms].s_value = (int)strtoul(line, &p, 16);
 #endif /* AFS_LINUX_64BIT_KERNEL */
 	p++;
-#ifdef AFS_LINUX26_ENV
 	/* Linux 2.6 /proc/kallsyms has a one-char symbol type
 	   between address and name, so step over it and the following
 	   blank.
 	*/
 	p += 2;
-#endif
 	q = strchr(p, '\t');
 	if (q)
 	    *q = '\0';
@@ -682,7 +676,7 @@ nlist(void *notused, struct afs_nlist *nlp)
     return 0;
 }
 
-#endif
+#endif /* AFS_LINUX_ENV */
 
 #if	defined(AFS_SUN5_ENV)
 #ifdef	_LP64
@@ -1779,7 +1773,7 @@ typedef struct event {
 #endif
 
 
-#ifdef AFS_LINUX22_ENV
+#ifdef AFS_LINUX_ENV
 /* This is replicated from LINUX/osi_alloc.c */
 #define MEM_SPACE sizeof(int)
 
@@ -1829,7 +1823,7 @@ print_alloced_memlist(void)
     printf("Found %d elements in allocated memory list, expected %d\n", n,
 	   count);
 }
-#endif
+#endif /* AFS_LINUX_ENV */
 
 void
 print_allocs(int pnt)
@@ -2100,7 +2094,7 @@ print_allocs(int pnt)
     printf
 	("\n\nNOTE:\n\tAll [...]* entries above aren't counted towards the total mem since they're redundant\n");
 
-#ifdef AFS_LINUX22_ENV
+#ifdef AFS_LINUX_ENV
     if (pnt)
 	print_alloced_memlist();
 #endif
@@ -2577,52 +2571,24 @@ print_vnode(int kmem, struct vnode *vep, struct vnode *ptr, int pnt)
 #endif
     printf(", v_mregb=0x%lx\n", vep->v_mregb);
 #endif
-#ifdef AFS_LINUX22_ENV
+#ifdef AFS_LINUX_ENV
     /* Print out the stat cache and other inode info. */
     printf
 	("\ti_ino=%d, i_mode=%x, i_nlink=%d, i_uid=%d, i_gid=%d, i_size=%d\n",
 	 vep->i_ino, vep->i_mode, vep->i_nlink, vep->i_uid, vep->i_gid,
 	 vep->i_size);
-#ifdef AFS_LINUX24_ENV
     printf
 	("\ti_atime=%u, i_mtime=%u, i_ctime=%u, i_version=%u, i_nrpages=%u\n",
 	 vep->i_atime, vep->i_mtime, vep->i_ctime, vep->i_version,
 	 vep->i_data.nrpages);
-#else
-    printf
-	("\ti_atime=%u, i_mtime=%u, i_ctime=%u, i_version=%u, i_nrpages=%u\n",
-	 vep->i_atime, vep->i_mtime, vep->i_ctime, vep->i_version,
-	 vep->i_nrpages);
-#endif
-#ifdef AFS_LINUX26_ENV
     printf("\ti_op=0x%x, i_rdev=0x%x, i_sb=0x%x\n", vep->i_op,
 	   vep->i_rdev, vep->i_sb);
-#else /* AFS_LINUX26_ENV */
-    printf("\ti_op=0x%x, i_dev=0x%x, i_rdev=0x%x, i_sb=0x%x\n", vep->i_op,
-	   vep->i_dev, vep->i_rdev, vep->i_sb);
-#endif /* AFS_LINUX26_ENV */
-#ifdef AFS_LINUX24_ENV
-#ifdef AFS_PARISC_LINUX24_ENV
-    printf("\ti_sem: count=%d, wait=0x%x\n", vep->i_sem.count,
-	   vep->i_sem.wait);
-#else
     printf("\ti_sem: count=%d, sleepers=%d, wait=0x%x\n", vep->i_sem.count,
 	   vep->i_sem.sleepers, vep->i_sem.wait);
-#endif
-#else
-    printf("\ti_sem: count=%d, waking=%d, wait=0x%x\n", vep->i_sem.count,
-	   vep->i_sem.waking, vep->i_sem.wait);
-#endif
-#ifdef AFS_LINUX26_ENV
     printf("\ti_hash=0x%x:0x%x, i_list=0x%x:0x%x, i_dentry=0x%x:0x%x\n",
 	   vep->i_hash.pprev, vep->i_hash.next, vep->i_list.prev,
 	   vep->i_list.next, vep->i_dentry.prev, vep->i_dentry.next);
-#else /* AFS_LINUX26_ENV */
-    printf("\ti_hash=0x%x:0x%x, i_list=0x%x:0x%x, i_dentry=0x%x:0x%x\n",
-	   vep->i_hash.prev, vep->i_hash.next, vep->i_list.prev,
-	   vep->i_list.next, vep->i_dentry.prev, vep->i_dentry.next);
-#endif /* AFS_LINUX26_ENV */
-#endif /* AFS_LINUX22_ENV */
+#endif /* AFS_LINUX_ENV */
 }
 
 void
@@ -2756,7 +2722,7 @@ print_vcache(int kmem, struct vcache *vep, struct vcache *ptr, int pnt)
 	    }
 	}
     }
-#ifdef AFS_LINUX22_ENV
+#ifdef AFS_LINUX_ENV
     printf("\tmapcnt=%d\n", vep->mapcnt);
 #endif
 }
diff --git a/src/vfsck/pass2.c b/src/vfsck/pass2.c
index 8b14fdd3b..9d0b7456c 100644
--- a/src/vfsck/pass2.c
+++ b/src/vfsck/pass2.c
@@ -140,7 +140,7 @@ pass2()
 #else /* no ACLS */
 	statemap[ROOTINO] = DSTATE;
 #endif /* ACLS */
-	/* fall into ... */
+	AFS_FALLTHROUGH;
 
     case DSTATE:
 	descend(&rootdesc, ROOTINO);
@@ -347,7 +347,7 @@ pass2check(idesc)
 		else if ((n = reply("REMOVE")) == 1)
 		    break;
 	    }
-	    /* fall through */
+	    AFS_FALLTHROUGH;
 
 	case FSTATE:
 #ifdef VICE
diff --git a/src/vfsck/pass5.c b/src/vfsck/pass5.c
index 8e6cd6d77..4ac84feee 100644
--- a/src/vfsck/pass5.c
+++ b/src/vfsck/pass5.c
@@ -213,7 +213,7 @@ pass5()
 	    case DCLEAR:
 	    case DFOUND:
 		newcg->cg_cs.cs_ndir++;
-		/* fall through */
+		AFS_FALLTHROUGH;
 
 #ifdef VICE
 	    case VSTATE:
diff --git a/src/viced/callback.c b/src/viced/callback.c
index 980d7e5d9..2a5b65aae 100644
--- a/src/viced/callback.c
+++ b/src/viced/callback.c
@@ -3072,7 +3072,7 @@ MultiBreakCallBackAlternateAddress_r(struct host *host,
 	    multi_Abort;
 	}
     }
-    multi_End_Ignore;
+    multi_End;
     H_LOCK;
     /* Destroy all connections except the one on which we succeeded */
     for (i = 0; i < j; i++)
@@ -3198,7 +3198,7 @@ MultiProbeAlternateAddress_r(struct host *host)
 	FS_STATE_UNLOCK;
 #endif
     }
-    multi_End_Ignore;
+    multi_End;
     H_LOCK;
     /* Destroy all connections except the one on which we succeeded */
     for (i = 0; i < j; i++)
diff --git a/src/viced/viced.c b/src/viced/viced.c
index 6a9643b5e..4f6396881 100644
--- a/src/viced/viced.c
+++ b/src/viced/viced.c
@@ -329,13 +329,13 @@ int
 viced_syscall(afs_uint32 a3, afs_uint32 a4, void *a5)
 {
     afs_uint32 rcode;
-# ifndef AFS_LINUX20_ENV
+# ifndef AFS_LINUX_ENV
     void (*old) (int);
 
     old = (void (*)(int))signal(SIGSYS, SIG_IGN);
 # endif
     rcode = syscall(AFS_SYSCALL, 28 /* AFSCALL_CALL */ , a3, a4, a5);
-# ifndef AFS_LINUX20_ENV
+# ifndef AFS_LINUX_ENV
     signal(SIGSYS, old);
 # endif
 
@@ -1900,7 +1900,12 @@ main(int argc, char *argv[])
     OpenLog(&logopts);
 
     LogCommandLine(argc, argv, "starting", "", "File server", FSLog);
-    if (afsconf_GetLatestKey(confDir, NULL, NULL) == 0) {
+
+    if (afsconf_CountKeys(confDir) == 0) {
+	ViceLog(0, ("WARNING: No encryption keys found! "
+		    "All authenticated accesses will fail. "
+		    "Run akeyconvert or asetkey to import encryption keys.\n"));
+    } else if (afsconf_GetLatestKey(confDir, NULL, NULL) == 0) {
 	LogDesWarning();
     }
 
diff --git a/src/vlserver/vlserver.c b/src/vlserver/vlserver.c
index 08ecab93c..09093783d 100644
--- a/src/vlserver/vlserver.c
+++ b/src/vlserver/vlserver.c
@@ -534,7 +534,11 @@ main(int argc, char **argv)
     rx_SetMaxProcs(tservice, 4);
 
     LogCommandLine(argc, argv, "vlserver", VldbVersion, "Starting AFS", FSLog);
-    if (afsconf_GetLatestKey(tdir, NULL, NULL) == 0) {
+    if (afsconf_CountKeys(tdir) == 0) {
+	VLog(0, ("WARNING: No encryption keys found! "
+		 "All authenticated accesses will fail."
+		 "Run akeyconvert or asetkey to import encryption keys.\n"));
+    } else if (afsconf_GetLatestKey(tdir, NULL, NULL) == 0) {
 	LogDesWarning();
     }
     VLog(0, ("%s\n", cml_version_number));
diff --git a/src/vol/Makefile.in b/src/vol/Makefile.in
index 8da6394e8..320be75fc 100644
--- a/src/vol/Makefile.in
+++ b/src/vol/Makefile.in
@@ -246,8 +246,9 @@ clean:
 	$(RM) -f *.o *.a AFS_component_version_number.c
 	$(RM) -f ${SCMPROGS} ${STAGEPROGS} core salvager volinfo volscan vol-bless gi fssync-debug
 
+.PHONY: test
 test:
-	cd test; $(MAKE)
+	cd test && $(MAKE)
 
 include ../config/Makefile.version
 
diff --git a/src/vol/daemon_com.h b/src/vol/daemon_com.h
index dabaf3b57..ce3a29ee2 100644
--- a/src/vol/daemon_com.h
+++ b/src/vol/daemon_com.h
@@ -87,7 +87,7 @@ enum SYNCReasonCode {
     afs_int64 _##buf##_l[SYNC_PROTO_MAX_LEN/sizeof(afs_int64)]; \
     char * buf = (char *)(_##buf##_l)
 
-#ifdef AFS_LINUX26_ENV
+#ifdef AFS_LINUX_ENV
 /* Some Linux kernels have a bug where we are not woken up immediately from a
  * select() when data is available. Work around this by having a low select()
  * timeout, so we don't hang in those situations. */
diff --git a/src/vol/fssync-server.c b/src/vol/fssync-server.c
index 8cf3b55de..720e6ef1c 100644
--- a/src/vol/fssync-server.c
+++ b/src/vol/fssync-server.c
@@ -954,6 +954,7 @@ FSYNC_com_VolOff(FSSYNC_VolOp_command * vcom, SYNC_response * res)
 
 		VOL_CV_WAIT(&V_attachCV(vp));
 	    }
+	    break;
 
 	case debugUtility:
 	    break;
@@ -996,7 +997,7 @@ FSYNC_com_VolOff(FSSYNC_VolOp_command * vcom, SYNC_response * res)
 	     * attaching the volume would be safe */
 	    VRegisterVolOp_r(vp, &info);
 	    vp->pending_vol_op->vol_op_state = FSSYNC_VolOpRunningUnknown;
-	    /* fall through */
+	    goto done;
 
 	case VOL_STATE_DELETED:
 	    goto done;
@@ -1026,7 +1027,7 @@ FSYNC_com_VolOff(FSSYNC_VolOp_command * vcom, SYNC_response * res)
                  * attaching the volume would be safe */
                 VRegisterVolOp_r(vp, &info);
                 vp->pending_vol_op->vol_op_state = FSSYNC_VolOpRunningUnknown;
-		/* fall through */
+		goto done;
 
             case VOL_STATE_DELETED:
                 goto done;
diff --git a/src/vol/ihandle.h b/src/vol/ihandle.h
index 0bc0203d5..89fd81ce6 100644
--- a/src/vol/ihandle.h
+++ b/src/vol/ihandle.h
@@ -521,7 +521,7 @@ extern Inode ih_icreate(IHandle_t * ih, int dev, char *part, Inode nI, int p1,
 # define IH_CREATE(H, D, P, N, P1, P2, P3, P4) \
         ih_icreate(H, D, P, N, P1, P2, P3, P4)
 
-# ifdef AFS_LINUX22_ENV
+# ifdef AFS_LINUX_ENV
 #  define OS_IOPEN(H) -1
 # else
 #  ifdef O_LARGEFILE
@@ -545,7 +545,7 @@ extern Inode ih_icreate(IHandle_t * ih, int dev, char *part, Inode nI, int p1,
 
 # define OS_SYNC(FD) fsync(FD)
 
-# ifdef AFS_LINUX22_ENV
+# ifdef AFS_LINUX_ENV
 #  define IH_INC(H, I, P) -1
 #  define IH_DEC(H, I, P) -1
 #  define IH_IREAD(H, O, B, S) -1
@@ -557,7 +557,7 @@ extern Inode ih_icreate(IHandle_t * ih, int dev, char *part, Inode nI, int p1,
                                           O, B, S)
 #  define IH_IWRITE(H, O, B, S) \
           inode_write((H)->ih_dev, (H)->ih_ino, (H)->ih_vid, O, B, S)
-# endif /* AFS_LINUX22_ENV */
+# endif /* AFS_LINUX_ENV */
 
 #endif /* AFS_NAMEI_ENV */
 
diff --git a/src/vol/listinodes.c b/src/vol/listinodes.c
index 75bf9362c..3e8cac748 100644
--- a/src/vol/listinodes.c
+++ b/src/vol/listinodes.c
@@ -26,7 +26,7 @@
 #include <ctype.h>
 
 #ifndef AFS_NAMEI_ENV
-#if defined(AFS_LINUX20_ENV)
+#if defined(AFS_LINUX_ENV)
 /* ListViceInodes
  *
  * Return codes:
@@ -1210,7 +1210,7 @@ bread(FD_t fd, char *buf, daddr_t blk, afs_int32 size)
     return 0;
 }
 
-#endif /* AFS_LINUX20_ENV */
+#endif /* AFS_LINUX_ENV */
 static afs_int32
 convertVolumeInfo(FdHandle_t *fdhr, FdHandle_t *fdhw, VolumeId vid)
 {
diff --git a/src/vol/namei_ops.c b/src/vol/namei_ops.c
index d02b465db..e7d060d00 100644
--- a/src/vol/namei_ops.c
+++ b/src/vol/namei_ops.c
@@ -2024,13 +2024,17 @@ _namei_examine_special(char * path1,
 	 * this like a normal file, we won't try to INC or DEC it. */
 	info.linkCount = 0;
     } else {
-	char path2[512];
+	char *path2;
 	/* Open this handle */
-	snprintf(path2, sizeof(path2),
-		 "%s" OS_DIRSEP "%s", path1, dname);
+	if (asprintf(&path2, "%s" OS_DIRSEP "%s", path1, dname) < 0) {
+	    Log("_namei_examine_special: memory allocation failure\n");
+	    ret = -1;
+	    goto error;
+	}
 	linkHandle->fd_fd = OS_OPEN(path2, Testing ? O_RDONLY : O_RDWR, 0666);
 	info.linkCount =
 	    namei_GetLinkCount(linkHandle, (Inode) 0, 1, 1, Testing);
+	free(path2);
     }
 
     if (!judgeFun ||
@@ -3271,19 +3275,17 @@ namei_ConvertROtoRWvolume(char *pname, VolumeId volumeId)
     return code;
 }
 
-/* PrintInode
+/**
+ * Format a string to print inode numbers.
  *
- * returns a static string used to print either 32 or 64 bit inode numbers.
+ * @param[out]  s    string buffer
+ * @param[in]   ino  inode number
+ * @returns pointer to formatted inode number string
  */
 char *
-PrintInode(char *s, Inode ino)
+PrintInode(afs_ino_str_t s, Inode ino)
 {
-    static afs_ino_str_t result;
-    if (!s)
-	s = result;
-
     snprintf(s, sizeof(afs_ino_str_t), "%llu", (afs_uintmax_t) ino);
-
     return s;
 }
 
diff --git a/src/vol/partition.c b/src/vol/partition.c
index 628de3394..8d37a07ac 100644
--- a/src/vol/partition.c
+++ b/src/vol/partition.c
@@ -52,7 +52,7 @@
 #endif
 #endif
 #else /* AFS_VFSINCL_ENV */
-#if !defined(AFS_AIX_ENV) && !defined(AFS_LINUX22_ENV) && !defined(AFS_DARWIN_ENV) && !defined(AFS_XBSD_ENV)
+#if !defined(AFS_AIX_ENV) && !defined(AFS_LINUX_ENV) && !defined(AFS_DARWIN_ENV) && !defined(AFS_XBSD_ENV)
 #include <sys/fs.h>
 #endif
 #endif /* AFS_VFSINCL_ENV */
@@ -75,7 +75,7 @@
 #include <sys/mnttab.h>
 #include <sys/mntent.h>
 #else
-#ifdef AFS_LINUX22_ENV
+#ifdef AFS_LINUX_ENV
 #include <mntent.h>
 #include <sys/statfs.h>
 #else
@@ -275,7 +275,7 @@ static int
 VCheckPartition(char *part, char *devname, int logging)
 {
     struct afs_stat_st status;
-#if !defined(AFS_LINUX20_ENV) && !defined(AFS_NT40_ENV)
+#if !defined(AFS_LINUX_ENV) && !defined(AFS_NT40_ENV)
     char AFSIDatPath[MAXPATHLEN];
 #endif
 
@@ -313,7 +313,7 @@ VCheckPartition(char *part, char *devname, int logging)
     }
 #endif
 
-#if !defined(AFS_LINUX20_ENV) && !defined(AFS_NT40_ENV)
+#if !defined(AFS_LINUX_ENV) && !defined(AFS_NT40_ENV)
     strcpy(AFSIDatPath, part);
     strcat(AFSIDatPath, "/AFSIDat");
 #ifdef AFS_NAMEI_ENV
@@ -343,7 +343,7 @@ VCheckPartition(char *part, char *devname, int logging)
 	return -1;
 #endif
 #endif /* AFS_NAMEI_ENV */
-#endif /* !AFS_LINUX20_ENV && !AFS_NT40_ENV */
+#endif /* !AFS_LINUX_ENV && !AFS_NT40_ENV */
 
     VInitPartition(part, devname, status.st_dev);
 
@@ -850,7 +850,7 @@ VAttachPartitions(void)
 }
 #endif
 
-#ifdef AFS_LINUX22_ENV
+#ifdef AFS_LINUX_ENV
 int
 VAttachPartitions(void)
 {
@@ -883,7 +883,7 @@ VAttachPartitions(void)
 
     return errors;
 }
-#endif /* AFS_LINUX22_ENV */
+#endif /* AFS_LINUX_ENV */
 
 /* This routine is to be called whenever the actual name of the partition
  * is required. The canonical name is still in part->name.
diff --git a/src/vol/salvaged.c b/src/vol/salvaged.c
index 2f354c535..c4df218b1 100644
--- a/src/vol/salvaged.c
+++ b/src/vol/salvaged.c
@@ -51,7 +51,7 @@
 #endif
 #endif
 #else /* AFS_VFSINCL_ENV */
-#if !defined(AFS_LINUX20_ENV) && !defined(AFS_XBSD_ENV) && !defined(AFS_DARWIN_ENV)
+#if !defined(AFS_LINUX_ENV) && !defined(AFS_XBSD_ENV) && !defined(AFS_DARWIN_ENV)
 #include <sys/inode.h>
 #endif
 #endif /* AFS_VFSINCL_ENV */
@@ -478,6 +478,7 @@ SalvageClient(VolumeId vid, char * pname)
 	switch (sres.state) {
 	case SALVSYNC_STATE_ERROR:
 	    printf("salvageserver reports salvage ended in an error; check log files for more details\n");
+	    AFS_FALLTHROUGH;
 	case SALVSYNC_STATE_DONE:
 	case SALVSYNC_STATE_UNKNOWN:
 	    done = 1;
diff --git a/src/vol/salvager.c b/src/vol/salvager.c
index b850e37c3..7e307e4ce 100644
--- a/src/vol/salvager.c
+++ b/src/vol/salvager.c
@@ -51,7 +51,7 @@
 #endif
 #endif
 #else /* AFS_VFSINCL_ENV */
-#if !defined(AFS_LINUX20_ENV) && !defined(AFS_XBSD_ENV) && !defined(AFS_DARWIN_ENV)
+#if !defined(AFS_LINUX_ENV) && !defined(AFS_XBSD_ENV) && !defined(AFS_DARWIN_ENV)
 #include <sys/inode.h>
 #endif
 #endif /* AFS_VFSINCL_ENV */
diff --git a/src/vol/salvsync-server.c b/src/vol/salvsync-server.c
index 6767f60e6..dd32d8d49 100644
--- a/src/vol/salvsync-server.c
+++ b/src/vol/salvsync-server.c
@@ -940,7 +940,7 @@ LinkNode(struct SalvageQueueNode * parent,
     switch (clone->state) {
     case SALVSYNC_STATE_QUEUED:
 	DeleteFromSalvageQueue(clone);
-
+	AFS_FALLTHROUGH;
     case SALVSYNC_STATE_SALVAGING:
 	switch (parent->state) {
 	case SALVSYNC_STATE_UNKNOWN:
diff --git a/src/vol/vol-info.c b/src/vol/vol-info.c
index 22ac94a48..6423fa8e9 100644
--- a/src/vol/vol-info.c
+++ b/src/vol/vol-info.c
@@ -331,6 +331,7 @@ ReadHdr1(struct VolInfoOpt *opt, IHandle_t * ih, char *to, afs_sfsize_t size,
     struct versionStamp *vsn;
     int bad = 0;
     int code;
+    afs_ino_str_t inode_str;
 
     vsn = (struct versionStamp *)to;
 
@@ -341,7 +342,7 @@ ReadHdr1(struct VolInfoOpt *opt, IHandle_t * ih, char *to, afs_sfsize_t size,
     if (vsn->magic != magic) {
 	bad++;
 	fprintf(stderr, "%s: Inode %s: Bad magic %x (%x): IGNORED\n",
-		progname, PrintInode(NULL, ih->ih_ino), vsn->magic, magic);
+		progname, PrintInode(inode_str, ih->ih_ino), vsn->magic, magic);
     }
 
     /* Check is conditional, in case caller wants to inspect version himself */
@@ -349,23 +350,23 @@ ReadHdr1(struct VolInfoOpt *opt, IHandle_t * ih, char *to, afs_sfsize_t size,
 	bad++;
 	fprintf(stderr, "%s: Inode %s: Bad version %x (%x): IGNORED\n",
 		progname,
-		PrintInode(NULL, ih->ih_ino), vsn->version, version);
+		PrintInode(inode_str, ih->ih_ino), vsn->version, version);
     }
     if (bad && opt->fixHeader) {
 	vsn->magic = magic;
 	vsn->version = version;
 	printf("Special index inode %s has a bad header. Reconstructing...\n",
-	       PrintInode(NULL, ih->ih_ino));
+	       PrintInode(inode_str, ih->ih_ino));
 	code = IH_IWRITE(ih, 0, to, size);
 	if (code != size) {
 	    fprintf(stderr,
 		    "%s: Write failed for inode %s; header left in damaged state\n",
-		    progname, PrintInode(NULL, ih->ih_ino));
+		    progname, PrintInode(inode_str, ih->ih_ino));
 	}
     }
     if (!bad && opt->dumpInfo) {
 	printf("Inode %s: Good magic %x and version %x\n",
-	       PrintInode(NULL, ih->ih_ino), magic, version);
+	       PrintInode(inode_str, ih->ih_ino), magic, version);
     }
     return 0;
 }
@@ -887,6 +888,7 @@ HandleSpecialFile(struct VolInfoOpt *opt, const char *name, struct DiskPartition
     afs_sfsize_t size = -1;
     IHandle_t *ih = NULL;
     FdHandle_t *fdP = NULL;
+    afs_ino_str_t inode_str;
 #ifdef AFS_NAMEI_ENV
     namei_t filename;
 #endif /* AFS_NAMEI_ENV */
@@ -912,7 +914,7 @@ HandleSpecialFile(struct VolInfoOpt *opt, const char *name, struct DiskPartition
 
   error:
     if (opt->dumpInfo) {
-	printf("\t%s inode\t= %s (size = ", name, PrintInode(NULL, inode));
+	printf("\t%s inode\t= %s (size = ", name, PrintInode(inode_str, inode));
 	if (size != -1) {
 	    printf("%lld)\n", size);
 	} else {
@@ -1241,6 +1243,7 @@ volinfo_SaveInode(struct VolInfoOpt *opt, struct VnodeDetails *vdp)
     afs_foff_t total;
     ssize_t len;
     Inode ino = VNDISK_GET_INO(vdp->vnode);
+    afs_ino_str_t inode_str;
 
     if (!VALID_INO(ino)) {
 	return;
@@ -1251,10 +1254,10 @@ volinfo_SaveInode(struct VolInfoOpt *opt, struct VnodeDetails *vdp)
     if (fdP == NULL) {
 	fprintf(stderr,
 		"%s: Can't open inode %s error %d (ignored)\n",
-		progname, PrintInode(NULL, ino), errno);
+		progname, PrintInode(inode_str, ino), errno);
 	return;
     }
-    snprintf(nfile, sizeof nfile, "TmpInode.%s", PrintInode(NULL, ino));
+    snprintf(nfile, sizeof nfile, "TmpInode.%s", PrintInode(inode_str, ino));
     ofd = afs_open(nfile, O_CREAT | O_RDWR | O_TRUNC, 0600);
     if (ofd < 0) {
 	fprintf(stderr,
@@ -1276,7 +1279,7 @@ volinfo_SaveInode(struct VolInfoOpt *opt, struct VnodeDetails *vdp)
 	    unlink(nfile);
 	    fprintf(stderr,
 		    "%s: Error while reading from inode %s (%d)\n",
-		    progname, PrintInode(NULL, ino), errno);
+		    progname, PrintInode(inode_str, ino), errno);
 	    return;
 	}
 	if (len == 0)
@@ -1299,7 +1302,7 @@ volinfo_SaveInode(struct VolInfoOpt *opt, struct VnodeDetails *vdp)
     IH_RELEASE(ih);
     close(ofd);
     printf("... Copied inode %s to file %s (%lu bytes)\n",
-	   PrintInode(NULL, ino), nfile, (unsigned long)total);
+	   PrintInode(inode_str, ino), nfile, (unsigned long)total);
 }
 
 /**
@@ -1812,6 +1815,7 @@ volinfo_PrintVnode(struct VolInfoOpt *opt, struct VnodeDetails *vdp)
     VnodeDiskObject *vnode = vdp->vnode;
     afs_fsize_t fileLength;
     Inode ino;
+    afs_ino_str_t inode_str;
 
     ino = VNDISK_GET_INO(vnode);
     VNDISK_GET_LEN(fileLength, vnode);
@@ -1828,7 +1832,7 @@ volinfo_PrintVnode(struct VolInfoOpt *opt, struct VnodeDetails *vdp)
 	 vnode->dataVersion, vnode->cloned, (afs_uintmax_t) fileLength,
 	 vnode->linkCount, vnode->parent);
     if (opt->dumpInodeNumber)
-	printf(" inode: %s", PrintInode(NULL, ino));
+	printf(" inode: %s", PrintInode(inode_str, ino));
     if (opt->dumpDate)
 	printf(" ServerModTime: %s", date(vnode->serverModifyTime));
 #if defined(AFS_NAMEI_ENV)
diff --git a/src/vol/vol-salvage.c b/src/vol/vol-salvage.c
index 706f9f023..79a68c6bb 100644
--- a/src/vol/vol-salvage.c
+++ b/src/vol/vol-salvage.c
@@ -119,7 +119,7 @@ Vnodes with 0 inode pointers in RW volumes are now deleted.
 #endif
 #endif
 #else /* AFS_VFSINCL_ENV */
-#if !defined(AFS_LINUX20_ENV) && !defined(AFS_XBSD_ENV) && !defined(AFS_DARWIN_ENV)
+#if !defined(AFS_LINUX_ENV) && !defined(AFS_XBSD_ENV) && !defined(AFS_DARWIN_ENV)
 #include <sys/inode.h>
 #endif
 #endif /* AFS_VFSINCL_ENV */
diff --git a/src/vol/volume.c b/src/vol/volume.c
index c2d06681e..4f292e054 100644
--- a/src/vol/volume.c
+++ b/src/vol/volume.c
@@ -58,7 +58,7 @@
 #endif
 #endif
 #else /* AFS_VFSINCL_ENV */
-#if !defined(AFS_AIX_ENV) && !defined(AFS_LINUX20_ENV) && !defined(AFS_XBSD_ENV) && !defined(AFS_DARWIN_ENV)
+#if !defined(AFS_AIX_ENV) && !defined(AFS_LINUX_ENV) && !defined(AFS_XBSD_ENV) && !defined(AFS_DARWIN_ENV)
 #include <sys/fs.h>
 #endif
 #endif /* AFS_VFSINCL_ENV */
@@ -83,7 +83,7 @@
 #if defined(AFS_SGI_ENV)
 #include <mntent.h>
 #else
-#ifndef AFS_LINUX20_ENV
+#ifndef AFS_LINUX_ENV
 #include <fstab.h>		/* Need to find in libc 5, present in libc 6 */
 #endif
 #endif
@@ -1796,15 +1796,18 @@ ShutdownVolumeWalk_r(struct DiskPartition64 * dp, int pass,
 		(V_attachState(vp) != VOL_STATE_PREATTACHED)) {
 		break;
 	    }
+	    AFS_FALLTHROUGH;
 	case 1:
 	    if ((V_attachState(vp) == VOL_STATE_ATTACHED) &&
 		(vp->header == NULL)) {
 		break;
 	    }
+	    AFS_FALLTHROUGH;
 	case 2:
 	    if (VIsExclusiveState(V_attachState(vp))) {
 		break;
 	    }
+	    AFS_FALLTHROUGH;
 	case 3:
 	    *idx = nqp;
 	    DeleteVolumeFromVByPList_r(vp);
@@ -1848,6 +1851,7 @@ VShutdownVolume_r(Volume * vp)
     case VOL_STATE_PREATTACHED:
     case VOL_STATE_ERROR:
 	VChangeState_r(vp, VOL_STATE_UNATTACHED);
+	break;
     case VOL_STATE_UNATTACHED:
     case VOL_STATE_DELETED:
 	break;
diff --git a/src/volser/volmain.c b/src/volser/volmain.c
index 2bbbc9214..40306d8d6 100644
--- a/src/volser/volmain.c
+++ b/src/volser/volmain.c
@@ -185,7 +185,7 @@ int
 volser_syscall(afs_uint32 a3, afs_uint32 a4, void *a5)
 {
     afs_uint32 rcode;
-#ifndef AFS_LINUX20_ENV
+#ifndef AFS_LINUX_ENV
     void (*old) (int);
 
     old = signal(SIGSYS, SIG_IGN);
@@ -193,7 +193,7 @@ volser_syscall(afs_uint32 a3, afs_uint32 a4, void *a5)
     rcode =
 	syscall(AFS_SYSCALL /* AFS_SYSCALL */ , 28 /* AFSCALL_CALL */ , a3,
 		a4, a5);
-#ifndef AFS_LINUX20_ENV
+#ifndef AFS_LINUX_ENV
     signal(SIGSYS, old);
 #endif
 
@@ -630,7 +630,11 @@ main(int argc, char **argv)
 
     LogCommandLine(argc, argv, "Volserver", VolserVersion, "Starting AFS",
 		   Log);
-    if (afsconf_GetLatestKey(tdir, NULL, NULL) == 0) {
+    if (afsconf_CountKeys(tdir) == 0) {
+	Log("WARNING: No encryption keys found! "
+	    "All authenticated accesses will fail. "
+	    "Run akeyconvert or asetkey to import encryption keys.\n");
+    } else if (afsconf_GetLatestKey(tdir, NULL, NULL) == 0) {
 	LogDesWarning();
     }
 
diff --git a/src/volser/volprocs.c b/src/volser/volprocs.c
index 745bdd328..710d4befa 100644
--- a/src/volser/volprocs.c
+++ b/src/volser/volprocs.c
@@ -2316,6 +2316,7 @@ GetVolInfo(afs_uint32 partId,
 	case VOL_INFO_LIST_SINGLE:
 	    Log("1 Volser: GetVolInfo: Volume %" AFS_VOLID_FMT " (%s:%s) will be destroyed on next salvage\n",
 		afs_printable_VolumeId_lu(volumeId), pname, volname);
+	    goto drop;
 
 	default:
 	    goto drop;
diff --git a/src/volser/vos.c b/src/volser/vos.c
index 379a19c38..e43e9fb3f 100644
--- a/src/volser/vos.c
+++ b/src/volser/vos.c
@@ -4053,33 +4053,32 @@ VolserStatus(struct cmd_syndesc *as, void *arock)
 	}
 	if (pntr->iflags) {
 	    fprintf(STDOUT, "attachFlags:  ");
-	    switch (pntr->iflags) {
-	    case ITOffline:
+	    if ((pntr->iflags & ITOffline) != 0) {
 		fprintf(STDOUT, "offline ");
-		break;
-	    case ITBusy:
+	    }
+	    if ((pntr->iflags & ITBusy) != 0) {
 		fprintf(STDOUT, "busy ");
-		break;
-	    case ITReadOnly:
+	    }
+	    if ((pntr->iflags & ITReadOnly) != 0) {
 		fprintf(STDOUT, "readonly ");
-		break;
-	    case ITCreate:
+	    }
+	    if ((pntr->iflags & ITCreate) != 0) {
 		fprintf(STDOUT, "create ");
-		break;
-	    case ITCreateVolID:
+	    }
+	    if ((pntr->iflags & ITCreateVolID) != 0) {
 		fprintf(STDOUT, "create volid ");
-		break;
 	    }
 	    fprintf(STDOUT, "\n");
 	}
 	if (pntr->vflags) {
 	    fprintf(STDOUT, "volumeStatus: ");
-	    switch (pntr->vflags) {
-	    case VTDeleteOnSalvage:
+	    if ((pntr->vflags & VTDeleteOnSalvage) != 0) {
 		fprintf(STDOUT, "deleteOnSalvage ");
-	    case VTOutOfService:
+	    }
+	    if ((pntr->vflags & VTOutOfService) != 0) {
 		fprintf(STDOUT, "outOfService ");
-	    case VTDeleted:
+	    }
+	    if ((pntr->vflags & VTDeleted) != 0) {
 		fprintf(STDOUT, "deleted ");
 	    }
 	    fprintf(STDOUT, "\n");
diff --git a/tests/Makefile.in b/tests/Makefile.in
index 23f1fa096..69f709ddd 100644
--- a/tests/Makefile.in
+++ b/tests/Makefile.in
@@ -6,8 +6,8 @@ abs_top_builddir=@abs_top_builddir@
 include @TOP_OBJDIR@/src/config/Makefile.config
 include @TOP_OBJDIR@/src/config/Makefile.pthread
 
-MODULE_CFLAGS = -DSOURCE='"$(abs_top_srcdir)/tests"' \
-	-DBUILD='"$(abs_top_builddir)/tests"'
+MODULE_CFLAGS = -DC_TAP_SOURCE='"$(abs_top_srcdir)/tests"' \
+	-DC_TAP_BUILD='"$(abs_top_builddir)/tests"'
 
 SUBDIRS = tap common auth util cmd volser opr rx
 
@@ -23,7 +23,7 @@ runtests.o: $(srcdir)/runtests.c
 check test tests: runtests
 	@for A in $(SUBDIRS); do cd $$A && $(MAKE) $@ && cd .. || exit 1; done
 	MAKECHECK=1 ./libwrap @TOP_OBJDIR@/lib \
-	    ./runtests $(abs_top_srcdir)/tests/TESTS
+	    ./runtests -v -l $(abs_top_srcdir)/tests/TESTS
 
 install:
 
diff --git a/tests/auth/keys-t.c b/tests/auth/keys-t.c
index 789b49bc2..f0556ceea 100644
--- a/tests/auth/keys-t.c
+++ b/tests/auth/keys-t.c
@@ -128,11 +128,11 @@ int main(int argc, char **argv)
 	goto out;
 
     /* Work out the path to our KeyFile. If the test harness hasn't set
-     * the SOURCE environment variable, then assume it is in our CWD */
-    if (getenv("SOURCE") == NULL) {
+     * the C_TAP_SOURCE environment variable, then assume it is in our CWD */
+    if (getenv("C_TAP_SOURCE") == NULL) {
 	keyfilesrc = strdup("KeyFile");
     } else {
-	if (asprintf(&keyfilesrc, "%s/auth/KeyFile", getenv("SOURCE")) == -1)
+	if (asprintf(&keyfilesrc, "%s/auth/KeyFile", getenv("C_TAP_SOURCE")) == -1)
 	    goto out;
     }
 
diff --git a/tests/bozo/bos-man-t b/tests/bozo/bos-man-t
index fedcf5863..b7a3d3222 100755
--- a/tests/bozo/bos-man-t
+++ b/tests/bozo/bos-man-t
@@ -8,7 +8,7 @@ use mancheck_utils;
 
 # Set this to the bare command to test
 my $command = 'bos';
-my $builddir = $ENV{BUILD};
+my $builddir = $ENV{C_TAP_BUILD};
 if (!$builddir) {
     $builddir = dirname($0) . "/..";
 }
diff --git a/tests/bucoord/backup-man-t b/tests/bucoord/backup-man-t
index d8df2c823..162fd2cf9 100755
--- a/tests/bucoord/backup-man-t
+++ b/tests/bucoord/backup-man-t
@@ -8,7 +8,7 @@ use mancheck_utils;
 
 # Set this to the bare command to test
 my $command = 'backup';
-my $builddir = $ENV{BUILD};
+my $builddir = $ENV{C_TAP_BUILD};
 if (!$builddir) {
     $builddir = dirname($0) . "/..";
 }
diff --git a/tests/cmd/command-t.c b/tests/cmd/command-t.c
index 796ff22c7..71efd398c 100644
--- a/tests/cmd/command-t.c
+++ b/tests/cmd/command-t.c
@@ -360,10 +360,10 @@ main(int argc, char **argv)
     cmd_FreeArgv(tv);
 
     /* Now, try adding a configuration file into the mix */
-    if (getenv("SOURCE") == NULL)
+    if (getenv("C_TAP_SOURCE") == NULL)
 	path = strdup("test1.conf");
     else {
-	if (asprintf(&path, "%s/cmd/test1.conf", getenv("SOURCE")) < 0)
+	if (asprintf(&path, "%s/cmd/test1.conf", getenv("C_TAP_SOURCE")) < 0)
 	    path = NULL;
     }
     if (path != NULL) {
diff --git a/tests/common/servers.c b/tests/common/servers.c
index 8a7d7a638..de85cd0d2 100644
--- a/tests/common/servers.c
+++ b/tests/common/servers.c
@@ -30,7 +30,7 @@ afstest_StartVLServer(char *dirname, pid_t *serverPid)
 	char *binPath, *logPath, *dbPath, *build;
 
 	/* Child */
-	build = getenv("BUILD");
+	build = getenv("C_TAP_BUILD");
 
 	if (build == NULL)
 	    build = "..";
diff --git a/tests/kauth/kas-man-t b/tests/kauth/kas-man-t
index 162958896..508dc4769 100755
--- a/tests/kauth/kas-man-t
+++ b/tests/kauth/kas-man-t
@@ -8,7 +8,7 @@ use mancheck_utils;
 
 # Set this to the bare command to test
 my $command = 'kas';
-my $builddir = $ENV{BUILD};
+my $builddir = $ENV{C_TAP_BUILD};
 if (!$builddir) {
     $builddir = dirname($0) . "/..";
 }
diff --git a/tests/ptserver/pt_util-t b/tests/ptserver/pt_util-t
index 8d3cdcb87..2267ceeb3 100755
--- a/tests/ptserver/pt_util-t
+++ b/tests/ptserver/pt_util-t
@@ -6,7 +6,7 @@ use warnings;
 use File::Basename;
 use Test::More tests=>2;
 
-my $builddir = $ENV{BUILD};
+my $builddir = $ENV{C_TAP_BUILD};
 if (!$builddir) {
   $builddir = dirname($0)."/..";
 }
diff --git a/tests/ptserver/pts-man-t b/tests/ptserver/pts-man-t
index 60645ea2b..288458702 100755
--- a/tests/ptserver/pts-man-t
+++ b/tests/ptserver/pts-man-t
@@ -8,7 +8,7 @@ use mancheck_utils;
 
 # Set this to the bare command to test
 my $command = 'pts';
-my $builddir = $ENV{BUILD};
+my $builddir = $ENV{C_TAP_BUILD};
 if (!$builddir) {
     $builddir = dirname($0) . "/..";
 }
diff --git a/tests/rpctestlib/rpc_test_procs.c b/tests/rpctestlib/rpc_test_procs.c
index 586324207..4f3740041 100644
--- a/tests/rpctestlib/rpc_test_procs.c
+++ b/tests/rpctestlib/rpc_test_procs.c
@@ -220,7 +220,7 @@ afs_int32 init_fs_channel(rpc_test_request_ctx **octx, char *cb_if,
     sprintf(ctx->fs_addr_s, "%s", fs_addr_s);
 
 #if defined(RPC_TEST_ADD_ADDRESSES)
-#if defined(AFS_LINUX26_ENV)
+#if defined(AFS_LINUX_ENV)
     sprintf(cmd, "ip addr add %s/%s dev %s label %s", listen_addr_s, prefix,
             cb_if, cb_if);
     code = system(cmd);
@@ -362,7 +362,7 @@ destroy_fs_channel(rpc_test_request_ctx *ctx)
 {
     afs_int32 code = 0;
 #if defined(RPC_TEST_ADD_ADDRESSES)
-#if defined(AFS_LINUX26_ENV)
+#if defined(AFS_LINUX_ENV)
     sprintf(cmd, "ip addr del %s/%s dev %s label %s", ctx->cb_listen_addr_s,
             ctx->cb_prefix_s, ctx->cb_if_s, ctx->cb_if_s);
     code = system(cmd);
diff --git a/tests/rx/perf-t b/tests/rx/perf-t
index 025d6b5e3..530630aed 100755
--- a/tests/rx/perf-t
+++ b/tests/rx/perf-t
@@ -7,7 +7,7 @@ use Test::More tests=>4;
 use POSIX qw(:sys_wait_h :signal_h);
 
 my $port = 4000;
-my $build = $ENV{BUILD};
+my $build = $ENV{C_TAP_BUILD};
 $build = ".." if (!defined($build));
 my $rxperf = $build."/../src/tools/rxperf/rxperf";
 
diff --git a/tests/venus/fs-man-t b/tests/venus/fs-man-t
index 3267b5ddd..cfbf6c0c8 100755
--- a/tests/venus/fs-man-t
+++ b/tests/venus/fs-man-t
@@ -8,7 +8,7 @@ use mancheck_utils;
 
 # Set this to the bare command to test
 my $command = 'fs';
-my $builddir = $ENV{BUILD};
+my $builddir = $ENV{C_TAP_BUILD};
 if (!$builddir) {
     $builddir = dirname($0) . "/..";
 }
diff --git a/tests/volser/vos-man-t b/tests/volser/vos-man-t
index 2e2cc3560..381f5ba7d 100755
--- a/tests/volser/vos-man-t
+++ b/tests/volser/vos-man-t
@@ -8,7 +8,7 @@ use mancheck_utils;
 
 # Set this to the bare command to test
 my $command = 'vos';
-my $builddir = $ENV{BUILD};
+my $builddir = $ENV{C_TAP_BUILD};
 if (!$builddir) {
     $builddir = dirname($0) . "/..";
 }
diff --git a/tests/volser/vos-t.c b/tests/volser/vos-t.c
index 75b0c50ba..41e74bdc5 100644
--- a/tests/volser/vos-t.c
+++ b/tests/volser/vos-t.c
@@ -69,7 +69,7 @@ TestListAddrs(struct ubik_client *client, char *dirname)
 	close(outpipe[0]);
 	close(outpipe[1]);
 
-	build = getenv("BUILD");
+	build = getenv("C_TAP_BUILD");
 	if (build == NULL)
 	    build = "..";
 
-- 
2.37.1

