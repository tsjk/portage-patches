From 00a2a85d8d4835fc7c6e45d9c74aef167a247f97 Mon Sep 17 00:00:00 2001
From: Woody Suwalski <terraluna977@gmail.com>
Date: Sat, 24 Feb 2018 09:51:53 -0500
Subject: [PATCH] Exfat-nofuse fix for kernel 4.16

Signed-off-by: Woody Suwalski <terraluna977@gmail.com>
---
 exfat_super.c | 83 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-
 1 file changed, 82 insertions(+), 1 deletion(-)

diff --git a/exfat_super.c b/exfat_super.c
index ab828c3..88d8b68 100644
--- a/exfat_super.c
+++ b/exfat_super.c
@@ -74,6 +74,9 @@
 #include <linux/namei.h>
 #include <asm/current.h>
 #include <asm/unaligned.h>
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,16,0)
+#include <linux/iversion.h>
+#endif
 
 #include "exfat_version.h"
 #include "exfat_config.h"
@@ -747,7 +750,11 @@ static int exfat_create(struct inode *dir, struct dentry *dentry, int mode,
 			err = -EIO;
 		goto out;
 	}
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,16,0)
 	dir->i_version++;
+#else
+	inode_inc_iversion(dir);
+#endif
 	dir->i_ctime = dir->i_mtime = dir->i_atime = current_time(dir);
 	if (IS_DIRSYNC(dir))
 		(void) exfat_sync_inode(dir);
@@ -761,11 +768,19 @@ static int exfat_create(struct inode *dir, struct dentry *dentry, int mode,
 		err = PTR_ERR(inode);
 		goto out;
 	}
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,16,0)
 	inode->i_version++;
+#else
+	inode_inc_iversion(inode);
+#endif
 	inode->i_mtime = inode->i_atime = inode->i_ctime = current_time(inode);
 	/* timestamp is already written, so mark_inode_dirty() is unnecessary. */
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,16,0)
 	dentry->d_time = dentry->d_parent->d_inode->i_version;
+#else
+	dentry->d_time = inode_query_iversion(dentry->d_parent->d_inode);
+#endif
 	d_instantiate(dentry, inode);
 
 out:
@@ -854,7 +869,12 @@ static struct dentry *exfat_lookup(struct inode *dir, struct dentry *dentry,
 	}
 out:
 	__unlock_super(sb);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,16,0)
 	dentry->d_time = dentry->d_parent->d_inode->i_version;
+#else
+	dentry->d_time = inode_query_iversion(dentry->d_parent->d_inode);
+#endif
+
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,38)
 	dentry->d_op = sb->s_root->d_op;
 	dentry = d_splice_alias(inode, dentry);
@@ -864,8 +884,13 @@ static struct dentry *exfat_lookup(struct inode *dir, struct dentry *dentry,
 	}
 #else
 	dentry = d_splice_alias(inode, dentry);
-	if (dentry)
+	if (dentry) {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,16,0)
 		dentry->d_time = dentry->d_parent->d_inode->i_version;
+#else
+		dentry->d_time = inode_query_iversion(dentry->d_parent->d_inode);
+#endif
+	}
 #endif
 	DPRINTK("exfat_lookup exited 2\n");
 	return dentry;
@@ -896,7 +921,11 @@ static int exfat_unlink(struct inode *dir, struct dentry *dentry)
 			err = -EIO;
 		goto out;
 	}
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,16,0)
 	dir->i_version++;
+#else
+	inode_inc_iversion(dir);
+#endif
 	dir->i_mtime = dir->i_atime = current_time(dir);
 	if (IS_DIRSYNC(dir))
 		(void) exfat_sync_inode(dir);
@@ -953,7 +982,11 @@ static int exfat_symlink(struct inode *dir, struct dentry *dentry, const char *t
 		goto out;
 	}
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,16,0)
 	dir->i_version++;
+#else
+	inode_inc_iversion(dir);
+#endif
 	dir->i_ctime = dir->i_mtime = dir->i_atime = current_time(dir);
 	if (IS_DIRSYNC(dir))
 		(void) exfat_sync_inode(dir);
@@ -967,7 +1000,11 @@ static int exfat_symlink(struct inode *dir, struct dentry *dentry, const char *t
 		err = PTR_ERR(inode);
 		goto out;
 	}
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,16,0)
 	inode->i_version++;
+#else
+	inode_inc_iversion(inode);
+#endif
 	inode->i_mtime = inode->i_atime = inode->i_ctime = current_time(inode);
 	/* timestamp is already written, so mark_inode_dirty() is unneeded. */
 
@@ -978,7 +1015,11 @@ static int exfat_symlink(struct inode *dir, struct dentry *dentry, const char *t
 	}
 	memcpy(EXFAT_I(inode)->target, target, len+1);
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,16,0)
 	dentry->d_time = dentry->d_parent->d_inode->i_version;
+#else
+	dentry->d_time = inode_query_iversion(dentry->d_parent->d_inode);
+#endif
 	d_instantiate(dentry, inode);
 
 out:
@@ -1017,7 +1058,11 @@ static int exfat_mkdir(struct inode *dir, struct dentry *dentry, int mode)
 			err = -EIO;
 		goto out;
 	}
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,16,0)
 	dir->i_version++;
+#else
+	inode_inc_iversion(dir);
+#endif
 	dir->i_ctime = dir->i_mtime = dir->i_atime = current_time(dir);
 	if (IS_DIRSYNC(dir))
 		(void) exfat_sync_inode(dir);
@@ -1032,11 +1077,19 @@ static int exfat_mkdir(struct inode *dir, struct dentry *dentry, int mode)
 		err = PTR_ERR(inode);
 		goto out;
 	}
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,16,0)
 	inode->i_version++;
+#else
+	inode_inc_iversion(inode);
+#endif
 	inode->i_mtime = inode->i_atime = inode->i_ctime = current_time(inode);
 	/* timestamp is already written, so mark_inode_dirty() is unneeded. */
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,16,0)
 	dentry->d_time = dentry->d_parent->d_inode->i_version;
+#else
+	dentry->d_time = inode_query_iversion(dentry->d_parent->d_inode);
+#endif
 	d_instantiate(dentry, inode);
 
 out:
@@ -1071,7 +1124,11 @@ static int exfat_rmdir(struct inode *dir, struct dentry *dentry)
 			err = -EIO;
 		goto out;
 	}
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,16,0)
 	dir->i_version++;
+#else
+	inode_inc_iversion(dir);
+#endif
 	dir->i_mtime = dir->i_atime = current_time(dir);
 	if (IS_DIRSYNC(dir))
 		(void) exfat_sync_inode(dir);
@@ -1134,7 +1191,11 @@ static int exfat_rename(struct inode *old_dir, struct dentry *old_dentry,
 			err = -EIO;
 		goto out;
 	}
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,16,0)
 	new_dir->i_version++;
+#else
+	inode_inc_iversion(new_dir);
+#endif
 	new_dir->i_ctime = new_dir->i_mtime = new_dir->i_atime = current_time(new_dir);
 	if (IS_DIRSYNC(new_dir))
 		(void) exfat_sync_inode(new_dir);
@@ -1157,7 +1218,11 @@ static int exfat_rename(struct inode *old_dir, struct dentry *old_dentry,
 			inc_nlink(new_dir);
 	}
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,16,0)
 	old_dir->i_version++;
+#else
+	inode_inc_iversion(old_dir);
+#endif
 	old_dir->i_ctime = old_dir->i_mtime = current_time(old_dir);
 	if (IS_DIRSYNC(old_dir))
 		(void) exfat_sync_inode(old_dir);
@@ -1872,7 +1937,11 @@ static int exfat_fill_inode(struct inode *inode, FILE_ID_T *fid)
 	EXFAT_I(inode)->target = NULL;
 	inode->i_uid = sbi->options.fs_uid;
 	inode->i_gid = sbi->options.fs_gid;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,16,0)
 	inode->i_version++;
+#else
+	inode_inc_iversion(inode);
+#endif
 	inode->i_generation = get_seconds();
 
 	if (info.Attr & ATTR_SUBDIR) { /* directory */
@@ -1932,7 +2001,11 @@ static struct inode *exfat_build_inode(struct super_block *sb,
 		goto out;
 	}
 	inode->i_ino = iunique(sb, EXFAT_ROOT_INO);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,16,0)
 	inode->i_version = 1;
+#else
+	inode_set_iversion(inode, 1);
+#endif
 	err = exfat_fill_inode(inode, fid);
 	if (err) {
 		iput(inode);
@@ -2422,7 +2495,11 @@ static int exfat_read_root(struct inode *inode)
 
 	inode->i_uid = sbi->options.fs_uid;
 	inode->i_gid = sbi->options.fs_gid;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,16,0)
 	inode->i_version++;
+#else
+	inode_inc_iversion(inode);
+#endif
 	inode->i_generation = 0;
 	inode->i_mode = exfat_make_mode(sbi, ATTR_SUBDIR, S_IRWXUGO);
 	inode->i_op = &exfat_dir_inode_operations;
@@ -2530,7 +2607,11 @@ static int exfat_fill_super(struct super_block *sb, void *data, int silent)
 	if (!root_inode)
 		goto out_fail2;
 	root_inode->i_ino = EXFAT_ROOT_INO;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,16,0)
 	root_inode->i_version = 1;
+#else
+	inode_set_iversion(root_inode, 1);
+#endif
 	error = exfat_read_root(root_inode);
 	if (error < 0)
 		goto out_fail2;
